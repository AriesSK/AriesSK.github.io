{"posts":[{"title":"54. 二叉搜索树的第k大节点","content":"知识点 运算符优先级 关于运算符的优先级，见21. 调整数组顺序使奇数位于偶数前面 下面两种的运算结果是一样的，这题中都可以： let k = 1; console.log(!--k); // true k = 1; console.log(!(--k)); // true 不过这样写容易出错，还是老实写： let k = 1; console.log(--k == 0); // true 题解 深度优先搜索 二叉搜索树的中序遍历就是升序数组，本题进行逆向的中序遍历，并且设置isFound标志找到了目标，提前结束递归（题目规定不会有空树的情况）： var kthLargest = function(root, k) { let isFound = false, res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (isFound) return; if (k - 1) --k; else { res = root.val; isFound = true; } dfs(root.left); } }; 后来发现isFound可以省略，当k减到 000 时即代表找到了目标： var kthLargest = function(root, k) { let res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (!k) return; // 先自减再判断是否为 0 if (!--k) res = root.val; dfs(root.left); } }; ","link":"https://AriesSK.github.io/post/jianzhi_54/"},{"title":"36. 二叉搜索树与双向链表","content":"知识点 二叉搜索树（二叉查找树，二叉排序树） 定义： 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。 二叉搜索树（Binary Search Tree, BST）的中序遍历是升序序列。 三种深度优先搜索 前中后指的是root节点在三个节点中的位置 前序遍历： var dfs = function(root) { if (!root) return; console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.left); dfs(root.right); } 中序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.right); } 后序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); dfs(root.right); console.log(root.val); // 操作 root 节点，比如打印其值 } 题解 法一：使用队列 我一开始想到的方法，在中序遍历的同时使用一个队列按顺序保存每一个节点，再按顺序输出节点并连接： var treeToDoublyList = function(root) { if (!root) return root; const list = []; dfs(root); const head = list.shift(); let ptr = head; while(list.length) { ptr.right = list.shift(); ptr.right.left = ptr; ptr = ptr.right; } ptr.right = head; head.left = ptr; return head; function dfs(root) { if (!root) return; dfs(root.left); list.push(root); dfs(root.right); } }; 法二：原地算法 事实上并不需要使用队列保存节点，使用一个``pre和一个curr`指针分别保存上一个节点和当前节点即可： var treeToDoublyList = function(root) { let pre, curr; // 空树 if (!root) return root; dfs(root); // 完成中序遍历后还需将头节点和尾节点连接起来成环 head.left = pre; pre.right = head; return head; function dfs(curr) { if (!curr) return; // 先找到最左侧的叶子节点，是链表的头节点 dfs(curr.left); if (pre) pre.right = curr; else head = curr; curr.left = pre; // 更新 curr pre = curr; dfs(curr.right); } }; ","link":"https://AriesSK.github.io/post/jianzhi_36/"},{"title":"34. 二叉树中和为某一值的路径","content":"知识点 JavaScript 的坑 做这道题的过程中遇到了两个坑，记录一下。 声明全局变量 这道题中我需要在dfs(root, target)中使用path和res，所以一开始在最外层声明了变量，即全局变量，像下面这样： const path = [], res = []; var pathSum = function(root, target) {} var dfs = function(root, target) {} 这样写能够通过 Leetcode 的测试用例，但同样的用例在正式提交时却会报错，这是因为上一次用例运行留下的全局变量并没有被销毁，会使之后的用例运行出错，所以应当将dfs(root, target)设置为局部函数： var pathSum = function(root, target) { const path = [], res = []; function dfs(root, target) {} } 引用值 这道题里的path是引用对象，使用res.push([path])是将这个引用对象放入了res中，而后续path对象改变时，res中的path的会随之改变，输出错误结果，正确处理需要深拷贝path存入res中，需要用到展开运算符...。 res.push([...path]); 对于一级基础数据，展开运算符实现深拷贝； 对于二级及以上的复杂数据，展开运算符实现浅拷贝。 题解 深度优先搜索 这道题需要遍历到叶子节点并且输出所有可能，因此无法剪枝。 使用path保存当前遍历的路径，res保存符合要求的路径，需要注意的是在返回上一层递归的时候需要通过path.pop()将path恢复至上一层节点： var pathSum = function(root, target) { const path = [], res = []; dfs(root, target); return res; // 声明函数 function dfs(root, target) { if (!root) return; path.push(root.val); target -= root.val; // 深拷贝 path 并存入 res if (!root.left &amp;&amp; !root.right &amp;&amp; !target) res.push([...path]); dfs(root.left, target); dfs(root.right, target); // 恢复 path path.pop(); }; }; ","link":"https://AriesSK.github.io/post/jianzhi_34/"},{"title":"13. 机器人的运动范围","content":"知识点 JavaScript 中的函数传值 js 中的所有函数的参数都是按值传递的，这意味着函数外的值会被复制到函数内部的参数中，如果是原始值，就跟原始值变量的复制一样，如果是引用值，就和引用值变量的复制一样。 按值传递参数： 外部的值被复制到函数的一个局部变量中，这两个值相互独立，互不干扰； 按引用传递参数： 外部的值在内存中的位置会被保存到函数的一个局部变量中，意味着对局部变量的修改会反应到函数外部，这在 js 中是不可能的。 原始值的按值传递举例，可以看到传入参数与外部值相互独立，互不干扰： function addOne (num) { num += 1; return num; } let count = 20; let res = addOne(count); // count === 20, res === 30 引用值的按值传递举例，如果是按引用传递，那么在新建obj对象的时候，person应该自动将指针改为指向&quot;Aries&quot;的对象，但事实上并没有。这证明了是按值传递的，传递了引用值，而引用的对象是保存在全局作用域，因此可以通过obj访问引用对象修改属性： function setName(obj) { obj.name = &quot;AriesSK&quot;; obj = new Object(); obj.name = &quot;Aries&quot; return num; } let person = new Object(); setName(person); // person.name === &quot;AriesSK&quot; 题解 法一：深度优先搜索 我的解法： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k, res); }; var dfs = function(visit, i, j, k, res) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &lt; 0 || i &gt;= visit.length || j &lt; 0 || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return res; visit[i][j] = 1; res = dfs(visit, i + 1, j, k, res); res = dfs(visit, i - 1, j, k, res); res = dfs(visit, i, j + 1, k, res); res = dfs(visit, i, j - 1, k, res); return ++res; } dfs 解法的优化，省略了不必要的res，并且由于从 (0,0)(0,0)(0,0) 开始，由图可以看出仅通过向右和向下两个方向即可访问所有可达解： var movingCount = function(m, n, k) { const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k); }; var dfs = function(visit, i, j, k) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if ( i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return 0; visit[i][j] = 1; return 1 + dfs(visit, i + 1, j, k) + dfs(visit, i, j + 1, k); } 法二：广度优先搜索 bfs 需要用到队列和循环，无需递归： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); const queue = []; queue.unshift([0, 0]); while(queue.length &gt; 0) { let temp = queue.pop(); let i = temp[0], j = temp[1], s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) continue; visit[i][j] = 1; ++res; queue.unshift([i + 1, j]); queue.unshift([i, j + 1]); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_13/"},{"title":"12. 矩阵中的路径","content":"知识点 深度优先搜索 通过递归的方式，先朝一个方向搜索到底，再回溯至上个节点，沿另一个方向搜索，一次类推。 剪枝 在搜索过程中遇到该路径不可能与目标匹配成功的情况时，应当立即返回，这叫可行性剪枝。 题解 深度优先搜索 + 剪枝 递归终止条件： 返回 false：索引越界 || 当前矩阵元素与目标不匹配（包括已访问）； 返回true：k === word.length - 1，即word已完全匹配。 递推工作： 标记已访问：将board[i][j]修改为 0，防止重复搜索； 搜索下一元素：朝当前元素上、下、左、右四个方向进行下一层递归，使用||连接代表只需找到一条可行路径，记录结果至res； 还原：将board[i][j]还原至初始值word[k]。 var exist = function(board, word) { for (let i = 0; i &lt; board.length; ++i) { for (let j = 0; j &lt; board[0].length; ++j) { if (dfs(board, word, i, j, 0)) return true; } } return false; }; var dfs = function(board, word, i, j, k) { if (i &gt;= board.length || i &lt; 0 || j &gt; board[0].length || j &lt; 0 || board[i][j] !== word[k]) return false; if (k === word.length - 1) return true; // 标记已访问 board[i][j] = 0; const res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1); // 恢复原数组 board[i][j] = word[k]; return res; } ","link":"https://AriesSK.github.io/post/jianzhi_12/"},{"title":"58 - I. 翻转字符单词顺序","content":"知识点 JavaScript 的正则表达式 语法： /正则表达式主体/修饰符(可选) 修饰符不区分大小写： 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符 [0-9] 查找任何从 0 至 9 的数字 (x|y) 查找任何以 | 分隔的选项 元字符是拥有特殊含义的字符： 元字符 描述 \\d 查找数字 \\s 查找空白字符 \\b 匹配单词边界 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 量词: 量词 描述 n+ 匹配任何包含至少一个 n 的字符串 n* 匹配任何包含零个或多个 n 的字符串 n? 匹配任何包含零个或一个 n 的字符串 JavaScript 的字符串函数 本题中使用的一些字符串函数及它们的时间复杂度： trim() // 去除字符串头尾的空格 O(n) split() // 拆分成数组 O(n) reverse() // 反转数组 O(n) join() // 使用特定分隔符将数组连接成字符串 O(n) 其中需要重点说明split()举例如下： let s = &quot;a b c&quot; s.split() // [&quot;a b c&quot;] // 直接返回数组 s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开 s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素 s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数 题解 法一：字符串函数 首先想到使用tirm()删除头尾空格，split(&quot; &quot;)拆分成数组，从数组末尾开始拼接： var reverseWords = function(s) { const arr = s.trim().split(&quot; &quot;); let res = &quot;&quot;; for (let i = arr.length - 1; i &gt;= 0; --i) { if (arr[i] === &quot;&quot;) continue; res += i ? arr[i] + &quot; &quot; : arr[i]; } return res; }; 事实上使用字符串函数代码可以更加简洁： var reverseWords = function(s) { return s.trim().split(/\\s+/).reverse().join(' '); }; 法二：双指针 var reverseWords = function(s) { s = s.trim(); let left = s.length - 1, right = left; let res = &quot;&quot;; // 保证 left 能够取到 0 while (left &gt;= 0) { // 找到第一个空格 while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left; res += s.substring(left + 1, right + 1) + &quot; &quot;; // 忽略空格找到第一个字符 while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left; right = left; } // 删去最后末尾多余的一个空格 return res.trim(); }; ","link":"https://AriesSK.github.io/post/jianzhi_58_i/"},{"title":"57. 和为s的两个数字","content":"知识点 JavaScript 的const 在允许的情况下，推荐使用const进行声明，const声明后无法重新赋值，但可以修改其属性值。 题解 双指针的简单应用： var twoSum = function(nums, target) { let left = 0, right = nums.length - 1; const res = []; // 若允许同一个数自己加自己则取 = while (left &lt; right) { // 在值是正数的情况下，改加为减能够有效防止值溢出 if (nums[left] &gt; target - nums[right]) --right; else if (nums[left] &lt; target - nums[right]) ++left; else { res.push(nums[left]); res.push(nums[right]); // 不适用 break 会导致无限循环入栈至溢出 break; } } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_57/"},{"title":"21. 调整数组顺序使奇数位于偶数前面","content":"知识点 JavaScript 中的运算符优先级 在写代码时需要注意运算符的优先级，如下由于!的运算优先级高于%，因此加不加()是两种结果： let num = 2; console.log(!num % 2); // 0 console.log(!(num % 2)); // true 题解 简单的双指针运用： var exchange = function(nums) { let left = 0, right = nums.length - 1; // while 中是否取等号均可 while (left &lt; right) { if (nums[left] % 2) ++left; else if (!(nums[right] % 2)) --right; else { let temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } return nums; }; ","link":"https://AriesSK.github.io/post/jianzhi_21/"},{"title":"52. 两个链表的第一个公共节点","content":"知识点 这题使用的是一种特别的解题思路： 你变成我，走过我走过的路； 我变成你，走过你走过的路； 然后我们便相遇了… 题解 法一：哈希表 链表 AAA 长度 mmm，链表 BBB 长度为 nnn。 看到这题的第一想法是暴力遍历，时间复杂度是 O(m∗n)O(m * n)O(m∗n)， 第二想法是用哈希表，时间复杂度降低为 O(m+n)O(m + n)O(m+n)，但需要 O(m)O(m)O(m) 的空间： var getIntersectionNode = function(headA, headB) { let ptra = headA, ptrb = headB; const set = new Set(); while(ptra) { set.add(ptra); ptra = ptra.next; } while(ptrb) { if (set.has(ptrb)) return ptrb; ptrb = ptrb.next; } return null; }; 法二：双指针 但题目要求时间复杂度降低为 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1) 。 这题用了一种比较特别的思路： 首先假设链表 AAA 有 aaa 个节点，链表 BBB 有 bbb 个节点， 它们的公共节点有 ccc 个，它们的第一个公共节点为 nodecnodecnodec； 设置指针ptra遍历链表 AAA，随后再从 headBheadBheadB 开始遍历，到达 nodecnodecnodec 时遍历长度为 a+(b−c)a + (b - c)a+(b−c)； 设置指针ptrb遍历链表 BBB，随后再从 headAheadAheadA 开始遍历，到达 nodecnodecnodec 时遍历长度为 b+(a−c)b + (a - c)b+(a−c)。 可以发现此时两指针相交于 nodecnodecnodec 并且遍历过的节点总数是相同的，这就为算法的实现提供了条件——每次使ptra和ptrb同时前进一个节点。 两条链表没有公共节点的情况就等同于两条链表的公共节点是链表结尾的 nullnullnull，因此在完成遍历后两指针同时为 nullnullnull 时会返回 nullnullnull： var getIntersectionNode = function(headA, headB) { let ptra = headA, ptrb = headB; while (ptra !== ptrb) { // 注意每一轮循环只因当修改一次指针的值 若这里使用条件语句则应当用 if else ptra = !ptra ? headB : ptra.next; ptrb = !ptrb ? headA : ptrb.next; } return ptra; }; ","link":"https://AriesSK.github.io/post/jianzhi_52/"},{"title":"25. 合并两个排序的链表","content":"知识点 JavaScript 赋值 js 中将原始值赋值给另一个变量时，原始值会被复制到新变量的位置，而这两个值是完全独立，互不干扰的： let num1 = 6; let num2 = num1; js 中将引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来： let obj1 = new Object(); let obj2 = obj1; obj1.name = &quot;AriesSK&quot;; console.log(obj2.name); // AriesSK 题解 法一：双指针 + 迭代 头指针的应用，注意在比较过程中newHead也会变化，需要使用一个指针res维护它的初值，初始链表为空的情况已经包含在内，不需要另外考虑： var mergeTwoLists = function(l1, l2) { let ptr1 = l1, ptr2 = l2, newHead = new ListNode(); const res = newHead; while (ptr1 &amp;&amp; ptr2) { if (ptr1.val &lt;= ptr2.val) { newHead.next = ptr1; ptr1 = ptr1.next; } else { newHead.next = ptr2; ptr2 = ptr2.next; } newHead = newHead.next; } // 一条为空 接上另一条剩下的 newHead.next = ptr1 ? ptr1 : ptr2; return res.next; }; 法二：递归 空间复杂度 O(n+m)O(n + m)O(n+m)，nnn 和 mmm 分别为两个链表的长度，递归调用函数需要消耗栈空间，栈空间的大小取决于递归调用的深度，这里最多调用 n+mn + mn+m 次： var mergeTwoLists = function(l1, l2) { if (!l1) return l2; else if (!l2) return l1; else if (l1.val &lt;= l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } ","link":"https://AriesSK.github.io/post/jianzhi_25/"},{"title":"22. 链表中的倒数第k个节点","content":"知识点 JavaScript 中 此类题目对头节点并不需要特殊的处理 因此可以不另设头指针。 题解 双指针 两指针减保持 kkk 距离，直到右指针为空时，左指针即为目标节点： var getKthFromEnd = function(head, k) { let left = head, right = left; while (k &gt; 0) { right = right.next; --k; } while (right) { left = left.next; right = right.next; } return left; }; ","link":"https://AriesSK.github.io/post/jianzhi_22/"},{"title":"18. 删除链表的节点","content":"知识点 在链表前设置一个指向头节点的头指针能够使算法不用单独考虑头节点的处理。 题解 双指针 使用 nextnextnext 遍历目标节点，currcurrcurr 记录目标节点的前一节点，以实现断链 推荐设置一个值为 nullnullnull 的头节点（头指针）newHead，能够有效避免删除头节点或链表为空的情况： var deleteNode = function(head, val) { const newHead = new ListNode(); newHead.next = head; let curr = newHead, next = curr.next; while (next) { if (next.val === val) { curr.next = next.next; next.next = null; break; } curr = curr.next; next = next.next; } return newHead.next; }; ","link":"https://AriesSK.github.io/post/jianzhi_18/"},{"title":"48. 最长不含重复字符的子字符串","content":"知识点 JavaScript 的字符串函数 字符串函数的补充说明： slice(start, end) // strat 取到，end 取不到 s = &quot;abcedf&quot; s.slice(-3) // edf s.slice(-3, -1) // ed s.substr(-1) // f s.substr(-3, 2) // ed 逆时针取两位 字符的 ASCII 码范围为 0~127。 题解 法一：动态规划 步骤： 状态定义：设动态规划矩阵 dpdpdp，dp[i]dp[i]dp[i] 代表前 iii 位字符串的最大不重复子串长度； 转移方程：判断以 s[i]s[i]s[i] 结尾的倒数 dp[i−1]dp[i - 1]dp[i−1] 个字符是否是不重复字串，若是，则 dp[i]=dp[i−1]+1dp[i] = dp[i - 1] + 1dp[i]=dp[i−1]+1；否则 dp[i]=dp[i−1]dp[i] = dp[i - 1]dp[i]=dp[i−1]; 初始状态：dp[0]=0dp[0] = 0dp[0]=0，dp[1]=1dp[1] = 1dp[1]=1； 返回结果：dp[n]dp[n]dp[n]。 var lengthOfLongestSubstring = function(s) { let pre = 0, curr = 0; for (let i = 0; i &lt; s.length; ++i) { curr = isRepeat(s.slice(i - pre, i + 1)) ? pre : pre + 1; pre = curr; } return curr; }; var isRepeat = function(s) { let set = new Set(); for (let i of s) { if (set.has(i)) return true; else set.add(i); } return false; }; 上面的方法每遍历一个字符，都需要遍历包含其的一个字串，时间复杂度较高，可以对其加以改进： 状态定义： 设动态规划矩阵 dpdpdp，dp[j]dp[j]dp[j] 代表以 s[j]s[j]s[j] 结尾的最大不重复子串长度； 转移方程： 固定右边界 jjj ，设 s[j]s[j]s[j] 左侧距离最近的相同字符位 s[i]s[i]s[i]。如果 dp[j−1]&lt;j−idp[j - 1] &lt; j - idp[j−1]&lt;j−i ，说明 s[j]s[j]s[j] 使不重复长度变长了一位，dp[j]=dp[j−1]+1dp[j] = dp[j - 1] + 1dp[j]=dp[j−1]+1；否则说明引起了重复，dp[j]=j−idp[j] = j - idp[j]=j−i； dp[i,j]={dp[j−1]+1,dp[j−1]&lt;j−ij−i,dp[j−1]≥j−idp[i, j] = \\begin{cases} dp[j - 1] + 1&amp; {,dp[j - 1] &lt; j - i}\\\\ j - i&amp; {,dp[j - 1] \\geq j - i} \\end{cases} dp[i,j]={dp[j−1]+1j−i​,dp[j−1]&lt;j−i,dp[j−1]≥j−i​ 初始状态： dp[0]=0dp[0] = 0dp[0]=0，dp[1]=1dp[1] = 1dp[1]=1； 返回结果： max(dp)max(dp)max(dp)。 可以通过哈希表记录每个字符最后一次出现的index到达记录i的效果： var lengthOfLongestSubstring = function(s) { let hash = new Map(); let pre = 0, res = 0; for (let j = 0; j &lt; s.length; ++j) { // 哈希表中若没有 s[j] 则设 i 初始为 -1 let i = hash.has(s.charAt(j)) ? hash.get(s.charAt(j)) : -1; hash.set(s.charAt(j), j); pre = pre &lt; j - i ? pre + 1 : j - i; res = Math.max(res, pre); } return res; }; 这种方法的时间复杂度被降低为了 O(n)O(n)O(n)，同时由于字符的 ASCII 码范围为 0~127，因此哈希表的空间复杂度是 O(1)O(1)O(1) 。 法二：滑动窗口 以 (a)bcabcbb 开始的最长不重复子串为 (abc)abcbb； 以 a(b)cabcbb 开始的最长不重复子串为 a(bca)bcbb； 以 ab(c)abcbb 开始的最长不重复子串为 ab(cab)cbb； 以 abc(a)bcbb 开始的最长不重复子串为 abc(abc)bb； 以 abca(b)cbb 开始的最长不重复子串为 abca(bc)bb； 以 abcab(c)bb 开始的最长不重复子串为 abcab(cb)b； 以 abcabc(b)b 开始的最长不重复子串为 abcabc(b)b； 以 abcabcb(b) 开始的最长不重复子串为 abcabcb(b)。 从上面的过程可以看出最长不重复字串的结束位置必然是递增的，因此就可以使用滑动窗口的方法： 使用两个指针表示字符串中的某个子串的左右边界（窗口），左指针代表子串的起始位置，而右指针代表字串的结束位置； 每一次将左指针右移一格，将下一个字符作为起始位置，在保证窗口中没有重复字符的前提下不断右移右指针。在移动结束后，窗口对应以左指针开始的最长不重复子串，记录其长度； 左指针移动到最后一个字符，返回记录长度的最大值。 var lengthOfLongestSubstring = function(s) { let max = 0; for (let left = 0; left &lt; s.length; ++left) { const set = new Set(); for (let right = left; right &lt; s.length; ++right) { // 找到重复字符的情况下 子串的长度为 right - left if (set.has(s.charAt(right))) { max = Math.max(max, right - left); break; } // 需要考虑 right 移至左端仍没有重复节点的情况 此时子串长度为 right - left + 1 else if (right === s.length - 1) max = Math.max(max, right - left + 1); else set.add(s.charAt(right)); } } return max; }; ","link":"https://AriesSK.github.io/post/jianzhi_48/"},{"title":"46. 把数字翻译成字符串","content":"知识点 JavaScript 字符串函数 toString() // 将数字转化为字符串以获取其长度 substr(begin, length) // 返回从下标 begin 开始长度为 length 的字符串 substr() 也可以使用其他两个函数替换: // 两者均是返回 begin 到 end 的字符串 均可以省略第二个参数 表示截取到字符串尾部 slice(begin, end) substring(begin, end) 两者的区别是： substring()会判断两个参数大小，小的作为起始位置，大的作为结束位置，slice()则不会； slice()中的负参数表示从末尾开始计数， 而substring()中负数按 000 处理。 题解 动态规划 这道题的递归思想类似于10 - II. 青蛙跳台阶问题，只不过需要对能否跳进行判断。 所以步骤如下： 状态定义： 设动态规划矩阵 dpdpdp，dp[i]dp[i]dp[i] 代表前 iii 位数字的翻译方案数量； 转移方程： 注意最后两位数除了大于 252525 时无法翻译，小于 101010 也同样无法翻译（无法翻译 000 开头的两位数）。因此： dp[i,j]={dp[i−1]+dp[i−2],10xi−1+xi∈[10,25])dp[i−1],10xi−1+xi∈[0,25)∪(25,99])dp[i, j] = \\begin{cases} dp[i - 1] + dp[i - 2]&amp; {, 10x_{i - 1} + x_i \\in [10, 25])}\\\\ dp[i - 1]&amp; {, 10x_{i - 1} + x_i \\in [0, 25) \\cup (25, 99])} \\end{cases} dp[i,j]={dp[i−1]+dp[i−2]dp[i−1]​,10xi−1​+xi​∈[10,25]),10xi−1​+xi​∈[0,25)∪(25,99])​ 初始状态： dp[0]=1dp[0] = 1dp[0]=1，dp[1]=1dp[1] = 1dp[1]=1； 返回结果： dp[n]dp[n]dp[n]。 var translateNum = function(num) { num = num.toString(); let p = 1, q = 1, r = 1; for (let i = 1; i &lt; num.length; ++i) { r = num.substr(i - 1, 2) &lt;= 25 &amp;&amp; num.substr(i - 1, 2) &gt;= 10 ? p + q : q; p = q; q = r; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_46/"},{"title":"47. 礼物的最大价值","content":"知识点 二维数组的动态规划 如果想要不修改原数组，则需要创建一个二维数组 dp[m,n]dp[m, n]dp[m,n]。 JavaScript 创建二维数组 const m = 4, n = 5; let arr = new Array(m); for (let i = 0; i &lt; n; ++i) arr[i] = new Array(n); 注意在数组为空的时候不能使用for in: let arr = new Array(5); // 数组内的值均是 undefined for (const i in arr) console.log(i); // 无输出 let arr = new Array(5).fill(0); for (const i in arr) console.log(i); // 1, 2, 3, 4, 5 题解 步骤： 状态定义：设动态规划矩阵 dpdpdp，dp(i,j)dp(i, j)dp(i,j) 代表从左上角开始到 (i,j)(i, j)(i,j) 时拿到礼物的最大价值； 转移方程： dp(i,j)={grid(i,j),i=0,j=0grid(i,j)+dp(i,j−1),i=0,j=0grid(i,j)+dp(i−1,j),i=0,j=0grid(i,j)+max[dp(i−1,j),dp(i−1,j)],i=0,j=0dp(i, j) = \\begin{cases} grid(i, j)&amp; {,i = 0, j = 0}\\\\ grid(i, j) + dp(i, j - 1)&amp; {,i = 0, j \\not= 0}\\\\ grid(i, j) + dp(i - 1, j)&amp; {,i \\not= 0, j = 0}\\\\ grid(i, j) + max[dp(i - 1, j), dp(i - 1, j)]&amp; {,i \\not= 0, j \\not= 0} \\end{cases} dp(i,j)=⎩⎪⎪⎪⎨⎪⎪⎪⎧​grid(i,j)grid(i,j)+dp(i,j−1)grid(i,j)+dp(i−1,j)grid(i,j)+max[dp(i−1,j),dp(i−1,j)]​,i=0,j=0,i=0,j​=0,i​=0,j=0,i​=0,j​=0​ 初始状态：dp(0,0)=0dp(0, 0) = 0dp(0,0)=0； 返回结果：dp(m−1)(n−1)dp(m - 1)(n - 1)dp(m−1)(n−1)。 var maxValue = function(grid) { let m = grid.length, n = grid[0].length; for (let i = 0; i &lt; m; ++i) { for (let j = 0; j &lt; n; ++j) { if (i === 0 &amp;&amp; j === 0) continue; if (i === 0) grid[i][j] += grid[i][j - 1]; else if (j === 0) grid[i][j] += grid[i - 1][j]; else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]) } } return grid[m - 1][n - 1]; }; 上面的方法还可以优化，因为当 gridgridgrid 矩阵很大时，i=0i = 0i=0 或 j=0j = 0j=0 的情况仅占极少数，相当循环每轮都冗余了一次判断。可以完成矩阵的第一行和第一列的赋值，再通过循环给剩余的赋值，提高代码运行效率： var maxValue = function(grid) { let m = grid.length, n = grid[0].length; for (let i = 1; i &lt; m; ++i) grid[i][0] += grid[i - 1][0]; for (let j = 1; j &lt; n; ++j) grid[0][j] += grid[0][j - 1]; for (let i = 1; i &lt; m; ++i) for (let j = 1; j &lt; n; ++j) grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]); return grid[m - 1][n - 1]; }; ","link":"https://AriesSK.github.io/post/jianzhi_47/"},{"title":"42. 连续子数组的最大和","content":"知识点 动态规划关键点 ：找到转移方程，用变量记录方程中涉及的状态。 本题关键在于：若前面的累加和为负数，则应当抛弃，从当前数开始累加。 题解 法一：暴力 双重遍历，时间复杂度O(n2)O(n^2)O(n2)： var maxSubArray = function(nums) { let max = nums[0]; for (let i = 0; i &lt; nums.length; ++i) { let sum = 0; for (let j = i; j &lt; nums.length; ++j) { sum += nums[j]; max = Math.max(max, sum); } } return max; }; 法二：动态规划 步骤： 状态定义： 设动态规划列表 dpdpdp，dp[i]dp[i]dp[i] 代表以 nums[i]nums[i]nums[i] 结尾 的连续子数组最大和； 转移方程： 若 dp[i−1]≤0dp[i - 1] \\leq 0dp[i−1]≤0，则 dp[i−1]+nums[i]≤nums[i]dp[i - 1] + nums[i] \\leq nums[i]dp[i−1]+nums[i]≤nums[i] 取 nums[i]nums[i]nums[i]，若 dp[i−1]&gt;0dp[i - 1] &gt; 0dp[i−1]&gt;0，则取 dp[i−1]+nums[i]dp[i - 1] + nums[i]dp[i−1]+nums[i]； 初始状态： max=nums[0max = nums[0max=nums[0]，dp[i−1]=0dp[i - 1] = 0dp[i−1]=0； 返回结果： dpdpdp 的最大值。 使用pre记录 dp[i−1]dp[i - 1]dp[i−1]，curr记录 dp[i]dp[i]dp[i] 的值，max 记录 dpdpdp 中的最大值： var maxSubArray = function(nums) { let max = nums[0], pre = 0; for (num of nums) { let curr = num + Math.max(pre, 0); max = Math.max(max, curr); pre = curr; } return max; }; ","link":"https://AriesSK.github.io/post/jianzhi_42/"},{"title":"63. 股票的最大利润","content":"知识点 动态规划需要解决所有的子问题并且把它们的解记录下来。 题解 法一：暴力 全遍历一遍，时间复杂度 O(n2)O(n^2)O(n2)： var maxProfit = function(prices) { // 设置最低利润为 0 let max = 0; for (let i = 0; i &lt; prices.length - 1; ++i) { for (let j = i + 1; j &lt; prices.length; ++j) { if (max &lt; prices[j] - prices[i]) max = prices[j] - prices[i]; } } return max; }; 法二：动态规划 由于必须得先买后卖，因此花费是到目前为止的最低买入价格。 步骤： 状态定义： 设动态规划列表 dpdpdp，dp[i]dp[i]dp[i] 代表以 prices[i]prices[i]prices[i] 结尾的子数组的最大利润，即前 iii 日的最大利润； 转移方程： dp[i]=max(dp[i−1],prices[i]−min(prices[0:i])dp[i] = max(dp[i - 1], prices[i] - min(prices[0 : i])dp[i]=max(dp[i−1],prices[i]−min(prices[0:i])； 初始状态： dp[0]=0dp[0] = 0dp[0]=0； 返回结果： dp[n−1]dp[n - 1]dp[n−1]， nnn 为列表长度。 var maxProfit = function(prices) { let cost = Number.MAX_VALUE, maxProfit = 0; for (const price of prices) { cost = Math.min(price, cost); // 第 n 天的价格减去目前为止最低的买入价 maxProfit = Math.max(price - cost, maxProfit) } return maxProfit; }; ","link":"https://AriesSK.github.io/post/jianzhi_63/"},{"title":"10 - II. 青蛙跳台阶问题","content":"知识点 类似斐波那契数列的问题，使用动态规划解决，需要注意初始状态的区别。 题解 动态规划 跳上 nnn 级台阶有 F(n)F(n)F(n) 种跳法，在所有跳法中，最后一步只有两种情况： 跳 111 级，有 F(n−1)F(n - 1)F(n−1) 种； 跳 222 级，有 F(n−2)F(n - 2)F(n−2) 种。 所以步骤如下： 状态定义： F(n)F(n)F(n) 表示跳上 nnn 级台阶的跳法总数； 转移方程： F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态： F(0)=1F(0) = 1F(0)=1，F(1)=1F(1) = 1F(1)=1，F(2)=2F(2) = 2F(2)=2； 返回结果： F(n)F(n)F(n)。 var numWays = function(n) { if (n &lt; 2) return 1; let p = 0, q = 1, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % (1e9+7); } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_ii/"},{"title":"10 - I. 斐波那契数列","content":"知识点 动态规划总结 Those who cannot remember the past are condemned to repeat it. 那些不记得过去的人注定要重蹈覆辙。 动态规划(Dynamic Programming, DP) 通过记住求过的解来节省时间，对每一个子问题只求解一次，并将结果存下来。 无后效性： 如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响 最优子结构性质： 大的问题的最优解可以由小问题的最优解推出 判断能否使用 DP 解决： 是否能够将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 步骤： 状态定义： 定义一个状态，这是一个最优解的结构特征； 转移方程： 进行状态递推，得到递推公式； 初始状态： 进行初始化； 返回结果： 返回需要的解。 其中最重要的是状态转移方程。 题解 法一：递归 我第一时间想到的思路，且代码简单，但递归过程中重复的计算过多，导致超出了时间限制，无法通过： var fib = function(n) { if (n === 0) return 0; if (n === 1) return 1; return (fib(n - 1) + fib(n - 2)) % (1e9+7); }; 法二：递归 + 哈希表 法一的优化，将每次计算后的结果存在哈希表中，即可避免重复计算，但需要额外O(n)的空间： var fib = function(n, hash = new Map()) { if (n &lt;= 1) return n; if (hash.has(n)) return hash.get(n); // 注意给 1e9+7 加括号 否则会出错 else hash.set(n, (fib(n - 1, hash) + fib(n - 2, hash)) % (1e9+7)); return hash.get(n); }; 法三：动态规划 状态转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2) 由于只涉及到三个值，因此可以用滚动数组法使得空间复杂度为O(1)： 状态定义：F(n)F(n)F(n) 表示第 nnn 个斐波那契数； 转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态：F(0)=0F(0) = 0F(0)=0，F(1)=1F(1) = 1F(1)=1，F(2)=1F(2) = 1F(2)=1； 返回结果：F(n)F(n)F(n)。 var fib = function(n) { const MOD = 1e9+7; if (n &lt; 2) return n; let p = 0, q = 0, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % MOD; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_i/"},{"title":"28. 对称的二叉树","content":"知识点 深度优先搜索的递归与迭代 dfs 的递归方法修改为迭代方法，常用的方式是引入一个队列来保证处理节点的顺序，同时还需要加入while循环。 JavaScript 树的比较 js 中两个树无法用===比较： // 虽然结构和值都相同，但是是两个不同的树，内存地址不同 let a = new TreeNode(1); let b = new TreeNode(1); a === b; // false 题解 深度优先搜索 递归 递归公式： F(l,r)F(l, r)F(l,r)：表示完成了节点 lll 和 rrr 的对比； F(l,r)=F(l.left,r.right)+F(l.right,r.left)F(l, r) = F(l.left, r.right) + F(l.right, r.left)F(l,r)=F(l.left,r.right)+F(l.right,r.left)。 终止条件： lll 和 rrr 同时为空 表示遍历完成 返回 true； lll 和 rrr 其中一个为空（结构不对称），或者 lll 和 rrr 值不同（值不对称），返回 false。 var isSymmetric = function(root) { return check(root, root); }; var check = function(l, r) { if (!l &amp;&amp; !r) return true; if (!l || !r || l.val !== r.val) return false; return check(l.left, r.right) &amp;&amp; check(l.right, r.left); } 迭代 双端队列，每次左右分别入队，左右分别出队： var isSymmetric = function(root) { const queue = []; queue.unshift(root); queue.push(root); // 这里即使 queue 为空队列也 !== null 不能用 !queue while (queue.length !== 0) { let l = queue.shift(); let r = queue.pop(); if (!l &amp;&amp; !r) continue; if (!l || !r || l.val !== r.val) return false; queue.unshift(l.right); queue.unshift(l.left); queue.push(r.left) queue.push(r.right); } return true; }; 普通队列，每次要比较的一对同时入队与出队： var isSymmetric = function(root) { const queue = []; queue.push(root); queue.push(root); while (queue.length !== 0) { let l = queue.pop(); let r = queue.pop(); if (!l &amp;&amp; !r) continue; if (!l || !r || l.val !== r.val) return false; queue.push(l.left); queue.push(r.right); queue.push(r.left) queue.push(l.right); } return true; }; ","link":"https://AriesSK.github.io/post/jianzhi_28/"},{"title":"27. 二叉树的镜像","content":"知识点 递归公式非常重要！！！ 题解 深度优先搜索 原树操作 递归公式： F(root)F(root)F(root)：完成以root为根节点的树的镜像； F(root)=F(root.left)+F(root.right)F(root) = F(root.left) + F(root.right)F(root)=F(root.left)+F(root.right) + 交换root左右子节点。 终止条件： root为空，即为叶子节点的子节点，返回null。 var mirrorTree = function(root) { if (!root) return null; const left = mirrorTree(root.left); const right = mirrorTree(root.right); root.left = right; root.right = left; return root; }; 复制树 递归公式： F(root)F(root)F(root)：创建新节点并复制root的值 ； F(root)=F(root.left)+F(root.right)F(root) = F(root.left) + F(root.right)F(root)=F(root.left)+F(root.right) + 交换root左右子节点。 终止条件： root为空，即为叶子节点的子节点，返回null。 var mirrorTree = function(root) { if (!root) return null; const newRoot = new TreeNode(root.val); newRoot.left = mirrorTree(root.right); newRoot.right = mirrorTree(root.left); return newRoot; }; ","link":"https://AriesSK.github.io/post/jianzhi_27/"},{"title":"26. 树的子结构","content":"知识点 深度优先遍历 深度优先遍历(DFS) 包括前序、中序、后序三种遍历。 dfs 算法中的前序遍历模板： var dfs = function (node) { // 节点判空必须放在操作前 防止报错 if (!node) return; // 节点为空，返回上一层 console.log(node.val); // 操作根节点 dfs(node.left); // 操作左子树 dfs(node.right); // 操作右子树 } dfs 往往需要使用递归，通常使用递归则不需要使用while循环。 题解 这道题融合了dfs遍历树和判断两树是否相同两道题，是 dfs 的变种，需要嵌套使用两种递归： 首先，遍历 AAA 中的每个节点node； 其次，判断以每个node为根节点的子树是否包含 BBB。 helper() 递归公式 ： F(A,B)F(A, B)F(A,B) ：检查 BBB 为根节点的树是否是 AAA 的子结构 F(A,B)=F(A.left,B.left)+F(A.right,B.right)F(A, B) = F(A.left, B.left) + F(A.right, B.right)F(A,B)=F(A.left,B.left)+F(A.right,B.right) + 检查 AAA, BBB 值和结构是否相同 终止条件： 遍历完 BBB 说明是子结构，return true； AAA 为空而 BBB 非空，说明结构不同，return false； AAA, BBB 的值不同，return false。 isSubStructure()递归公式： F(A,B)F(A, B)F(A,B) ：遍历 AAA 树，同时使用helper()判断 BBB 是否是 AAA 树的子结构； F(A,B)=F(A.left,B)+F(A.right,B)+helper(A,B)F(A, B) = F(A.left, B) + F(A.right, B) + helper(A, B)F(A,B)=F(A.left,B)+F(A.right,B)+helper(A,B)。 终止条件： BBB 是空树，题目给出不是任何树的子结构，return false； 遍历完 AAA，说明没找到 BBB 相同子结构，return false。 var isSubStructure = function(A, B) { if (!A || !B) return false; return helper(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); }; var helper = function(A, B) { if (!B) return true; if (!A || A.val !== B.val) return false; return helper(A.left, B.left) &amp;&amp; helper(A.right, B.right); } 注意 dfs 中判空的操作要放在最前面，不然会出错。比如helper()中的 BBB 判空如果放在判断 AAA, BBB 值是否相同后面，则在 BBB 为空 AAA 不为空的情况下会返回false，但实际上应当返回 true。 ","link":"https://AriesSK.github.io/post/jianzhi_26/"},{"title":"32 - III. 从上到下打印二叉树 III","content":"知识点 JavaScript 的双端队列 js 中的双端队列也是用数组模拟的： 栈： 右进右出，左栈底右栈头； 队列： 右进左出，左队头右队尾。 push() // 队尾入队 unshift(); // 队头入队 题解 深度优先搜索 该题需要判断该层是奇数层还是偶数层： var levelOrder = function(root) { const queue = []; const number = []; if (!root) return number; queue.push(root); while (queue.length) { const count = queue.length; // 在这一步之后 number.length 就等同于当前的层数 number.push([]); for (let i = 0; i &lt; count; ++i) { root = queue.shift(); // 奇数层左到右 偶数层右到左 if (number.length % 2) number[number.length - 1].push(root.val); else number[number.length - 1].unshift(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } } return number; }; 这题判断奇偶的方法有三种，第三种最 smart： // 使用数字记录层数 let tier = 1; ++ tier; // 使用布尔类型记录奇偶 let leftOrder = true; leftOrder = !leftOrder; // 使用 number 的长度奇偶判断，长度即当前层数 if (number.length % 2) // 右到左 else // 左到右 ","link":"https://AriesSK.github.io/post/jianzhi_32_iii/"},{"title":"32 - II. 从上到下打印二叉树 II","content":"知识点 JavaScript 的二维数组 js 中创建二维数组是在一维数组中再添加数组： let array = []; // array = [] 先声明一维数组 array.push([]); // array = [[]] 扩展为二维数组 array.push([]); // array = [[], []] 持续扩展 题解 深度优先搜索 使用双重循环保证每次打印一层： var levelOrder = function(root) { const queue = []; const number = []; if (!root) return number; queue.push(root); while (queue.length) { // 注意这里必须保存队列的长度，因为后面 shift()，push() 均会改变队列的长度 // queue.length 代表了当前层的长度 // 循环中的 const 每次循环会创建新的实例，因此不会报错 const count = queue.length; // 创建二维数组 number.push([]); // 使用 for 循环使每一层的打印在一个 while 循环中完成 for (let i = 0; i &lt; count; ++i) { root = queue.shift(); number[number.length - 1].push(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } } return number; }; ","link":"https://AriesSK.github.io/post/jianzhi_32_ii/"},{"title":"32 - I. 从上到下打印二叉树 I","content":"知识点 广度优先搜索 广度优先搜索(BFS)，也叫层次遍历，是借助队列的先入先出特性(FIFO)实现的。 在 JavaScript 中是用数组来模拟队列的： // 下面四种数组操作均会改变数组的长度 push() // 数组末添加 入队 返回长度 pop() // 数组末弹出 返回弹出元素 unshift() // 数组头添加 返回长度 shift() // 数组头弹出 出队 返回弹出元素 JavaScript 的if表达式 if (a) {} // 只要 a 不为 0, null, undefined, false 均会执行内部操作 题解 深度优先搜索 经典的 Breath First Search： var levelOrder = function(root) { // 数组可以用 const 声明 const queue = []; const number = []; // 空树的特殊情况，不要忘记考虑！ if (!root) return number; queue.push(root); while (queue.length) { // 先弹出后处理 root = queue.shift(); number.push(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } return number; }; ","link":"https://AriesSK.github.io/post/jianzhi_32_i/"},{"title":"50. 第一个只出现一次的字符","content":"知识点 JavaScript 中的for循环 for in，in 指的是数组的下标： var array = [a,b,c,d,e] for (let i in array) { console.log(i); // 0,1,2,3,4 console.log(array[i]); // a,b,c,d,e } for of，of 指的是数组的值： for (let i of array) { console.log(i); // a,b,c,d,e } JavaScript 字符串 Array.from()能够将字符串拆成字符数组。 js 中没有Char只有String，Char是长度为一的String。 js 不能像 java 那样使用单字符相减获得 ASCII 码的差值，因为字符只是单字符的字符串，因此使用一下方法获取 ASCII 码值： 'a'.charCodeAt(0) // 97 题解 应用哈希表，遍历两遍字符串，第一遍存并判断是否只出现一次，第二遍输出： var firstUniqChar = function(s) { let hash = new Map(); for (let i = 0; i &lt; s.length; ++i) { if (!hash.has(s.charAt(i))) hash.set(s.charAt(i), true); else hash.set(s.charAt(i), false); } for (let i = 0; i &lt; s.length; ++i) { if (hash.get(s.charAt(i))) return s.charAt(i); } return ' '; }; // 简单写法 var firstUniqChar = function(s) { let hash = new Map(); let charArray = Array.from(s); for (let c of charArray) { hash.set(c, !hash.has(c)); } for (let c of charArray) { if (hash.get(c)) return c; } return ' '; }; 也可以使用长度26的数组，记录每个字母的出现次数。 ","link":"https://AriesSK.github.io/post/jianzhi_50/"},{"title":"11. 旋转数组的最小数字","content":"知识点 这一题的二分法很特别，因为在numbers[m] = numbers[r]的情况下，无法判断旋转点在哪个半区，因此无法通过常规方法缩小区间，而需要使用--r来缩小区间，而--r的终止条件应当是l === r时，因此本题需要使用模板二，二分法具体模板见53 - I. 在排序数组中查找数字 I。 题解 法一：暴力 找到第一个变小的数字： var minArray = function(numbers) { for (let i = 1; i &lt; numbers.length; ++i) { if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; } // 旋转0个数的情况 return numbers[0]; }; 法二：二分法 要保证每次缩小区间后最小值仍在区间内。 二分会有三种情况： 当 nums[m]&gt;nums[r]nums[m] &gt; nums[r]nums[m]&gt;nums[r] 时： mmm 一定在左排序数组中，即旋转点 xxx 一定在 [m+1,r][m + 1, r][m+1,r] 闭区间内，因此执行 r=m+1r = m + 1r=m+1； 当 nums[m]&lt;nums[r]nums[m] &lt; nums[r]nums[m]&lt;nums[r] 时： mmm 一定在右排序数组中，即旋转点 xxx 一定在 [l,m][l, m][l,m] 闭区间内，因此执行 r=mr = mr=m； 当 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 时： 无法判断 mmm 在哪个排序数组中，即无法判断旋转点 xxx 在 [l,m][l, m][l,m] 还是 [m+1,r][m + 1, r][m+1,r] 区间中，但由于 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 并且 mmm 一定在区间内，因此即使 num[r]num[r]num[r] 是最小值，也可以执行 r=r−1r = r - 1r=r−1 缩小范围。 为什么本题二分法不用 nums[m]nums[m]nums[m] 和 nums[l]nums[l]nums[l] 作比较？ 避免了旋转 000 个数出现的问题。 二分目的是判断 mmm 在哪个排序数组中，从而缩小区间。而在 nums[m]&gt;nums[l]nums[m] &gt; nums[l]nums[m]&gt;nums[l] 情况下，无法判断 mmm 在哪个排序数组中。本质上是由于 rrr 初始值肯定在右排序数组中；但 lll 初始值无法确定在哪个排序数组中。 var minArray = function(numbers) { let l = 0, r = numbers.length; while (l &lt; r) { const m = l + Math.floor((r - l) / 2); if (numbers[m] &gt; numbers[r]) l = m + 1; else if (numbers[m] &lt; numbers[r]) r = m; else --r; } return numbers[l]; }; ","link":"https://AriesSK.github.io/post/jianzhi_11/"},{"title":"04. 二维数组中的查找","content":"知识点 本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。 题解 法一：暴力 注意题目中提示了输入可能是空数组，这种情况需要特别考虑： var findNumberIn2DArray = function(matrix, target) { // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑 if (!matrix.length) return false; let n = matrix.length, m = matrix[0].length; for (let i = 0; i &lt; n; ++i) { for (let j = 0; j &lt; m; ++j) { if (matrix[i][j] === target) return true; } } return false; }; 法二：标志数 将矩阵逆时针旋转 45°，能够发现其结构类似二叉搜索树，左分支更小，右分支更大； 因此从根节点，也就是右上角开始搜索，比target大就向左，否则向右； 矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。 // 右上角开始 var findNumberIn2DArray = function(matrix, target) { if (!matrix.length) return false; let i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &lt; target) ++i; else --j; } return false; }; // 左下角开始 var findNumberIn2DArray = function(matrix, target) { let i = matrix.length - 1, j = 0; // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错 while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &gt; target) --i; else ++j; } return false; }; ","link":"https://AriesSK.github.io/post/jianzhi_04/"},{"title":"53 - II. 0~n-1中缺失的数字","content":"知识点 JavaScript 的排序函数 sort()函数： sort() // 默认按字母升序，40 在 5 前面，是先调用 toString() 再比较 sort(function(a, b){return a - b}) // 按数字升序 sort((a, b) =&gt; a - b) // 按数字升序的简写 sort(function(a, b){return b - a}) // 按数字降序 sort((a, b) =&gt; b - a) // 按数字降序的简写 JavaScript 的箭头函数 // 下面三个等同 var sum = function(a, b) { return a + b; }; var sum = (a, b) =&gt; { return a + b; }; var sum = (a, b) =&gt; a + b; // 一个参数可不用括号 var sum = x =&gt; { retrun x; }; // 没有或多个参数均需要括号 var sum = () =&gt; { return 1; }; 题解 法一：二分法 数组下标与值不同说明已经发生了数字缺失： var missingNumber = function(nums) { let left = 0, right = nums.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === mid) left = mid + 1; else right = mid - 1; } return left; }; 法二：数学 高斯求和公式−目前的和=缺失的数字高斯求和公式 - 目前的和 = 缺失的数字高斯求和公式−目前的和=缺失的数字： var missingNumber = function(nums) { const n = nums.length + 1; let total = Math.floor(n * (n - 1) / 2); let arrSum = 0; for (let i = 0; i &lt; n - 1; i++) { arrSum += nums[i]; } return total - arrSum; }; 法三：暴力 找第一个下标与值不同的位置： var missingNumber = function(nums) { // 如果乱序则先排序 nums.sort((a, b) =&gt; a - b); const n = nums.length + 1; for (let i = 0; i &lt; n - 1; i++) { if (nums[i] !== i) { return i; } } return n - 1; }; ","link":"https://AriesSK.github.io/post/jianzhi_53_ii/"},{"title":"53 - I. 在排序数组中查找数字 I","content":"知识点 二分法总结 有序的序列查找，优先考虑二分法。 无重复元素 查找target在序列中是否出现： const binarySearch(nums, target) { let left = 0, right = nums.length; while (left &lt;= right) { // 能够防止溢出 const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return -1; }; 有重复元素 查找首个大于target的元素序号； 查找首个大于等于target的元素序号（等同于查找首个大于target - 1的元素序号）。 const binarySearch(nums, target) { let left = 0, right = num.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] &lt;= target) left = mid + 1; else right = mid - 1; } return i; } 循环条件写left &lt;= right和left &lt; right的区别 区别在于是否包含最右边的边界值，因为当left==right时，不会再进入循环体，所以right初始化时就取值为len(nums)，这样在for循环中就能保证是在这样一个左闭右开的区间 [left,right)[left,right)[left,right)，且right赋值应该为right = mid而非right = mid-1，因为右半边是开区间，取mid-1就无法验证到mid-1是否是目标值。简单来说区别是right所代表的位置是否参与计算。 两种写法模板 // 模板一 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt;= right 的情况下 right = nums.length - 1 以保证 mid 能够取到 const binarySearch = function(nums, target) { let left = 0, right = nums.length - 1; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return left; } // 模板二 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt; right 的情况下 right = nums.length 因为 mid 最多取到 right - 1 const binarySearch = function(nums, target) { let left = 0, right = nums.length; while (left &lt; right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; } return left; } JavaScript 中的数组越界 js 数组允许越界，越界返回的是undefined。 js 在非严格模式的情况下变量允许不声明直接赋值。 题解 法一：暴力 逐个遍历： var search = function(nums, target) { let start = -1, end = -1; for (let i = 0; i &lt; nums.length; ++i) { if (nums[i] === target) { start = i; break; } } if (start === -1) return 0; // 这里只有在 js 中才行 因为允许数组越界 正常 i = nums.length 时 若nums[i] === target 则 end = nums.length for (let i = start;; ++i) { if (nums[i] !== target) { end = i; break; } } return end - start; }; 法二：二分法 这里的binarySearch()方法目的实际上是寻找tar值能够插入的最右的位置，因此答案为target的右边界减去(target - 1)的右边界。 var search = function(nums, target) { return binarySearch(nums, target) - binarySearch(nums, target - 1); } const binarySearch = function(nums, tar) { let i = 0, j = nums.length - 1; // 用 &lt;= 保证 tar 能够插入最右的位置 而不是 最右的前一位 while (i &lt;= j) { // 不像 java 在 js 中需要手动取整 const m = Math.floor((i + j) / 2); // 由于找最右插入位置 因此即使nums[m] = tar 插入位置也在 m + 1 及之后 if (nums[m] &lt;= tar) i = m + 1; else j = m - 1; } // i 永远比 j 大1 只能返回 i return i; }; // while 中 &lt;= 换为 &lt; 后 改变 j 的初始值 和 j 每次的缩小值 const binarySearch = function(nums, target) { let i = 0, j = nums.length; while (i &lt; j) { const m = i + Math.floor((j - i) / 2); if (nums[m] &lt;= target) i = m + 1; else j = m; } return i; } ","link":"https://AriesSK.github.io/post/jianzhi_53_i/"},{"title":"03. 数组中重复的数字","content":"知识点 JavaScript 中的Map对象与Set对象 Map对象存储键值对，一些常用的方法如下： set(key, value) get(key) has(key) delete(key) Set对象是唯一值的集合，一些常用的方法如下： add(key) clear() // 删除所有 delete(key) entries() keys() values() // 返回值的数组，分别返回键值对、键名、键值，在 Set 中结果相同 has(key) size() Map和Set的 key 可以是任何数据类型。 题解 法一：哈希表 我一开始想到的是使用Map： var findRepeatNumber = function(nums) { let hash = new Map(); for (let i = 0; i &lt; nums.length; ++i) { // 这里需要使用 has()，而不是 get()，防止 get() 取到 0 导致判断出错 if (!hash.has(nums[i])) hash.set(nums[i], i); else return nums[i]; } }; 后来发现Map存储的是键值对，但在这题中只需要存 key，不需要存 value，因此用Set更好： var findRepeatNumber = function(nums) { let set = new Set(); for (let i = 0; i &lt; nums.length; ++i) { if (!set.has(nums[i])) set.add(nums[i]); else return nums[i]; } }; 法二：原地算法 遍历数组nums，设索引初始值为i = 0： 若nums[i] = i：说明此数字已在对应索引位置，无需交换，因此跳过； 若nums[nums[i]] = nums[i]：代表索引nums[i]处和索引i处的元素值都为nums[i]，即找到一组重复值，返回此值nums[i]； 否则：交换索引为i和nums[i]的元素值，将此数字交换至对应索引位置。 若遍历完毕尚未返回，则返回 -1。 var findRepeatNumber = function(nums) { let i = 0; while (i &lt; nums.length) { if (nums[i] === i) { // 直到该位置已放置正确数字再处理下一个位置，以保证数组被完全遍历 ++i; continue; } if (nums[nums[i]] === nums[i]) return nums[i]; let tmp = nums[i]; nums[i] = nums[nums[i]]; // 注意这里 num[i] 已经被修改了值，因此不能用 nums[nums[i]] nums[tmp] = tmp; } return -1; }; ","link":"https://AriesSK.github.io/post/jianzhi_03/"},{"title":"58 - II. 左旋字符串","content":"知识点 JavaScript 的字符串操作函数 charAt(index) // 返回指定索引位置的字符 indexOf() // 返回字符串中检索指定字符第一次出现的位置 replace(searchvalue,newvalue) // 替换第一个子串 replaceAll(searchvalue,newvalue) // 替换所有子串 slice(start, end) // 提取字符串的片段 以新字符串返回 split(separator,limit) // 将字符串分割为子字符串数组 substr(start,length) // 从起始索引号提取字符串中指定数目的字符 substring(start, end) // 提取字符串中两个指定的索引号之间的字符 trim() // 移除字符串首尾空白 题解 substring()： var reverseLeftWords = function(s, n) { return s.substring(n) + s.substring(0, n); }; charAt() + 取余： var reverseLeftWords = function(s, n) { let res = &quot;&quot;; for (let i = 0; i &lt; s.length; ++i) res += s.charAt((i + n) % s.length); return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_58_ii/"},{"title":"05. 替换空格","content":"知识点 JavaScript 中的字符赋值 在 js 中不能直接对字符串中字符赋值： var replaceSpace = function(s) { for (let i = 0; i &lt; s.length; ++i) { if (s[i] === &quot; &quot;) s[i] = &quot;%20&quot;; } return s; }; 正确的做法是使用replace()操作。 题解 不使用字符串方法的解法： var replaceSpace = function(s) { let res = '' for(let i = 0;i &lt; s.length; i++) { if (s[i] === &quot; &quot;) res += &quot;%20&quot;; else res += s[i]; } return res; } 可以使用split()将字符串转化为数组： var replaceSpace = function(s) { arr = s.split(&quot; &quot;); let res = &quot;&quot;; for (let i = 0; i &lt; arr.length; ++i) { if (i === arr.length - 1) res += arr[i]; else res += arr[i] + &quot;%20&quot;; } return res; }; 可以使用字符串的自带函数，注意replace()只替换第一个，而replaceAll()替换全部： var replaceSpace = function(s) { return s.replaceAll(&quot; &quot;, &quot;%20&quot;); }; split()以特定分隔符将字符串拆分为数组，join()则以特定分隔符将数组中元素连接成字符串： var replaceSpace = function(s) { return s.split(&quot; &quot;).join(&quot;%20&quot;); }; ","link":"https://AriesSK.github.io/post/jianzhi_05/"},{"title":"35. 复杂链表的复制","content":"知识点 JavaScript 链表 js 中不提供链表API，是使用对象模拟的，因此解法特殊些。 一个包含三个节点的单链表如下表示（data, next都是对象的属性）： list = { data: 1, next: { data: 2, next: { data: 3, next: null, }, }, }; 题目中的复杂链表实现如下： functuon Node(val, next, random) { this.val = val; this.next = next; this.random = random; } 题解 法一：回溯 + 哈希表 用于将所有b中可枚举属性复制到a中，重名属性则后者覆盖前者： Object.assign(a, b1, b2, ...); 哈希表存值： hashmap.set(key, value); 注意空链表的特殊情况： var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { // 只设置val属性 hash.set(head, {val: head.val}); // 递归复制 next 和 random 属性 Object.assign(hash.get(head), {next: copyRandomList(head.next, hash), random: copyRandomList(head.random, hash)}); } return hash.get(head); }; 也可以在存节点时设置所有的属性，后续递归修改next和random属性的值即可: var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { hash.set(head, {val: head.val, next: head.next, random: head.random}); hash.get(head).next = copyRandomList(head.next, hash); hash.get(head).random = copyRandomList(head.random, hash); } return hash.get(head); }; 法二：迭代 + 节点拆分 先画图后写代码不需要使用哈希表，空间复杂度低： var copyRandomList = function(head) { if (head === null) return null; // 复制节点 for (let node = head; node !== null; node = node.next.next) { const newNode = new Node(node.val, node.next, null); node.next = newNode; } // 复制 random 属性，注意 node.random 指空的情况 for (let node = head; node !== null; node = node.next.next) { const newNode = node.next; newNode.random = (node.random !== null) ? node.random.next : null; } // 创建新的头节点，防止后面断开后找不到新链表的头节点 const newHead = head.next; // 断开新旧链表，注意最后一个节点的 next 指空的情况 for (let node = head; node !== null; node = node.next) { const newNode = node.next; node.next = node.next.next; newNode.next = (newNode.next !== null) ? newNode.next.next : null; } return newHead; }; ","link":"https://AriesSK.github.io/post/jianzhi_35/"},{"title":"24. 反转链表","content":"知识点 递归总结 递归=递归公式+终止条件递归 = 递归公式 + 终止条件递归=递归公式+终止条件 先写出公式，再转换代码。 题解 涉及链表操作的题，建议先把过程画出来，再写成代码。 法一：迭代（双指针） 每次推进一个节点，需要注意提前存next节点，防止断链后找不到后续节点： var reverseList = function(head) { // 从 null 开始 考虑单节点情况 let prev = null; let curr = head; while (curr) { let next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; }; 法二：递归 递归方法需要注意的是递归函数和终止条件： var reverseList = function(head) { // 终止条件： 空链表 或 最后一个节点 if (head == null || head.next == null) return head; // 递归函数：反转 head.next + 处理 head // 反转 head.next let res = reverseList(head.next); // 处理 head，下一个节点指向自己，自己指空 head.next.next = head; head.next = null; return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_24/"},{"title":"06. 从头到尾打印链表","content":"知识点 JavaScript 中的栈 js 中并不存在Stack这个数据结构的API，是使用数组中的两种操作模拟形成的： push() // 向数组末添加元素 pop() // 弹出并返回数组末元素，会改变数组的长度 题解 使用栈倒着打印链表： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.push(ptr.val); ptr = ptr.next; } let number = []; // 下面这行是错误的写法，因为 pop() 改变了 stack.length，导致出错 // for (let i = 0; i &lt; stack.length; ++i) number[i] = stack.pop(); let length = stack.length; for (let i = 0; i &lt; length; ++i) number[i] = stack.pop(); return number; }; 使用unshift()能够直接向数组开头添加元素并返回新长度： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.unshift(ptr.val) ptr = ptr.next; } return stack }; ","link":"https://AriesSK.github.io/post/jianzhi_06/"},{"title":"30. 包含min函数的栈","content":"知识点 JavaScript 的栈 js 中没有栈的API，是使用数组模拟的，因此可以直接通过下标访问栈中任意元素。 题解 利用辅助栈，在主栈与辅助栈同时压入元素。主栈正常，辅助栈比较栈顶与将与将压入元素，选取较小的入栈，保证辅助栈的栈顶元素是就是主栈的 minminmin： var MinStack = function() { this.stack = []; this.min_stack = []; }; /** * @param {number} x * @return {void} */ MinStack.prototype.push = function(x) { this.stack.push(x); // 避免 min_stack 为空时 push 时出错 if (!this.min_stack.length) this.min_stack.push(x); else this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x)); }; /** * @return {void} */ MinStack.prototype.pop = function() { this.stack.pop(); this.min_stack.pop(); }; /** * @return {number} */ MinStack.prototype.top = function() { // java 中 peek() 返回栈顶元素 ，pop()取出并返回栈顶元素 // js 中只有pop() 没有 peek()，访问栈顶元素使用下标 return this.stack[this.stack.length - 1]; }; /** * @return {number} */ MinStack.prototype.min = function() { return this.min_stack[this.min_stack.length - 1]; }; ","link":"https://AriesSK.github.io/post/jianzhi_30/"},{"title":"09. 用两个栈实现队列","content":"知识点 JavaScript 中的prototype js 中使用 prototype 属性给对象的构造函数添加新的属性。 判空 js 中通过长度判空 if(!stack.length) // 如果栈为空 java 中使用isEmpty()判空 题解 使用两个栈实现队列，一个入栈一个出栈，在入栈与出栈中的元素转移时，入栈弹出的是后入元素，应当先压入出栈，从而保证先入先出： // 构造函数 var CQueue = function() { this.inStack = []; this.outStack = []; }; /** * @param {number} value * @return {void} */ // 使用 prototype 给构造函数添加新的属性 // 入队 压入进栈 CQueue.prototype.appendTail = function(value) { this.inStack.push(value); }; /** * @return {number} */ // 出队 CQueue.prototype.deleteHead = function() { if (!this.outStack.length) { // 入栈出栈均为空 队列中没有元素 if (!this.inStack.length) return -1; // 出栈为空 进栈有元素 将进栈元素全部压入出栈 先入先出 while (this.inStack.length) { this.outStack.push(this.inStack.pop()) } } // 出栈有元素 直接弹出 return this.outStack.pop(); }; ","link":"https://AriesSK.github.io/post/jianzhi_09/"}]}