{"posts":[{"title":"54. 二叉搜索树的第k大节点","content":"知识点 运算符优先级 关于运算符的优先级，见21. 调整数组顺序使奇数位于偶数前面 下面两种的运算结果是一样的，这题中都可以： let k = 1; console.log(!--k); // true k = 1; console.log(!(--k)); // true 不过这样写容易出错，还是老实写： let k = 1; console.log(--k == 0); // true 题解 深度优先搜索 二叉搜索树的中序遍历就是升序数组，本题进行逆向的中序遍历，并且设置isFound标志找到了目标，提前结束递归（题目规定不会有空树的情况）： var kthLargest = function(root, k) { let isFound = false, res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (isFound) return; if (k - 1) --k; else { res = root.val; isFound = true; } dfs(root.left); } }; 后来发现isFound可以省略，当k减到 000 时即代表找到了目标： var kthLargest = function(root, k) { let res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (!k) return; // 先自减再判断是否为 0 if (!--k) res = root.val; dfs(root.left); } }; ","link":"https://AriesSK.github.io/post/jianzhi_54/"},{"title":"36. 二叉搜索树与双向链表","content":"知识点 二叉搜索树（二叉查找树，二叉排序树） 定义： 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。 二叉搜索树（Binary Search Tree, BST）的中序遍历是升序序列。 三种深度优先搜索 前中后指的是root节点在三个节点中的位置 前序遍历： var dfs = function(root) { if (!root) return; console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.left); dfs(root.right); } 中序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.right); } 后序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); dfs(root.right); console.log(root.val); // 操作 root 节点，比如打印其值 } 题解 法一：使用队列 我一开始想到的方法，在中序遍历的同时使用一个队列按顺序保存每一个节点，再按顺序输出节点并连接： var treeToDoublyList = function(root) { if (!root) return root; const list = []; dfs(root); const head = list.shift(); let ptr = head; while(list.length) { ptr.right = list.shift(); ptr.right.left = ptr; ptr = ptr.right; } ptr.right = head; head.left = ptr; return head; function dfs(root) { if (!root) return; dfs(root.left); list.push(root); dfs(root.right); } }; 法二：原地算法 事实上并不需要使用队列保存节点，使用一个``pre和一个curr`指针分别保存上一个节点和当前节点即可： var treeToDoublyList = function(root) { let pre, curr; // 空树 if (!root) return root; dfs(root); // 完成中序遍历后还需将头节点和尾节点连接起来成环 head.left = pre; pre.right = head; return head; function dfs(curr) { if (!curr) return; // 先找到最左侧的叶子节点，是链表的头节点 dfs(curr.left); if (pre) pre.right = curr; else head = curr; curr.left = pre; // 更新 curr pre = curr; dfs(curr.right); } }; ","link":"https://AriesSK.github.io/post/jianzhi_36/"},{"title":"34. 二叉树中和为某一值的路径","content":"知识点 JavaScript 的坑 做这道题的过程中遇到了两个坑，记录一下。 声明全局变量 这道题中我需要在dfs(root, target)中使用path和res，所以一开始在最外层声明了变量，即全局变量，像下面这样： const path = [], res = []; var pathSum = function(root, target) {} var dfs = function(root, target) {} 这样写能够通过 Leetcode 的测试用例，但同样的用例在正式提交时却会报错，这是因为上一次用例运行留下的全局变量并没有被销毁，会使之后的用例运行出错，所以应当将dfs(root, target)设置为局部函数： var pathSum = function(root, target) { const path = [], res = []; function dfs(root, target) {} } 引用值 这道题里的path是引用对象，使用res.push([path])是将这个引用对象放入了res中，而后续path对象改变时，res中的path的会随之改变，输出错误结果，正确处理需要深拷贝path存入res中，需要用到展开运算符...。 res.push([...path]); 对于一级基础数据，展开运算符实现深拷贝； 对于二级及以上的复杂数据，展开运算符实现浅拷贝。 题解 深度优先搜索 这道题需要遍历到叶子节点并且输出所有可能，因此无法剪枝。 使用path保存当前遍历的路径，res保存符合要求的路径，需要注意的是在返回上一层递归的时候需要通过path.pop()将path恢复至上一层节点： var pathSum = function(root, target) { const path = [], res = []; dfs(root, target); return res; // 声明函数 function dfs(root, target) { if (!root) return; path.push(root.val); target -= root.val; // 深拷贝 path 并存入 res if (!root.left &amp;&amp; !root.right &amp;&amp; !target) res.push([...path]); dfs(root.left, target); dfs(root.right, target); // 恢复 path path.pop(); }; }; ","link":"https://AriesSK.github.io/post/jianzhi_34/"},{"title":"13. 机器人的运动范围","content":"知识点 JavaScript 中的函数传值 js 中的所有函数的参数都是按值传递的，这意味着函数外的值会被复制到函数内部的参数中，如果是原始值，就跟原始值变量的复制一样，如果是引用值，就和引用值变量的复制一样。 按值传递参数： 外部的值被复制到函数的一个局部变量中，这两个值相互独立，互不干扰； 按引用传递参数： 外部的值在内存中的位置会被保存到函数的一个局部变量中，意味着对局部变量的修改会反应到函数外部，这在 js 中是不可能的。 原始值的按值传递举例，可以看到传入参数与外部值相互独立，互不干扰： function addOne (num) { num += 1; return num; } let count = 20; let res = addOne(count); // count === 20, res === 30 引用值的按值传递举例，如果是按引用传递，那么在新建obj对象的时候，person应该自动将指针改为指向&quot;Aries&quot;的对象，但事实上并没有。这证明了是按值传递的，传递了引用值，而引用的对象是保存在全局作用域，因此可以通过obj访问引用对象修改属性： function setName(obj) { obj.name = &quot;AriesSK&quot;; obj = new Object(); obj.name = &quot;Aries&quot; return num; } let person = new Object(); setName(person); // person.name === &quot;AriesSK&quot; 题解 法一：深度优先搜索 我的解法： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k, res); }; var dfs = function(visit, i, j, k, res) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &lt; 0 || i &gt;= visit.length || j &lt; 0 || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return res; visit[i][j] = 1; res = dfs(visit, i + 1, j, k, res); res = dfs(visit, i - 1, j, k, res); res = dfs(visit, i, j + 1, k, res); res = dfs(visit, i, j - 1, k, res); return ++res; } dfs 解法的优化，省略了不必要的res，并且由于从 (0,0)(0,0)(0,0) 开始，由图可以看出仅通过向右和向下两个方向即可访问所有可达解： var movingCount = function(m, n, k) { const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k); }; var dfs = function(visit, i, j, k) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if ( i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return 0; visit[i][j] = 1; return 1 + dfs(visit, i + 1, j, k) + dfs(visit, i, j + 1, k); } 法二：广度优先搜索 bfs 需要用到队列和循环，无需递归： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); const queue = []; queue.unshift([0, 0]); while(queue.length &gt; 0) { let temp = queue.pop(); let i = temp[0], j = temp[1], s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) continue; visit[i][j] = 1; ++res; queue.unshift([i + 1, j]); queue.unshift([i, j + 1]); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_13/"},{"title":"12. 矩阵中的路径","content":"知识点 深度优先搜索 通过递归的方式，先朝一个方向搜索到底，再回溯至上个节点，沿另一个方向搜索，一次类推。 剪枝 在搜索过程中遇到该路径不可能与目标匹配成功的情况时，应当立即返回，这叫可行性剪枝。 题解 深度优先搜索 + 剪枝 递归终止条件： 返回 false：索引越界 || 当前矩阵元素与目标不匹配（包括已访问）； 返回true：k === word.length - 1，即word已完全匹配。 递推工作： 标记已访问：将board[i][j]修改为 0，防止重复搜索； 搜索下一元素：朝当前元素上、下、左、右四个方向进行下一层递归，使用||连接代表只需找到一条可行路径，记录结果至res； 还原：将board[i][j]还原至初始值word[k]。 var exist = function(board, word) { for (let i = 0; i &lt; board.length; ++i) { for (let j = 0; j &lt; board[0].length; ++j) { if (dfs(board, word, i, j, 0)) return true; } } return false; }; var dfs = function(board, word, i, j, k) { if (i &gt;= board.length || i &lt; 0 || j &gt; board[0].length || j &lt; 0 || board[i][j] !== word[k]) return false; if (k === word.length - 1) return true; // 标记已访问 board[i][j] = 0; const res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1); // 恢复原数组 board[i][j] = word[k]; return res; } ","link":"https://AriesSK.github.io/post/jianzhi_12/"},{"title":"58 - I. 翻转字符单词顺序","content":"知识点 JavaScript 的正则表达式 语法： /正则表达式主体/修饰符(可选) 修饰符不区分大小写： 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符 [0-9] 查找任何从 0 至 9 的数字 (x|y) 查找任何以 | 分隔的选项 元字符是拥有特殊含义的字符： 元字符 描述 \\d 查找数字 \\s 查找空白字符 \\b 匹配单词边界 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 量词: 量词 描述 n+ 匹配任何包含至少一个 n 的字符串 n* 匹配任何包含零个或多个 n 的字符串 n? 匹配任何包含零个或一个 n 的字符串 JavaScript 的字符串函数 本题中使用的一些字符串函数及它们的时间复杂度： trim() // 去除字符串头尾的空格 O(n) split() // 拆分成数组 O(n) reverse() // 反转数组 O(n) join() // 使用特定分隔符将数组连接成字符串 O(n) 其中需要重点说明split()举例如下： let s = &quot;a b c&quot; s.split() // [&quot;a b c&quot;] // 直接返回数组 s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开 s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素 s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数 题解 法一：字符串函数 首先想到使用tirm()删除头尾空格，split(&quot; &quot;)拆分成数组，从数组末尾开始拼接： var reverseWords = function(s) { const arr = s.trim().split(&quot; &quot;); let res = &quot;&quot;; for (let i = arr.length - 1; i &gt;= 0; --i) { if (arr[i] === &quot;&quot;) continue; res += i ? arr[i] + &quot; &quot; : arr[i]; } return res; }; 事实上使用字符串函数代码可以更加简洁： var reverseWords = function(s) { return s.trim().split(/\\s+/).reverse().join(' '); }; 法二：双指针 var reverseWords = function(s) { s = s.trim(); let left = s.length - 1, right = left; let res = &quot;&quot;; // 保证 left 能够取到 0 while (left &gt;= 0) { // 找到第一个空格 while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left; res += s.substring(left + 1, right + 1) + &quot; &quot;; // 忽略空格找到第一个字符 while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left; right = left; } // 删去最后末尾多余的一个空格 return res.trim(); }; ","link":"https://AriesSK.github.io/post/jianzhi_58_i/"},{"title":"57. 和为s的两个数字","content":"知识点 JavaScript 的const 在允许的情况下，推荐使用const进行声明，const声明后无法重新赋值，但可以修改其属性值。 题解 双指针的简单应用： var twoSum = function(nums, target) { let left = 0, right = nums.length - 1; const res = []; // 若允许同一个数自己加自己则取 = while (left &lt; right) { // 在值是正数的情况下，改加为减能够有效防止值溢出 if (nums[left] &gt; target - nums[right]) --right; else if (nums[left] &lt; target - nums[right]) ++left; else { res.push(nums[left]); res.push(nums[right]); // 不适用 break 会导致无限循环入栈至溢出 break; } } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_57/"},{"title":"21. 调整数组顺序使奇数位于偶数前面","content":"知识点 JavaScript 中的运算符优先级 在写代码时需要注意运算符的优先级，如下由于!的运算优先级高于%，因此加不加()是两种结果： let num = 2; console.log(!num % 2); // 0 console.log(!(num % 2)); // true 题解 简单的双指针运用： var exchange = function(nums) { let left = 0, right = nums.length - 1; // while 中是否取等号均可 while (left &lt; right) { if (nums[left] % 2) ++left; else if (!(nums[right] % 2)) --right; else { let temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } return nums; }; ","link":"https://AriesSK.github.io/post/jianzhi_21/"},{"title":"22. 链表中的倒数第k个节点","content":"知识点 JavaScript 中 此类题目对头节点并不需要特殊的处理 因此可以不另设头指针。 题解 双指针 两指针减保持 kkk 距离，直到右指针为空时，左指针即为目标节点： var getKthFromEnd = function(head, k) { let left = head, right = left; while (k &gt; 0) { right = right.next; --k; } while (right) { left = left.next; right = right.next; } return left; }; ","link":"https://AriesSK.github.io/post/jianzhi_22/"},{"title":"18. 删除链表的节点","content":"知识点 在链表前设置一个指向头节点的头指针能够使算法不用单独考虑头节点的处理。 题解 双指针 使用 nextnextnext 遍历目标节点，currcurrcurr 记录目标节点的前一节点，以实现断链 推荐设置一个值为 nullnullnull 的头节点（头指针）newHead，能够有效避免删除头节点或链表为空的情况： var deleteNode = function(head, val) { const newHead = new ListNode(); newHead.next = head; let curr = newHead, next = curr.next; while (next) { if (next.val === val) { curr.next = next.next; next.next = null; break; } curr = curr.next; next = next.next; } return newHead.next; }; ","link":"https://AriesSK.github.io/post/jianzhi_18/"},{"title":"10 - I. 斐波那契数列","content":"知识点 动态规划总结 Those who cannot remember the past are condemned to repeat it. 那些不记得过去的人注定要重蹈覆辙。 动态规划(Dynamic Programming, DP)通过记住求过的解来节省时间，对每一个子问题只求解一次，并将结果存下来。 无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响 最优子结构性质：大的问题的最优解可以由小问题的最优解推出 判断能否使用 DP 解决：是否能够将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 步骤： 状态定义：定义一个状态，这是一个最优解的结构特征； 转移方程：进行状态递推，得到递推公式； 初始状态：进行初始化； 返回结果。 其中最重要的是状态转移方程。 题解 法一：递归 我第一时间想到的思路，且代码简单，但递归过程中重复的计算过多，导致超出了时间限制，无法通过： var fib = function(n) { if (n === 0) return 0; if (n === 1) return 1; return (fib(n - 1) + fib(n - 2)) % (1e9+7); }; 法二：递归 + 哈希表 法一的优化，将每次计算后的结果存在哈希表中，即可避免重复计算，但需要额外O(n)的空间： var fib = function(n, hash = new Map()) { if (n &lt;= 1) return n; if (hash.has(n)) return hash.get(n); // 注意给 1e9+7 加括号 否则会出错 else hash.set(n, (fib(n - 1, hash) + fib(n - 2, hash)) % (1e9+7)); return hash.get(n); }; 法三：动态规划 状态转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2) 由于只涉及到三个值，因此可以用滚动数组法使得空间复杂度为O(1)： 状态定义：F(n)F(n)F(n) 表示第 nnn 个斐波那契数； 转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态：F(0)=0F(0) = 0F(0)=0，F(1)=1F(1) = 1F(1)=1，F(2)=1F(2) = 1F(2)=1； 返回结果：F(n)F(n)F(n)。 var fib = function(n) { const MOD = 1e9+7; if (n &lt; 2) return n; let p = 0, q = 0, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % MOD; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_i/"},{"title":"10 - II. 青蛙跳台阶问题","content":"知识点 类似斐波那契数列的问题，使用动态规划解决，需要注意初始状态的区别。 题解 动态规划 跳上 nnn 级台阶有 F(n)F(n)F(n) 种跳法，在所有跳法中，最后一步只有两种情况： 跳 111 级，有 F(n−1)F(n - 1)F(n−1) 种； 跳 222 级，有 F(n−2)F(n - 2)F(n−2) 种。 所以步骤如下： 状态定义：F(n)F(n)F(n) 表示跳上 nnn 级台阶的跳法总数； 转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态：F(0)=1F(0) = 1F(0)=1，F(1)=1F(1) = 1F(1)=1，F(2)=2F(2) = 2F(2)=2； 返回结果：F(n)F(n)F(n)。 var numWays = function(n) { if (n &lt; 2) return 1; let p = 0, q = 1, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % (1e9+7); } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_ii/"},{"title":"11. 旋转数组的最小数字","content":"知识点 这一题的二分法很特别，因为在numbers[m] = numbers[r]的情况下，无法判断旋转点在哪个半区，因此无法通过常规方法缩小区间，而需要使用--r来缩小区间，而--r的终止条件应当是l === r时，因此本题需要使用模板二，二分法具体模板见53 - I. 在排序数组中查找数字 I。 题解 法一：暴力 找到第一个变小的数字： var minArray = function(numbers) { for (let i = 1; i &lt; numbers.length; ++i) { if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; } // 旋转0个数的情况 return numbers[0]; }; 法二：二分法 要保证每次缩小区间后最小值仍在区间内。 二分会有三种情况： 当 nums[m]&gt;nums[r]nums[m] &gt; nums[r]nums[m]&gt;nums[r] 时： mmm 一定在左排序数组中，即旋转点 xxx 一定在 [m+1,r][m + 1, r][m+1,r] 闭区间内，因此执行 r=m+1r = m + 1r=m+1； 当 nums[m]&lt;nums[r]nums[m] &lt; nums[r]nums[m]&lt;nums[r] 时： mmm 一定在右排序数组中，即旋转点 xxx 一定在 [l,m][l, m][l,m] 闭区间内，因此执行 r=mr = mr=m； 当 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 时： 无法判断 mmm 在哪个排序数组中，即无法判断旋转点 xxx 在 [l,m][l, m][l,m] 还是 [m+1,r][m + 1, r][m+1,r] 区间中，但由于 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 并且 mmm 一定在区间内，因此即使 num[r]num[r]num[r] 是最小值，也可以执行 r=r−1r = r - 1r=r−1 缩小范围。 为什么本题二分法不用 nums[m]nums[m]nums[m] 和 nums[l]nums[l]nums[l] 作比较？ 避免了旋转 000 个数出现的问题。 二分目的是判断 mmm 在哪个排序数组中，从而缩小区间。而在 nums[m]&gt;nums[l]nums[m] &gt; nums[l]nums[m]&gt;nums[l] 情况下，无法判断 mmm 在哪个排序数组中。本质上是由于 rrr 初始值肯定在右排序数组中；但 lll 初始值无法确定在哪个排序数组中。 var minArray = function(numbers) { let l = 0, r = numbers.length; while (l &lt; r) { const m = l + Math.floor((r - l) / 2); if (numbers[m] &gt; numbers[r]) l = m + 1; else if (numbers[m] &lt; numbers[r]) r = m; else --r; } return numbers[l]; }; ","link":"https://AriesSK.github.io/post/jianzhi_11/"},{"title":"04. 二维数组中的查找","content":"知识点 本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。 题解 法一：暴力 注意题目中提示了输入可能是空数组，这种情况需要特别考虑： var findNumberIn2DArray = function(matrix, target) { // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑 if (!matrix.length) return false; let n = matrix.length, m = matrix[0].length; for (let i = 0; i &lt; n; ++i) { for (let j = 0; j &lt; m; ++j) { if (matrix[i][j] === target) return true; } } return false; }; 法二：标志数 将矩阵逆时针旋转 45°，能够发现其结构类似二叉搜索树，左分支更小，右分支更大； 因此从根节点，也就是右上角开始搜索，比target大就向左，否则向右； 矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。 // 右上角开始 var findNumberIn2DArray = function(matrix, target) { if (!matrix.length) return false; let i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &lt; target) ++i; else --j; } return false; }; // 左下角开始 var findNumberIn2DArray = function(matrix, target) { let i = matrix.length - 1, j = 0; // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错 while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &gt; target) --i; else ++j; } return false; }; ","link":"https://AriesSK.github.io/post/jianzhi_04/"},{"title":"53 - II. 0~n-1中缺失的数字","content":"知识点 JavaScript 的排序函数 sort()函数： sort() // 默认按字母升序，40 在 5 前面，是先调用 toString() 再比较 sort(function(a, b){return a - b}) // 按数字升序 sort((a, b) =&gt; a - b) // 按数字升序的简写 sort(function(a, b){return b - a}) // 按数字降序 sort((a, b) =&gt; b - a) // 按数字降序的简写 JavaScript 的箭头函数 // 下面三个等同 var sum = function(a, b) { return a + b; }; var sum = (a, b) =&gt; { return a + b; }; var sum = (a, b) =&gt; a + b; // 一个参数可不用括号 var sum = x =&gt; { retrun x; }; // 没有或多个参数均需要括号 var sum = () =&gt; { return 1; }; 题解 法一：二分法 数组下标与值不同说明已经发生了数字缺失： var missingNumber = function(nums) { let left = 0, right = nums.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === mid) left = mid + 1; else right = mid - 1; } return left; }; 法二：数学 高斯求和公式−目前的和=缺失的数字高斯求和公式 - 目前的和 = 缺失的数字高斯求和公式−目前的和=缺失的数字： var missingNumber = function(nums) { const n = nums.length + 1; let total = Math.floor(n * (n - 1) / 2); let arrSum = 0; for (let i = 0; i &lt; n - 1; i++) { arrSum += nums[i]; } return total - arrSum; }; 法三：暴力 找第一个下标与值不同的位置： var missingNumber = function(nums) { // 如果乱序则先排序 nums.sort((a, b) =&gt; a - b); const n = nums.length + 1; for (let i = 0; i &lt; n - 1; i++) { if (nums[i] !== i) { return i; } } return n - 1; }; ","link":"https://AriesSK.github.io/post/jianzhi_53_ii/"},{"title":"53 - I. 在排序数组中查找数字 I","content":"知识点 二分法总结 有序的序列查找，优先考虑二分法。 无重复元素 查找target在序列中是否出现： const binarySearch(nums, target) { let left = 0, right = nums.length; while (left &lt;= right) { // 能够防止溢出 const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return -1; }; 有重复元素 查找首个大于target的元素序号； 查找首个大于等于target的元素序号（等同于查找首个大于target - 1的元素序号）。 const binarySearch(nums, target) { let left = 0, right = num.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] &lt;= target) left = mid + 1; else right = mid - 1; } return i; } 循环条件写left &lt;= right和left &lt; right的区别 区别在于是否包含最右边的边界值，因为当left==right时，不会再进入循环体，所以right初始化时就取值为len(nums)，这样在for循环中就能保证是在这样一个左闭右开的区间 [left,right)[left,right)[left,right)，且right赋值应该为right = mid而非right = mid-1，因为右半边是开区间，取mid-1就无法验证到mid-1是否是目标值。简单来说区别是right所代表的位置是否参与计算。 两种写法模板 // 模板一 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt;= right 的情况下 right = nums.length - 1 以保证 mid 能够取到 const binarySearch = function(nums, target) { let left = 0, right = nums.length - 1; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return left; } // 模板二 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt; right 的情况下 right = nums.length 因为 mid 最多取到 right - 1 const binarySearch = function(nums, target) { let left = 0, right = nums.length; while (left &lt; right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; } return left; } JavaScript 中的数组越界 js 数组允许越界，越界返回的是undefined。 js 在非严格模式的情况下变量允许不声明直接赋值。 题解 法一：暴力 逐个遍历： var search = function(nums, target) { let start = -1, end = -1; for (let i = 0; i &lt; nums.length; ++i) { if (nums[i] === target) { start = i; break; } } if (start === -1) return 0; // 这里只有在 js 中才行 因为允许数组越界 正常 i = nums.length 时 若nums[i] === target 则 end = nums.length for (let i = start;; ++i) { if (nums[i] !== target) { end = i; break; } } return end - start; }; 法二：二分法 这里的binarySearch()方法目的实际上是寻找tar值能够插入的最右的位置，因此答案为target的右边界减去(target - 1)的右边界。 var search = function(nums, target) { return binarySearch(nums, target) - binarySearch(nums, target - 1); } const binarySearch = function(nums, tar) { let i = 0, j = nums.length - 1; // 用 &lt;= 保证 tar 能够插入最右的位置 而不是 最右的前一位 while (i &lt;= j) { // 不像 java 在 js 中需要手动取整 const m = Math.floor((i + j) / 2); // 由于找最右插入位置 因此即使nums[m] = tar 插入位置也在 m + 1 及之后 if (nums[m] &lt;= tar) i = m + 1; else j = m - 1; } // i 永远比 j 大1 只能返回 i return i; }; // while 中 &lt;= 换为 &lt; 后 改变 j 的初始值 和 j 每次的缩小值 const binarySearch = function(nums, target) { let i = 0, j = nums.length; while (i &lt; j) { const m = i + Math.floor((j - i) / 2); if (nums[m] &lt;= target) i = m + 1; else j = m; } return i; } ","link":"https://AriesSK.github.io/post/jianzhi_53_i/"},{"title":"03. 数组中重复的数字","content":"知识点 JavaScript 中的Map对象与Set对象 Map对象存储键值对，一些常用的方法如下： set(key, value) get(key) has(key) delete(key) Set对象是唯一值的集合，一些常用的方法如下： add(key) clear() // 删除所有 delete(key) entries() keys() values() // 返回值的数组，分别返回键值对、键名、键值，在 Set 中结果相同 has(key) size() Map和Set的 key 可以是任何数据类型。 题解 法一：哈希表 我一开始想到的是使用Map： var findRepeatNumber = function(nums) { let hash = new Map(); for (let i = 0; i &lt; nums.length; ++i) { // 这里需要使用 has()，而不是 get()，防止 get() 取到 0 导致判断出错 if (!hash.has(nums[i])) hash.set(nums[i], i); else return nums[i]; } }; 后来发现Map存储的是键值对，但在这题中只需要存 key，不需要存 value，因此用Set更好： var findRepeatNumber = function(nums) { let set = new Set(); for (let i = 0; i &lt; nums.length; ++i) { if (!set.has(nums[i])) set.add(nums[i]); else return nums[i]; } }; 法二：原地算法 遍历数组nums，设索引初始值为i = 0： 若nums[i] = i：说明此数字已在对应索引位置，无需交换，因此跳过； 若nums[nums[i]] = nums[i]：代表索引nums[i]处和索引i处的元素值都为nums[i]，即找到一组重复值，返回此值nums[i]； 否则：交换索引为i和nums[i]的元素值，将此数字交换至对应索引位置。 若遍历完毕尚未返回，则返回 -1。 var findRepeatNumber = function(nums) { let i = 0; while (i &lt; nums.length) { if (nums[i] === i) { // 直到该位置已放置正确数字再处理下一个位置，以保证数组被完全遍历 ++i; continue; } if (nums[nums[i]] === nums[i]) return nums[i]; let tmp = nums[i]; nums[i] = nums[nums[i]]; // 注意这里 num[i] 已经被修改了值，因此不能用 nums[nums[i]] nums[tmp] = tmp; } return -1; }; ","link":"https://AriesSK.github.io/post/jianzhi_03/"},{"title":"58 - II. 左旋字符串","content":"知识点 JavaScript 的字符串操作函数 charAt(index) // 返回指定索引位置的字符 indexOf() // 返回字符串中检索指定字符第一次出现的位置 replace(searchvalue,newvalue) // 替换第一个子串 replaceAll(searchvalue,newvalue) // 替换所有子串 slice(start, end) // 提取字符串的片段 以新字符串返回 split(separator,limit) // 将字符串分割为子字符串数组 substr(start,length) // 从起始索引号提取字符串中指定数目的字符 substring(start, end) // 提取字符串中两个指定的索引号之间的字符 trim() // 移除字符串首尾空白 题解 substring()： var reverseLeftWords = function(s, n) { return s.substring(n) + s.substring(0, n); }; charAt() + 取余： var reverseLeftWords = function(s, n) { let res = &quot;&quot;; for (let i = 0; i &lt; s.length; ++i) res += s.charAt((i + n) % s.length); return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_58_ii/"},{"title":"05. 替换空格","content":"知识点 JavaScript 中的字符赋值 在 js 中不能直接对字符串中字符赋值： var replaceSpace = function(s) { for (let i = 0; i &lt; s.length; ++i) { if (s[i] === &quot; &quot;) s[i] = &quot;%20&quot;; } return s; }; 正确的做法是使用replace()操作。 题解 不使用字符串方法的解法： var replaceSpace = function(s) { let res = '' for(let i = 0;i &lt; s.length; i++) { if (s[i] === &quot; &quot;) res += &quot;%20&quot;; else res += s[i]; } return res; } 可以使用split()将字符串转化为数组： var replaceSpace = function(s) { arr = s.split(&quot; &quot;); let res = &quot;&quot;; for (let i = 0; i &lt; arr.length; ++i) { if (i === arr.length - 1) res += arr[i]; else res += arr[i] + &quot;%20&quot;; } return res; }; 可以使用字符串的自带函数，注意replace()只替换第一个，而replaceAll()替换全部： var replaceSpace = function(s) { return s.replaceAll(&quot; &quot;, &quot;%20&quot;); }; split()以特定分隔符将字符串拆分为数组，join()则以特定分隔符将数组中元素连接成字符串： var replaceSpace = function(s) { return s.split(&quot; &quot;).join(&quot;%20&quot;); }; ","link":"https://AriesSK.github.io/post/jianzhi_05/"},{"title":"35. 复杂链表的复制","content":"知识点 JavaScript 链表 js 中不提供链表API，是使用对象模拟的，因此解法特殊些。 一个包含三个节点的单链表如下表示（data, next都是对象的属性）： list = { data: 1, next: { data: 2, next: { data: 3, next: null, }, }, }; 题目中的复杂链表实现如下： functuon Node(val, next, random) { this.val = val; this.next = next; this.random = random; } 题解 法一：回溯 + 哈希表 用于将所有b中可枚举属性复制到a中，重名属性则后者覆盖前者： Object.assign(a, b1, b2, ...); 哈希表存值： hashmap.set(key, value); 注意空链表的特殊情况： var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { // 只设置val属性 hash.set(head, {val: head.val}); // 递归复制 next 和 random 属性 Object.assign(hash.get(head), {next: copyRandomList(head.next, hash), random: copyRandomList(head.random, hash)}); } return hash.get(head); }; 也可以在存节点时设置所有的属性，后续递归修改next和random属性的值即可: var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { hash.set(head, {val: head.val, next: head.next, random: head.random}); hash.get(head).next = copyRandomList(head.next, hash); hash.get(head).random = copyRandomList(head.random, hash); } return hash.get(head); }; 法二：迭代 + 节点拆分 先画图后写代码不需要使用哈希表，空间复杂度低： var copyRandomList = function(head) { if (head === null) return null; // 复制节点 for (let node = head; node !== null; node = node.next.next) { const newNode = new Node(node.val, node.next, null); node.next = newNode; } // 复制 random 属性，注意 node.random 指空的情况 for (let node = head; node !== null; node = node.next.next) { const newNode = node.next; newNode.random = (node.random !== null) ? node.random.next : null; } // 创建新的头节点，防止后面断开后找不到新链表的头节点 const newHead = head.next; // 断开新旧链表，注意最后一个节点的 next 指空的情况 for (let node = head; node !== null; node = node.next) { const newNode = node.next; node.next = node.next.next; newNode.next = (newNode.next !== null) ? newNode.next.next : null; } return newHead; }; ","link":"https://AriesSK.github.io/post/jianzhi_35/"},{"title":"24. 反转链表","content":"知识点 递归总结 递归=递归公式+终止条件递归 = 递归公式 + 终止条件递归=递归公式+终止条件 先写出公式，再转换代码。 题解 涉及链表操作的题，建议先把过程画出来，再写成代码。 法一：迭代（双指针） 每次推进一个节点，需要注意提前存next节点，防止断链后找不到后续节点： var reverseList = function(head) { // 从 null 开始 考虑单节点情况 let prev = null; let curr = head; while (curr) { let next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; }; 法二：递归 递归方法需要注意的是递归函数和终止条件： var reverseList = function(head) { // 终止条件： 空链表 或 最后一个节点 if (head == null || head.next == null) return head; // 递归函数：反转 head.next + 处理 head // 反转 head.next let res = reverseList(head.next); // 处理 head，下一个节点指向自己，自己指空 head.next.next = head; head.next = null; return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_24/"},{"title":"06. 从头到尾打印链表","content":"知识点 JavaScript 中的栈 js 中并不存在Stack这个数据结构的API，是使用数组中的两种操作模拟形成的： push() // 向数组末添加元素 pop() // 弹出并返回数组末元素，会改变数组的长度 题解 使用栈倒着打印链表： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.push(ptr.val); ptr = ptr.next; } let number = []; // 下面这行是错误的写法，因为 pop() 改变了 stack.length，导致出错 // for (let i = 0; i &lt; stack.length; ++i) number[i] = stack.pop(); let length = stack.length; for (let i = 0; i &lt; length; ++i) number[i] = stack.pop(); return number; }; 使用unshift()能够直接向数组开头添加元素并返回新长度： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.unshift(ptr.val) ptr = ptr.next; } return stack }; ","link":"https://AriesSK.github.io/post/jianzhi_06/"},{"title":"30. 包含min函数的栈","content":"知识点 JavaScript 的栈 js 中没有栈的API，是使用数组模拟的，因此可以直接通过下标访问栈中任意元素。 题解 利用辅助栈，在主栈与辅助栈同时压入元素。主栈正常，辅助栈比较栈顶与将与将压入元素，选取较小的入栈，保证辅助栈的栈顶元素是就是主栈的 minminmin： var MinStack = function() { this.stack = []; this.min_stack = []; }; /** * @param {number} x * @return {void} */ MinStack.prototype.push = function(x) { this.stack.push(x); // 避免 min_stack 为空时 push 时出错 if (!this.min_stack.length) this.min_stack.push(x); else this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x)); }; /** * @return {void} */ MinStack.prototype.pop = function() { this.stack.pop(); this.min_stack.pop(); }; /** * @return {number} */ MinStack.prototype.top = function() { // java 中 peek() 返回栈顶元素 ，pop()取出并返回栈顶元素 // js 中只有pop() 没有 peek()，访问栈顶元素使用下标 return this.stack[this.stack.length - 1]; }; /** * @return {number} */ MinStack.prototype.min = function() { return this.min_stack[this.min_stack.length - 1]; }; ","link":"https://AriesSK.github.io/post/jianzhi_30/"},{"title":"09. 用两个栈实现队列","content":"知识点 JavaScript 中的prototype js 中使用 prototype 属性给对象的构造函数添加新的属性。 判空 js 中通过长度判空 if(!stack.length) // 如果栈为空 java 中使用isEmpty()判空 题解 使用两个栈实现队列，一个入栈一个出栈，在入栈与出栈中的元素转移时，入栈弹出的是后入元素，应当先压入出栈，从而保证先入先出： // 构造函数 var CQueue = function() { this.inStack = []; this.outStack = []; }; /** * @param {number} value * @return {void} */ // 使用 prototype 给构造函数添加新的属性 // 入队 压入进栈 CQueue.prototype.appendTail = function(value) { this.inStack.push(value); }; /** * @return {number} */ // 出队 CQueue.prototype.deleteHead = function() { if (!this.outStack.length) { // 入栈出栈均为空 队列中没有元素 if (!this.inStack.length) return -1; // 出栈为空 进栈有元素 将进栈元素全部压入出栈 先入先出 while (this.inStack.length) { this.outStack.push(this.inStack.pop()) } } // 出栈有元素 直接弹出 return this.outStack.pop(); }; ","link":"https://AriesSK.github.io/post/jianzhi_09/"}]}