{"posts":[{"title":"60. n个骰子的点数","content":"知识点 正推与逆推 很多题会有正推和逆推两种思考的方式，当一种实现起来困难的时候，不如尝试一下另一种，有时候有惊喜，别让思维受到局限！ 题解 动态规划 这题可以很容易地想到 nnn 个骰子可看作是 n−1n - 1n−1 个骰子再新增一个，因此应当使用动态规划。假设 dp[n][x]dp[n][x]dp[n][x] 表示求 nnn 个骰子点数和为 xxx 的概率，由于新加入的骰子有六种等概率的点数可能性，可以得到递推公式： dp(n,x)=∑i=16f(n−1,x−i)×16dp(n, x)=\\sum_{i=1}^{6} f(n-1, x-i) \\times \\frac{1}{6} dp(n,x)=i=1∑6​f(n−1,x−i)×61​ 但是这个公式转化为代码存在问题，比如求 dp[3][16]dp[3][16]dp[3][16] 应当用到 dp[2][10]dp[2][10]dp[2][10] 至 dp[2][15]dp[2][15]dp[2][15]，但事实上 dp[2]dp[2]dp[2] 的最大点数和只有 121212，也就是只能用到 dp[2][10]dp[2][10]dp[2][10] 至 dp[2][12]dp[2][12]dp[2][12]，这在转换为代码时就会出现越界的问题。 上述递推思想是逆推，如果用正推的思想即可避免越界： 由于新增一个骰子的点数在 111 至 666 之间，所以 dp[n−1][x]dp[n - 1][x]dp[n−1][x] 仅与 dp[n][x+1]dp[n][x + 1]dp[n][x+1] 至 dp[n][x+6]dp[n][x + 6]dp[n][x+6] 有关，所以遍历 dp[n−1]dp[n - 1]dp[n−1] 的各点数和的概率，将其加入到其在 dp[n]dp[n]dp[n] 中相关的项中即可完成正推。 由于数组从 000 开始，因此需注意公式与下标之间的转化： var dicesProbability = function(n) { const dp = new Array(n); dp[0] = new Array(6).fill(1 / 6); for (let i = 1; i &lt; n; ++i) dp[i] = new Array((i + 1) * 5 + 1).fill(0); for (let i = 1; i &lt; n; ++i) { for (let j = 0; j &lt; dp[i - 1].length; ++j) { for (let k = 0; k &lt; 6; ++k) { dp[i][j + k] += dp[i - 1][j] / 6; } } } return dp[n - 1]; }; 上面的方法是定义了一个二维数组，但事实上 dp[n]dp[n]dp[n] 的值仅与 dp[n−1]dp[n - 1]dp[n−1] 有关，因此可以通过两个一维数组来降低空间复杂度，类似于10 - I. 斐波那契数列中的滑动数组思想： var dicesProbability = function(n) { let dp = new Array(6).fill(1 / 6); for (let i = 2; i &lt;= n; ++i) { const tmp = new Array(5 * i + 1).fill(0); // 注意 js 要赋值，否则为 NaN for (let j = 0; j &lt; dp.length; ++j) { for (let k = 0; k &lt; 6; ++k) { tmp[j + k] += dp[j] / 6; } } dp = tmp; } return dp; }; ","link":"https://AriesSK.github.io/post/jianzhi_60/"},{"title":"49. 丑数","content":"知识点 找前 n 个素数(质数) **法一：**首先可以排除所有偶数，然后对奇数使用试除法，对于 nnn，使用 [0,n][0, \\sqrt{n}][0,n​]范围内的整数逐个试除即可，只需要到 n\\sqrt{n}n​ 的原因是如果 nnn 不是素数，则一定有一个非 111 的因数小于 n\\sqrt{n}n​。 法二：埃氏筛法从 222 开始每找到一个素数，就把它的倍数全部筛掉，如果一个数没有被比它小的素数“筛掉”，那它就是素数。需要使用额外的数组空间来记录该数是否已经被筛掉。 法三：欧拉筛法法二的优化算法，法二对于 666 这些多个素数的倍数会重复标记，欧拉筛法就是要保证每个数只被筛掉一次。欧拉筛法比较难理解。 // 找 n 以内的所有素数 var find = function(n) { // num 存素数，mark 标记是否被筛掉 const num = new Array(n), mark = new Array(n).fill(false); let count = 0; for (let i = 2; i &lt;= n; ++i) { // 未被更小的数筛掉，是素数 if (!mark[i]) num[count++] = i; // 遍历素数 for (let j = 0; num[j] &lt;= n / i; ++j) { // 筛掉当前数的素数倍 mark[num[j] * i] = true; // 防止重复标记，以 i = 6, nums[j] = 2 为例，上一行已经通过 2 筛掉了 6，如果不跳出，接下来又会通过 3 筛掉 6，导致重复计算 if (i % num[j] === 0) break; } } return num; } Tips 111 不是质数，但与任何数互质。 互质是指两个整数只有 111 一个公因数。 题解 法一：暴力 我想到了 较大的丑数=较小的丑数∗(2/3/5)较大的丑数 = 较小的丑数 * (2/3/5)较大的丑数=较小的丑数∗(2/3/5)，因此使用哈希集合存储丑数，并对每个数遍历判断，如果其因子有 2/3/5，并且除以因子后仍是丑数，则该数是丑数。可惜这种方法超时了，说明还有优化的空间： var nthUglyNumber = function(n){ const set = new Set(); set.add(1); let i = 1; n -= 1; while (n) { ++i; if (!(i % 2) &amp;&amp; set.has(i / 2) || !(i % 3) &amp;&amp; set.has(i / 3) || !(i % 5) &amp;&amp; set.has(i / 5)) { --n; set.add(i); } } return i; }; 法二：动态规划 上面我的思路是对的，但是没想到可以从头开始递推，只需要从 2 开始每次找 2/3/5 的倍数中最小的那一个，就是要找的丑数，可以通过动态规划的方式： 状态定义： dp[i]dp[i]dp[i] 表示第 i+1i + 1i+1 个丑数； 转移方程： dp[i]=min(dp[a]∗2,dp[b]∗3,dp[c]∗5)dp[i] = min(dp[a] * 2, dp[b] * 3, dp[c] * 5)dp[i]=min(dp[a]∗2,dp[b]∗3,dp[c]∗5)，其中 a,b,ca, b, ca,b,c 从 000 开始，并且丑数选择了哪一个，则其对应的索引自增； 初始状态： dp[0]=1dp[0] = 1dp[0]=1； 返回结果： dp[n−1]dp[n - 1]dp[n−1]。 var nthUglyNumber = function(n){ let a = 0, b = 0, c = 0; const dp = []; dp.push(1); for (let i = 1; i &lt; n; ++i) { const n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5; dp[i] = Math.min(Math.min(n2, n3), n5); if (dp[i] === n2) ++a; if (dp[i] === n3) ++b; if (dp[i] === n5) ++c; } return dp[n - 1]; }; 上面的两种方法中： 动态规划的时间复杂度是 O(n)O(n)O(n)，只需要遍历 nnn 个丑数； 一开始我以为我的方法也是 O(n)O(n)O(n) 的时间复杂度，但后来发现应该是 O(k)O(k)O(k)，其中 kkk 表示第 nnn 个丑数，因为需要遍历每个小于 kkk 的数，显然 kkk 是大于 nnn 的，所以导致了超时。 ","link":"https://AriesSK.github.io/post/jianzhi_49/"},{"title":"19. 正则表达式匹配","content":"知识点 JavaScript 正则表达式 与本题无关，记录一下 js 的正则表达式，格式/正则表达式主体/修饰符(可选)。 正则表达式修饰符 修饰符 说明 i 不区分大小写 g 全局匹配（不是找到第一个就停止） m 多行匹配 正则表达式模式 表达式 说明 [abc] 查找方括号之间的任何字符 [0-9] 查找任何从 0 到 9 的数字 (x|y) 查找任何以 | 分隔的选项 元字符 说明 \\d 查找数字 \\s 查找空白字符 \\b 匹配单词边界 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 量词 说明 n+ 匹配任何包括至少一个 n 的字符串 n* 匹配任何包括零个或多个 n 的字符串 n? 匹配任何包括零个或一个 n 的字符串 Tips &quot;.&quot; 在正则表达式中是表示任意一个字符的通配符，若要使用点字符，则应为 &quot;.&quot; // 可以通过 RegExp() 将字符串转换为正则表达式，test() 是该对象的一个方法，用于检测字符串中是否匹配某个模式 const s = &quot;a*&quot;, test = &quot;a&quot;; const p = new RegExp(s); console.log(p); // /a*/ console.log(p.test(test)); // true 题解 动态规划 用 dp[i][j]dp[i][j]dp[i][j] 表示 sss 的前 iii 个字符与 ppp 中的前 jjj 个字符是否能够匹配。在进行状态转移时，考虑 ppp 的第 jjj 个字符的匹配情况: 如果 ppp 的第 jjj 个字符是普通字符，那么我们必须在 sss 中匹配一个相同的字符，即 f[i][j]={f[i−1][j−1],s[i]=p[j] false, s[i]≠p[j]f[i][j]= \\begin{cases}f[i-1][j-1], &amp; s[i]=p[j] \\\\ \\text { false, } &amp; s[i] \\neq p[j]\\end{cases} f[i][j]={f[i−1][j−1], false, ​s[i]=p[j]s[i]​=p[j]​ 如果 sss 的第 iii 个字符与 ppp 的第 jjj 个字符不相同，那么无法进行匹配；否则可以匹配，而完整的匹配结果取决于前面的部分。 如果 ppp 的第 jjj 个字符是 ∗*∗ ，在匹配的过程中，本质上只会有两种情况: 匹配 sss 末尾的一个字符，则还可以继续进行匹配； 不匹配字符，将该组合视作出现 000 次，不再继续匹配。 如上可以写出状态转移方程: f[i][j]={f[i−1][j] or f[i][j−2],s[i]=p[j−1]f[i][j−2],s[i]≠p[j−1]f[i][j]= \\begin{cases}f[i-1][j] \\text { or } f[i][j-2], &amp; s[i]=p[j-1] \\\\ f[i][j-2], &amp; s[i] \\neq p[j-1]\\end{cases} f[i][j]={f[i−1][j] or f[i][j−2],f[i][j−2],​s[i]=p[j−1]s[i]​=p[j−1]​ 在任意情况下，只要 p[j]p[j]p[j] 是 ...，那么 p[j]p[j]p[j] 一定成功匹配 sss 中的任意一个字符。 最终的状态转移方程如下: f[i][j]={ if (p[j]≠∗)={f[i−1][j−1], match (s[i],p[j]) false, otherwise otherwise ={f[i−1][j] or f[i][j−2], match (s[i],p[j−1])f[i][j−2], otherwise f[i][j]= \\begin{cases}\\text { if }\\left(p[j] \\neq{ }^{*}\\right)= \\begin{cases}f[i-1][j-1], &amp; \\text { match }(s[i], p[j]) \\\\ \\text { false, } &amp; \\text { otherwise }\\end{cases} \\\\ \\text { otherwise }= \\begin{cases}f[i-1][j] \\text { or } f[i][j-2], &amp; \\text { match }(s[i], p[j-1]) \\\\ f[i][j-2], &amp; \\text { otherwise }\\end{cases} \\end{cases}f[i][j]=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​ if (p[j]​=∗)={f[i−1][j−1], false, ​ match (s[i],p[j]) otherwise ​ otherwise ={f[i−1][j] or f[i][j−2],f[i][j−2],​ match (s[i],p[j−1]) otherwise ​​ 其中match(x, y)判断两个字符是否匹配的辅助函数，只有当 yyy 是 ... 或者 xxx 和 yyy 本身相同时，才会返回 truetruetrue。 注意：大部分语言中，字符串的字符下标是从 000 开始的，但本题中 000 用来表示空串而不是第一个元素的下标，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。 var isMatch = function(s, p) { let m = s.length, n = p.length; // 由于 0 表示空串，因此数组的长度需要增加一位 const dp = new Array(m + 1); // 初始化时需要填充 false，因为对于 i 或 j 为 0，也就是空串匹配应当默认无法匹配，代码中不进行赋值，而在 js 中不赋值为 undefined，会影响结果 for (let i = 0; i &lt;= m; ++i) dp[i] = new Array(n + 1).fill(false); // s, p 均为空串，则可以匹配 dp[0][0] = true; for (let i = 0; i &lt;= m; ++i) { for (let j = 1; j &lt;= n; ++j) { if (p.charAt(j - 1) === &quot;*&quot;) { // 即使 dp[i - 1][j] 无法匹配，但只要 dp[i][j - 2] 能够匹配，dp[i][j] 也可以匹配，因为不论 j - 1 是什么字符，都可以通过 * 归零 // 因此这里 dp[i][j] 的结果由两种情况共同决定，有一种能够匹配即可 if (match(s, p, i, j - 1)) dp[i][j] = dp[i - 1][j] || dp[i][j - 2]; else dp[i][j] = dp[i][j - 2]; } else { if (match(s, p, i, j)) dp[i][j] = dp[i - 1][j - 1]; } } } return dp[m][n]; function match(s, p, i, j) { // 需要注意下标与实际字符下标的对应关系 if (!i) return false; if (p.charAt(j - 1) === &quot;.&quot;) return true; return s.charAt(i - 1) === p.charAt(j - 1); } }; ","link":"https://AriesSK.github.io/post/jianzhi_19/"},{"title":"38. 字符串的排列","content":"知识点 Tips 回溯与深度优先搜索的思想不要局限在树、图当中，思维要开阔！ join() // 在未设置参数时，默认以 &quot;,&quot; 分隔 题解 回溯 标准的深度优先搜素，但由于字符可能出现重复的情况，因此需要加入剪枝的操作，使用一个Set()记录已在该位放置过的字符，遇重复时可直接跳过： 本题的深度优先遍历思想是：先固定每一位获取排列的可能，再逐步回溯，考虑每一位的不同可能。简单来说就是当前位固定一个元素后，先不考虑该位的其他可能，尝试固定下一位，在后面的位考虑完后再回溯上来。 var permutation = function(s) { const c = s.split(&quot;&quot;), res = []; dfs(0); return res; function dfs(x) { // 由于最后一位在前一位确定后已经确定，因此直接记录结果并返回 if (x === c.length - 1) { res.push(c.join(&quot;&quot;)); return; } const set = new Set(); // x 指向本轮讨论的位置，i 指向准备放置的字符 for (let i = x; i &lt; c.length; ++i) { // 剪枝 if (set.has(c[i])) continue; set.add(c[i]); swap(x, i); dfs(x + 1); // 注意需要恢复初始排列，保证 dfs 的正确 swap(x, i); } } function swap(a, b) { let tmp = c[a]; c[a] = c[b]; c[b] = tmp; } }; ","link":"https://AriesSK.github.io/post/jianzhi_38/"},{"title":"37. 序列化二叉树","content":"知识点 二叉树的遍历序列 对二叉树的遍历常用的有深度优先遍历的前序遍历、中序遍历、后序遍历以及广度优先遍历的层序遍历，但这些遍历的序列包含的二叉树的信息是不完整的，一个序列可以对应多种可能的二叉树，如果需要完整保存二叉树的信息，则需要将叶子节点之下的 nullnullnull 也记录在序列中，本题就是这种序列的应用。 Tips Number(&quot;null&quot;); // NaN Number(null); // 0 题解 层序遍历 我的解法，我的想法和官方解基本一致，层序遍历一直记录到最后一个叶子节点，并将遍历过程中的 nullnullnull 也记录下来。不过我为了让字符串和示例的一致，将最后一个节点之后的 nullnullnull 全部删除了，这会导致在反序列化的过程中对于最后一个父节点无右孩子的情况容易出错，需要添加额外判断： var serialize = function(root) { if (!root) return &quot;&quot;; const res = [], queue = []; queue.push(root); while (queue.length) { const tmp = queue.shift(); if (tmp) { res.push(tmp.val); queue.push(tmp.left); queue.push(tmp.right); } else res.push(&quot;null&quot;); // 如果是 null 的话转化为最终拼接时字符串会变成 &quot;&quot; } for (let i = res.length - 1; i &gt;= 0; --i) { // 删除最后一个节点后多余的 null if (res[i] !== &quot;null&quot;) break; res.pop(); } return res.join(&quot;,&quot;); }; var deserialize = function(data) { if (data === &quot;&quot;) return null; // 注意这里是返回 null 而不是 [] const arr = data.split(&quot;,&quot;), queue = []; const root = new TreeNode(Number(arr.shift())); queue.push(root); while (arr.length) { const tmp = queue.shift(); const left = arr.shift(); if (left !== &quot;null&quot;) { tmp.left = new TreeNode(Number(left)); queue.push(tmp.left); } if (arr.length) { // 最后一个父节点可能没有右孩子导致出错，额外判断 const right = arr.shift(); if (right !== &quot;null&quot;) { tmp.right = new TreeNode(Number(right)); queue.push(tmp.right); } } } return root; }; 如果序列化的时候不删除序列末尾的 nullnullnull 则还可以简化部分代码。 ","link":"https://AriesSK.github.io/post/jianzhi_37/"},{"title":"59 - II. 队列的最大值","content":"知识点 JavaScript 的this关键字 js 中的this会随着执行环境的改变而改变： 在方法中，this表示该方法所属的对象； 单独使用，this表示全局对象； 在函数中，this表示全局对象； 在函数中，在严格模式下，this是 undefinedundefinedundefined； 在事件中，this表示接收事件的元素； 类似call()和apply()方法可以将this引用到任何对象。 题解 单调队列 与59 - I. 滑动窗口的最大值的思想一致，维护一个辅助的非严格递减的单调队列即可： var MaxQueue = function() { this.queue = []; this.max_queue = []; }; /** * @return {number} */ MaxQueue.prototype.max_value = function() { return this.queue.length ? this.max_queue[0] : -1; }; /** * @param {number} value * @return {void} */ MaxQueue.prototype.push_back = function(value) { this.queue.push(value); while (this.max_queue.length &amp;&amp; this.max_queue[this.max_queue.length - 1] &lt; value) this.max_queue.pop(); this.max_queue.push(value); }; /** * @return {number} */ MaxQueue.prototype.pop_front = function() { if (this.max_queue[0] === this.queue[0]) this.max_queue.shift(); if (!this.queue.length) return -1; return this.queue.shift(); }; ","link":"https://AriesSK.github.io/post/jianzhi_59_ii/"},{"title":"59 - I.滑动窗口的最大值","content":"知识点 JavaScript 中的最值 特别要注意的是MIN_VALUE是极小的正数： Number.MAX_VALUE // 1.7976931348623157e+308 Number.MIN_VALUE // 5e-324 注意这是一个无限接近零的 正数 Number.MAX_SAFE_INTEGER // 2^53 - 1 Number.MIN_SAFE_INTEGER // -(2^53 - 1) 这是负数 如果需要负数可以使用： -Number.MAX_VALUE 题解 法一：暴力 时间复杂度是 O(nk)O(nk)O(nk)，主要问题就是窗口移动时被移除的元素可能就是窗口中的唯一最大值，因此每次都得在窗口中重新遍历获取最大值： var maxSlidingWindow = function(nums, k) { if (!nums.length) return []; const res = []; for (let i = 0; i &lt;= nums.length - k; ++i) { let max = -Number.MAX_VALUE; for (let j = 0; j &lt; k; ++j) { max = Math.max(max, nums[i + j]); } res.push(max); } return res; }; 法二：单调队列 这道题是可以优化到线性时间复杂度 O(n)O(n)O(n) 的，需要用到单调队列（单调递减或递增的队列），在遍历数组的时候维护一个非严格递减的单调队列，队列中仅包含当前窗口内的元素，但不必包含当前窗口内的所有元素： var maxSlidingWindow = function(nums, k) { if (!nums.length) return []; const res = [], queue = []; // 构建初始的单调队列，保存第一个窗口中的一个递减序列 for (let i = 0; i &lt; k; ++i) { while (queue.length &amp;&amp; queue[queue.length - 1] &lt; nums[i]) queue.pop(); queue.push(nums[i]); } res.push(queue[0]); // for (let j = k; j &lt; nums.length; ++j) { // 如果队首是这一轮窗口需要移除的元素，则将其出队，以保证队列中只有当前窗口元素 // nums[j - k] 表示本轮需要移除的元素，如果不等于队首，说明该元素已被队列移除 if (queue[0] === nums[j - k]) queue.shift(); while (queue.length &amp;&amp; queue[queue.length - 1] &lt; nums[j]) queue.pop(); queue.push(nums[j]); res.push(queue[0]); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_59_i/"},{"title":"67. 把字符串转换为整数","content":"知识点 JavaScript 的幂运算 js 中的**表示幂运算，等同于`Math.pow()。 判断字符是否是数字字符 if (s &lt;= '9' &amp;&amp; s &gt;= '0') return true; if (s &gt; '9' || s &lt; '0') return false; 题解 遍历 遍历字符串的每个字符，每个字符的可能情况和处理如下： 若是空格，继续遍历； 若是 +++ 或 −-−，记录并继续遍历； 若是非数字字符，结束遍历； 若是数字字符，转为数字并计入结果（js 中一元运算符的+能进行类型转换）。 若最终结果超题目要求范围，按题目要求返回值即可，因为不会超过 js 的数字表示范围。 var strToInt = function(str) { let res = 0, i = 0, s = 1; if (!str.length) return 0; while (str.charAt(i) === &quot; &quot;) { if (i === str.length) return 0; ++i; } if (str.charAt(i) === '-') s = -1; if (str.charAt(i) === '+' || str.charAt(i) === '-') ++i; for (let j = i; j &lt; str.length; ++j) { if (str.charAt(j) &gt; '9' || str.charAt(j) &lt; '0') break; res = res * 10 + +str.charAt(j); } return s === 1 ? Math.min(res, 2**31 - 1) : Math.max(-res, -(2**31)); }; ","link":"https://AriesSK.github.io/post/jianzhi_67/"},{"title":"20. 表示数值的字符串","content":"知识点 有限状态自动机 定义状态； 画出状态转移图； 编写代码（利用数组和哈希表存储状态转移表）。 题解 最开始利用 js 自身的特性写了一种抖机灵的解法，仅供一乐： var isNumber = function(s) { if(s.trim() === &quot;&quot;) return false; return !isNaN(Number(s)); }; 有限状态自动机 这道题的正统解法还是有限状态自动机： var isNumber = function(s) { // 使用数组存储自动机的九种状态，使用哈希表存储状态转移表 const states = [ new Map([[' ', 0], ['s', 1], ['d', 2], ['.', 4]]), new Map([['d', 2], ['.', 4]]), new Map([['d', 2], ['.', 3], ['e', 5], [' ', 8]]), new Map([['d', 3], ['e', 5], [' ', 8]]), new Map([['d', 3]]), new Map([['s', 6], ['d', 7]]), new Map([['d', 7]]), new Map([['d', 7], [' ', 8]]), new Map([[' ', 8]]) ]; // p 为当前状态， t 为字符类型 let p = 0, t; for (let c of s.split('')) { if (c &gt;= '0' &amp;&amp; c &lt;= '9') t = 'd'; else if(c === '+' || c === '-') t = 's'; else if(c === 'e' || c === 'E') t = 'e'; else if(c === '.' || c === ' ') t = c; else t = '?'; // 无法转移至下一个状态，返回 false if (!states[p].has(t)) return false; p = states[p].get(t); } // 四种合法的结束状态 return p === 2 || p === 3 || p === 7 || p === 8; }; ","link":"https://AriesSK.github.io/post/jianzhi_20/"},{"title":"31. 栈的压入、弹出序列","content":"知识点 快速判断出栈序列是否合法 对于出栈序列中的每个元素，所有在它后面出栈的但比它先入栈的元素，其出栈顺序必定与入栈顺序相反。因为比它先入栈的元素要不先于它出栈，要不还在栈中，而在栈中则必定先进后出。 这种判定方法在适用于选择题中的快速判断，特别在入栈元素是递增时，只需要判断出栈序列中每个元素后面比它小的元素有没有遵循递减排列即可，不过在算法中复杂度比较高。 题解 模拟 使用一个辅助栈来模拟操作，看看能否模拟成功： var validateStackSequences = function(pushed, popped) { const stack = []; let i = 0; for (num of pushed) { // 按入栈顺序入栈 stack.push(num); // 每次入栈后判断，将符合出栈顺序的元素全部出栈 while (stack.length &amp;&amp; stack[stack.length - 1] === popped[i]) { stack.pop(); ++i; } } // 最终栈为空返回 true return !stack.length; }; ","link":"https://AriesSK.github.io/post/jianzhi_31/"},{"title":"29. 顺时针打印矩阵","content":"知识点 JavaScript 二维数组声明的坑 如下声明数组，然后更改第一行第一列的元素，发现居然第一列的元素都被改了，这是由于第一个fill()创建的三个Array()对象指向同一个内存地址，类似浅拷贝，因此修改其中一个就会同时变更其余的： const flag = new Array(3).fill(new Array(3).fill(0)); flag[0][0] = 1; console.log(flag); // [[1,0,0],[1,0,0],[1,0,0]] 所以js里声明二维数组还是老老实实用循环吧： const flag = new Array(3); for (let i = 0; i &lt; n; ++i) flag[i] = new Array(3).fill(0); 题解 错误解法 我的开始的错误想法是通过递归的方式，遵循右下左上的顺序遍历，但后来发现在应当向上遍历的过程中由于向右的优先级更高，会在后段遍历出现顺序的错误： var spiralOrder = function(matrix) { if (!matrix.length) return matrix; const m = matrix.length, n = matrix[0].length; const res = []; const flag = new Array(m); for (let i = 0; i &lt; m; ++i) flag[i] = new Array(n).fill(0); print(0, 0); return res; function print(i, j) { if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || flag[i][j]) return; res.push(matrix[i][j]); flag[i][j] = 1; print(i, j + 1); print(i + 1, j); print(i, j - 1); print(i - 1, j); }; }; 模拟 + 设定边界 顺时针打印矩阵的顺序是“从左向右、从上向下、从右向左、从下向上”循环，因此，设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。 对四个方向进行循环打印，每个方向步骤为： 根据边界顺序打印元素； 边界向内收缩 111，表示已被打印； 判断打印是否完成，即边界是否相遇，相遇则跳出。 var spiralOrder = function(matrix) { if (!matrix.length) return matrix; let l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1; const res = []; while (true) { for (let i = l; i &lt;= r; ++i) res.push(matrix[t][i]); if (++t &gt; b) break; for (let i = t; i &lt;= b; ++i) res.push(matrix[i][r]); if (--r &lt; l) break; for (let i = r; i &gt;= l; --i) res.push(matrix[b][i]); if (--b &lt; t) break; for (let i = b; i &gt;= t; --i) res.push(matrix[i][l]); if (++l &gt; r) break; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_29/"},{"title":"62. 圆圈中最后剩下的数字","content":"知识点 约瑟夫环 这道题是经典的约瑟夫环问题，其推到过程如下： 对于 ⌈n,m\\lceil n, m⌈n,m 问题」，首轮删除环中第 mmm 个数字后，得到一个长度为 n−1n-1n−1 的数字环。由于有可能 m&gt;m&gt;m&gt; nnn ，因此删除的数字为 (m−1)%n(m-1) \\% n(m−1)%n ，删除后的数字环从下个数字（即 m%n)m \\% n)m%n) 开始，设 t=m%nt=m \\% nt=m%n ，可 得数字环： t,t+1,t+2,…,0,1,…,t−3,t−2t, t+1, t+2, \\ldots, 0,1, \\ldots, t-3, t-2 t,t+1,t+2,…,0,1,…,t−3,t−2 删除一轮后的数字环也变为一个 ⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」，观察以下数字编号对应关系，这里的等价替换是本题的精华部分，就是将一个⌈n,m\\lceil n, m⌈n,m 问题」用一个改变起点的⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」等价替换： ⌈n−1,m 问题」→⌈n,m 问题」删除后 0→t+01→t+1…→…n−2→t−2\\begin{array}{rlr} \\lceil n-1, m \\text { 问题」} &amp; \\rightarrow &amp; \\lceil n, m \\text { 问题」删除后 } \\\\ 0 &amp; \\rightarrow &amp; t+0 \\\\ 1 &amp; \\rightarrow &amp; t+1 \\\\ \\ldots &amp; \\rightarrow &amp; \\ldots \\\\ n-2 &amp; \\rightarrow &amp; t-2 \\end{array} ⌈n−1,m 问题」01…n−2​→→→→→​⌈n,m 问题」删除后 t+0t+1…t−2​ 设 ⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」某数字为 xxx ，则可得递推关系: x→(x+t)%nx \\rightarrow(x+t) \\% n x→(x+t)%n 比如下图中⌈4,3\\lceil 4, 3⌈4,3 问题」的第 000 位实际上是⌈5,3\\lceil 5, 3⌈5,3 问题」的第 0+30 + 30+3 位。 换而言之，若已知 ⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」的解 f(n−1)f(n-1)f(n−1) ，则可通过以上公式计算得到 ⌈n,m\\lceil n, m⌈n,m 问题」的解 f(n)f(n)f(n) ，即: f(n)=(f(n−1)+t)%n=(f(n−1)+m%n)%n=(f(n−1)+m)%n\\begin{aligned} f(n) &amp;=(f(n-1)+t) \\% n \\\\ &amp;=(f(n-1)+m \\% n) \\% n \\\\ &amp;=(f(n-1)+m) \\% n \\end{aligned} f(n)​=(f(n−1)+t)%n=(f(n−1)+m%n)%n=(f(n−1)+m)%n​ 题解 动态规划 我的思路是构建列表来模拟删除过程，但是其时间复杂度是 O(nm)O(nm)O(nm)，这是不可接受的，这道题的正确解法应当是动态规划： 状态定义： dp[i]dp[i]dp[i] 表示 ⌈i,m\\lceil i, m⌈i,m 问题」的解； 转移方程： dp[i]=(dp[i−1]+m)%idp[i] = (dp[i - 1] + m) \\% idp[i]=(dp[i−1]+m)%i； 初始状态： dp[1]=0dp[1] = 0dp[1]=0 ； 返回结果： dp[n]dp[n]dp[n]。 var lastRemaining = function(n, m) { // x 代表最终被剩下的元素在上一级数组中的下标 let x = 0; for (let i = 2; i &lt;= n; ++i) x = (x + m) % i; return x; }; ","link":"https://AriesSK.github.io/post/jianzhi_62/"},{"title":"57 - II. 和为s的连续正数序列","content":"知识点 滑动窗口 滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。 滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)O(n)O(n)。 题解 法一：暴力 + 二分 我的思路是start从 111 开始枚举，end通过二分法查找，通过求和公式判断是否为 targettargettarget： var findContinuousSequence = function(target) { const res = []; for (let start = 1; start &lt;= target &gt;&gt; 1; ++start) { let l = start, r = (target &gt;&gt; 1) + 1; while(l &lt;= r) { const end = (l + r) &gt;&gt; 1; if (sum(start, end) === target) { const tmp = []; for (let i = start; i &lt;= end; ++i) tmp.push(i); res.push(tmp); break; } if (sum(start, end) &lt; target) l = end + 1; else r = end - 1; } } return res; }; var sum = function(start, end) { return (start + end) * (end - start + 1) / 2; } 法二：暴力 + 数学优化 上面的方法可以使用数学方法优化，减免查找end的时间复杂度： 我们在知道起点 xxx 和终点 yyy ，那么 xxx 累加到 yyy 的和由求和公式可以知道是 (x+y)×(y−x+1)2\\frac{(x+y) \\times(y-x+1)}{2}2(x+y)×(y−x+1)​ ，那 么问题就转化为了是否存在一个正整数 y(y&gt;x)y(y&gt;x)y(y&gt;x) ，满足等式 (x+y)×(y−x+1)2= target \\frac{(x+y) \\times(y-x+1)}{2}=\\text { target } 2(x+y)×(y−x+1)​= target 转化一下变成 y2+y−x2+x−2× target =0y^{2}+y-x^{2}+x-2 \\times \\text { target }=0 y2+y−x2+x−2× target =0 这是一个关于 yyy 的一元二次方程，其中 a=1,b=1,c=−x2+x−2×a=1, b=1, c=-x^{2}+x-2 \\timesa=1,b=1,c=−x2+x−2× target 直接套用求根公式即可 O(1)O(1)O(1) 解得 yyy ，判断是否整数解需要满足两个条件: 判别式 b2−4acb^{2}-4 a cb2−4ac 开根需要为整数； 最后的求根公式的分子需要为偶数，因为分母为 222。 var findContinuousSequence = function(target) { const res = []; for (let start = 1; start &lt;= target &gt;&gt; 1; ++start) { let delta = 1 - 4 * (start - start * start - 2 * target); if (delta &lt; 0) continue; let sqrt = Math.sqrt(delta); if ((sqrt - 1) % 2 === 0) { let end = (sqrt - 1) / 2; const tmp = []; for (let i = start; i &lt;= end; ++i) tmp.push(i); res.push(tmp); } } return res; }; 法三：滑动窗口（双指针） 这道题是滑动窗口的典型应用，因为两边界只需要向右移动即可找到所有解： var findContinuousSequence = function(target) { let l = 1, r = 2, sum = 3; const res = []; while(l &lt; r) { if (sum === target) { const tmp = []; for (let i = l; i &lt;= r; ++i) tmp.push(i); res.push(tmp); } // 为了找到所有解，不论什么情况都需要移动一侧边界 if (sum &gt;= target) { sum -= l; ++l; } else { ++r; sum += r; } } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_57_ii/"},{"title":"14 - I.剪绳子","content":"知识点 数学推导 推论一：将绳子 以相等的长度等分为多段，得到的乘积最大。 以下公式为算术几何均值不等式，等号当且仅当 n1=n2=…=nan_{1}=n_{2}=\\ldots=n_{a}n1​=n2​=…=na​ 时成立。 n1+n2+…+naa≥n1n2…naa\\frac{n_{1}+n_{2}+\\ldots+n_{a}}{a} \\geq \\sqrt[a]{n_{1} n_{2} \\ldots n_{a}} an1​+n2​+…+na​​≥an1​n2​…na​​ 推论二：尽可能将绳子以长度 3 等分为多段时，乘积最大。 设将绳子按照 xxx 长度等分为 aaa 段，即 n=axn=a xn=ax ，则乘积为 xax^{a}xa 。观察以下公式，由于 nnn 为常数 因此当 x1xx \\frac{1}{x}xx1​ 取最大值时， 乘积达到最大值。 xa=xnx=(x1x)nx^{a}=x^{\\frac{n}{x}}=\\left(x^{\\frac{1}{x}}\\right)^{n} xa=xxn​=(xx1​)n 根据分析，可将问题转化为求 y=x1xy=x \\frac{1}{x}y=xx1​ 的极大值，因此对 xxx 求导数。 ln⁡y=1xln⁡x 取对数 1yy˙=1x2−1x2ln⁡x 对 x 求导 =1−ln⁡xx2y˙=1−ln⁡xx2x 整理得 \\begin{array}{rlr} \\ln y &amp; =\\frac{1}{x} \\ln x &amp; \\text { 取对数 } \\\\ \\frac{1}{y} \\dot{y} &amp; =\\frac{1}{x^{2}}-\\frac{1}{x^{2}} \\ln x &amp; \\text { 对 } x \\text { 求导 } \\\\ &amp; =\\frac{1-\\ln x}{x^{2}} &amp; \\\\ \\dot{y} &amp; =\\frac{1-\\ln x}{x^{2}} x &amp; \\text { 整理得 } \\end{array} lnyy1​y˙​y˙​​=x1​lnx=x21​−x21​lnx=x21−lnx​=x21−lnx​x​ 取对数 对 x 求导 整理得 ​ 令 y˙=0\\dot{y}=0y˙​=0 ，则 1−ln⁡x=01-\\ln x=01−lnx=0 ，易得驻点为 x0=e≈2.7x_{0}=e \\approx 2.7x0​=e≈2.7 ；根据以下公式，可知 x0x_{0}x0​ 为极大值点。 y˙{&gt;0,x∈[−∞,e)&lt;0,x∈(e,∞]\\dot{y} \\begin{cases}&gt;0 &amp; , x \\in[-\\infty, e) \\\\ &lt;0 &amp; , x \\in(e, \\infty]\\end{cases} y˙​{&gt;0&lt;0​,x∈[−∞,e),x∈(e,∞]​ 由于切分长度 xxx 必须为整数，最接近 eee 的整数为 2 或 3 。如下式所示，代入 x=2x=2x=2 和 x=3x=3x=3 ， 得出 x=3x=3x=3 时，乘积达到最大。 y(3)=31/3≈1.44y(2)=21/2≈1.41\\begin{aligned} &amp;y(3)=3^{1 / 3} \\approx 1.44 \\\\ &amp;y(2)=2^{1 / 2} \\approx 1.41 \\end{aligned} ​y(3)=31/3≈1.44y(2)=21/2≈1.41​ 题解 法一：数学 这种方法时空复杂度均为 O(1)O(1)O(1)，根据数学方法可以获得推论： 所有绳段长度相等时乘积最大； 每段的最优长度为 333。 从而得出切分规则： 最优：333。把绳子尽可能切为多个长度为 333 的片段，留下的最后一段绳子的长度可能为 0,1,20,1,20,1,2 三种情况； 次优：222。若最后一段绳子长度为 222；则保留，不再拆分； 最差：111。若最后一段绳子长度为 111；则应把一份 3+13 + 13+1 替换为 2+22 + 22+2，因为 2×2&gt;3×12 \\times 2 &gt; 3 \\times 12×2&gt;3×1。 var cuttingRope = function(n) { if (n &lt;= 3) return n - 1; // 注意 js 中因为不分整型和浮点型 因此不是整除 let a = Math.floor(n / 3), b = n % 3; if (b === 0) return Math.pow(3, a); if (b === 1) return Math.pow(3, a - 1) * 4; return Math.pow(3, a) * 2; }; 法二：动态规划 状态定义： dp[i]dp[i]dp[i] 表示将长度为 iii 的绳子剪成至少两段绳子之后，这些绳子长度的最大乘积； 转移方程： 当 i≥2i \\geq 2i≥2 时，假设对长度为 iii 绳子剪出的第一段绳子长度是 j(1≤j&lt;i)j(1 \\leq j&lt;i)j(1≤j&lt;i)，其中 jjj 的需要对每个值进行遍历，则有以下两种方案： 将 iii 剪成 jjj 和 i−ji - ji−j 长度的绳子，且 i−ji - ji−j 不再继续剪，此时的乘积是 j×(i−j)j \\times (i - j)j×(i−j)； 将 iii 剪成 jjj 和 i−ji-ji−j 长度的绳子，且 i−ji-ji−j 继续剪成多段长度的绳子，此时的乘积是 j×dp[i−j]j \\times d p[i-j]j×dp[i−j]； 因此有 dp[i]=max⁡(dp[i],max⁡(j×(i−j),j×dp[i−j]))dp[i] = \\max (dp[i], \\max (j \\times(i - j), j \\times dp[i-j]))dp[i]=max(dp[i],max(j×(i−j),j×dp[i−j])) 。 初始状态： dp[1]=1dp[1] = 1dp[1]=1 ； 返回结果： dp[n]dp[n]dp[n]。 var cuttingRope = function(n) { const dp = new Array(n + 1).fill(0); dp[1] = 1; for (let i = 2; i &lt;= n; ++i) { for (let j = 1; j &lt; i; ++j) dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[i - j] * j)); } return dp[n]; }; ","link":"https://AriesSK.github.io/post/jianzhi_14_i/"},{"title":"66. 构建乘积数组","content":"知识点 需要对学过的算法思想学以致用！ 题解 动态规划思想 看到这题我的第一想法就是先遍历数组获取所有元素的乘积，然后每次除其中一个数，获取结果。但这种方法要求数组中不出现 000，而且题目要求了不能使用除法。 事实上，看到这种后一个状态计算与前一个有关的题目，第一时间要想到动态规划，这题的思路就是左右两个 dpdpdp，分别存储下标 iii 左右的数字的累乘结果。 在这道题中两个 dpdpdp 还能使用输出数组替代以降低空间复杂度，由于当前状态只与前一个的状态相关，因此只需要使用一个tmp来存储中间结果即可（逆向的时候）。 var constructArr = function(a) { if (!a.length) return a; const b = new Array(a.length); b[0] = 1; for (let i = 1; i &lt; a.length; ++i) b[i] = b[i - 1] * a[i - 1]; let tmp = 1; for (let j = a.length - 2; j &gt;= 0; --j) { tmp *= a[j + 1]; b[j] *= tmp; } return b; }; ","link":"https://AriesSK.github.io/post/jianzhi_66/"},{"title":"39. 数组中出现次数超过一半的数字","content":"知识点 JavaScript 的Map() Set()和Map()的 keykeykey都是不能重复的，在Map()中重复赋值会覆盖之前的： const map = new Map(); map.set(&quot;name&quot;, &quot;Aries&quot;); map.set(&quot;name&quot;, &quot;AriesSK&quot;); console.log(map); // {&quot;name&quot; =&gt; &quot;AriesSK&quot;} keykeykey 可以不声明，valuevaluevalue不行： const map = new Map(); map.set(name, Aries); map.set(name, AriesSK); console.log(map); // {&quot;&quot; =&gt; &quot;AriesSK&quot;} const map = new Map(); map.set(name, Aries); map.set(name, AriesSK); console.log(map); // undefined 题解 法一：哈希表 遍历数组，同时用哈希表记录每个数的出现次数，发现超过数组长度一半的直接返回结果： var majorityElement = function(nums) { const map = new Map(); for (const num of nums) { if (map.has(num)) map.set(num, map.get(num) + 1); else map.set(num, 1); if (map.get(num) * 2 &gt; nums.length) return num; } }; 法二：排序 对数组排序，数组中间的数一定是所求数，这里不管怎么排序，只要能让相同的数排在一起，就能输出正确的结果： var majorityElement = function(nums) { //nums.sort(); 这样写是默认按字母升序的，比如 40 会排在 5 前面，不过本题不影响结果 nums.sort((a, b) =&gt; a - b); // 正确的按数字升序 return nums[nums.length &gt;&gt; 1]; }; 法三：摩尔投票法 本题的最优解法，时间复杂度 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1)，其核心思想是票数抵消，票多者胜，拟将超过一半的数称为众数： 由于众数占据超过数组的一半，设其票数为 +1+1+1，其余数票数为 −1-1−1，则票数和为正； 若前几个数字票数和为 000，则剩余数字票数和仍为正，且众数不变。 因此每次设区间的第一个数 xxx 为众数，遍历到出现票数和为 000 的情况，不论 xxx 是不是真正的众数 yyy，在票数和为 000 的区间内，yyy 的出现次数最多占据一半，因此剩余元素中 yyy 仍占据超过一半，因此以此不断缩小空间至遍历完数组，输出最后一个假设数 xxx。 简单来说，不论是众数与非众数对拼消耗还是非众数内部消耗，剩余的数里一定是众数占优： var majorityElement = function(nums) { let vote = 0, res = 0; for (const num of nums) { if (!vote) res = num; vote += num === res ? 1 : -1; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_39/"},{"title":"56 - II. 数组中数字出现的次数 II","content":"知识点 JavaScript 声明特定长度的数组 注意在声明数字数组时一定要记得初始化值，否则会出错： const arr = new Array(5); for (let i = 0; i &lt; 5; ++i) arr[i] += 1; // [NaN, NaN, NaN, NaN, NaN] const arr = new Array(5).fill(0); for (let i = 0; i &lt; 5; ++i) arr[i] += 1; // [1, 1, 1, 1, 1] 位运算获取每一位和为每一位赋值 获取每一位： for (let i = 0; i &lt; 32; ++i) { res[i] += num &amp; 1; // 1 &amp; 0(1) === 0(1) num &gt;&gt;&gt;= 1; } 为每一位赋值： for (let j = 31; j &gt;= 0; --j) { res &lt;&lt;= 1; res |= counts[j] % 3; // 0 | 0(1) === 0(1) } 题解 遍历 + 位运算 这道题没要求空间复杂度，可以使用哈希表，但还有更好的方法： 遍历数组每一个数的每一位，统计每一位 111 出现的次数，对 333 求余后获得所求数： var singleNumber = function(nums) { const counts = new Array(32).fill(0); for (num of nums) { for (let i = 0; i &lt; 32; ++i) { // 每次 &amp; 1 并且右移的操作能够获取 num 的每一位 counts[i] += num &amp; 1; num &gt;&gt;&gt;= 1; } } let res = 0; for (let j = 31; j &gt;= 0; --j) { // 每次左移并且 | 的操作能够为 res 的每一位赋值 res &lt;&lt;= 1; res |= counts[j] % 3; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_56_ii/"},{"title":"56 - I. 数组中数字出现的次数 I","content":"知识点 异或寻找只出现一次的数字 如果数组中只有一个数组出现了一次，其余的都出现了两次，那么解决方法就很简单，只需要对整个数组进行异或运算，成对的数字会两两抵消，剩下的最终结果就是想要找的数字。 题解 分组异或 这道题的难点在于限制了时间复杂度和空间复杂度，所以暴力和哈希都不能使用，并且只出现一次的数字变成了两个，因此无法直接使用异或运算获得结果，需要进行分组，分组目标是： 成对的数字分在同一组； 只出现一次的数字分在不同组。 因此解决方法是： 使用a，b代表两个分组的异或结果，c代表整个数组的异或结果（实际上就是所求两个数字的异或结果）； 使用初始为 111，每次左移一位的tmp与c进行与运算，找到c的第一个为 111的位，这一位是两个数不同的位，以该位为标准将数组划分为两部分，达到分组目标； 两组分别异或，输出结果。 var singleNumbers = function(nums) { let a = 0, b = 0, c = 0, tmp = 1; for (num of nums) c ^= num; // 一元运算符 ! 的优先级仅次于括号 while (!(c &amp; tmp)) tmp &lt;&lt;= 1; for (num of nums) { if (num &amp; tmp) a ^= num; else b ^= num; } return [a, b]; }; ","link":"https://AriesSK.github.io/post/jianzhi_56_i/"},{"title":"65. 不用加减乘除做加法","content":"知识点 位运算替代加法 假设 aaa、bbb的无进位和为 nnn，进位为 ccc，则普通的加法 s=a+bs = a + bs=a+b 可以转化为 s=n+cs = n + cs=n+c。 题解 位运算 观察 aaa，bbb 的无进位和与进位： a(i) b(i) n(i) c(i + 1) 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 根据上表可以发现无进位和和异或运算规律相同，进位和与运算规律相同（需左移一位），由于加上进位后可能出现新的进位，因此需要一直循环直到进位为 000。 递归： var add = function(a, b) { if (!b) return a; return add(a ^ b, (a &amp; b) &lt;&lt; 1); }; 循环： var add = function(a, b) { while (b) { let c = (a &amp; b) &lt;&lt; 1; a ^= b; // a 始终保存当前和 b = c; // b 始终保存进位 } return a; } ","link":"https://AriesSK.github.io/post/jianzhi_65/"},{"title":"15. 二进制中1的个数","content":"知识点 JavaScript 的位运算 运算符 名称 描述 &amp; 按位与 均为 1 返回 1 | 按位或 有一个为 1 返回1 ^ 按位异或 值不同返回 1 ~ 按位非 反转 &lt;&lt; 左移 左移一位，右边填充 0 &gt;&gt; 有符号右移 右移一位，左边填充符号位的值 &gt;&gt;&gt; 无符号右移 右移一位，左边填充 0 题解 异或 异或 0，常用于判断奇偶，时间复杂度 O(k)O(k)O(k)，kkk 为整数的位数： var hammingWeight = function(n) { let count = 0; for (let i = 0; i &lt; 32; ++i) { // while (n) { if (n &amp; 1) ++count; n &gt;&gt;&gt;= 1; } return count; }; 巧用 n &amp; (n - 1)，时间复杂度 O(logn)O(logn)O(logn)，nnn 的二进制位数为 lognlognlogn： n−1n - 1n−1 相对于 nnn，最右边的 111 变为 000，此 111 右侧均变为 000； 因此n &amp; (n - 1)起到的作用就是每次消去最右边的 111。 var hammingWeight = function(n) { let count = 0; while (n) { n &amp;= (n - 1); ++count; } return count; }; ","link":"https://AriesSK.github.io/post/jianzhi_15/"},{"title":"33. 二叉搜索树的后序遍历序列","content":"知识点 树的先序、中序、后序遍历 对于此类题目： 首先要了解其根、左子树、右子树的在数组中的区间划分； 其次根据题意找出对单个区间的操作； 对每个区间递归处理。 题解 法一：递归分治 每判断一个都需要遍历数组区间，时间复杂度 O(n2)O(n^2)O(n2)。 判断是否是二叉搜索树的后序遍历： 首先在数组区间中的最后一个节点是该树（子树）的根节点； 随后根据根节点判断数组剩余是否分成了小于根节点和大于根节点两部分，并且小于部分位于大于部分左侧； 递归判断每一子树的正确性。 var verifyPostorder = function(postorder) { return dfs(postorder, 0, postorder.length - 1); function dfs(postorder, l, r) { // 超过叶子节点，返回 true if (l &gt; r) return true; // 从区间左侧开始遍历 let i = l; // 找到第一个大于等于根节点的数，可以保证其左侧是小于部分 while (postorder[i] &lt; postorder[r]) ++i; let m = i; // 判断其及其右侧是否是大于部分 while (postorder[i] &gt; postorder[r]) ++i; return i === r &amp;&amp; dfs(postorder, l, m - 1) &amp;&amp; dfs(postorder, m, r - 1); }; }; 法二：栈 使用栈将遍历过的节点储存起来，当遇到递减的节点时，栈中最底下也是值最小的那个是它的父节点（递增才入栈，递减就出栈至空栈，栈底元素值最接近）。 var verifyPostorder = function(postorder) { const stack = []; // 设置初始根节点，值为无限大，原根节点视作其左节点 let root = Number.MAX_VALUE; // 将`preorder`倒序，入栈遍历的元素 for (let i = postorder.length - 1; i &gt;= 0; --i) { // 遍历发现左子树有元素比根节点大，返回 false if (postorder[i] &gt; root) return false; // 发现递减元素，出栈至空，更新 root while (stack.length &amp;&amp; stack[stack.length - 1] &gt; postorder[i]) root = stack.pop(); stack.push(postorder[i]); } // 遍历完毕，均满足规则，返回 true return true; }; ","link":"https://AriesSK.github.io/post/jianzhi_33/"},{"title":"16. 数组的整数次方","content":"知识点 JavaScript 的位移运算 &gt;&gt; // 有符号位移，右移一位，左边补符号位的值，0 正 1 负 &gt;&gt;&gt; // 无符号位移，右移一位，左边补 0 js 中的向下取整往往可以使用&gt;&gt;来实现： 2 &gt;&gt; 1; // 1 3 &gt;&gt; 1; // 1 -3 &gt;&gt; 1; // -2 本题中需要判断奇偶的操作： if (n % 2) (n - 1) / 2; else n / 2; 可以直接简化成： n &gt;&gt; 1; JavaScript 的整数范围 js 符号整数范围 [−231,231−1][-2^{31}, 2^{31}-1][−231,231−1]，即 [-2147483648, 2147483647]，当值为 2147483648 时超出了有符号整数的范围，js 会自动转换为无符号整数。 无符号整数因为多一位数用来保存值，因此范围更大。 对于正数来说，使用``&gt;&gt;和&gt;&gt;&gt;效果是一致的，由于本题法三中有测试用例会溢出并转为无符号整数，因此需要使用&gt;&gt;&gt;`。 JavaScript 的取余运算 常见的判断奇偶是使用取余运算n % 2，然而用位运算n &amp; 1也可以实现，并且位运算是底层运算，速度较快。 &amp;位运算是在两个数相同位上均为 1 才返回 1，否则返回 0，因此n &amp; 1就能够判断最右一位是否为 1，n &amp; 1返回 1 表示奇数，返回 0 表示偶数。 题解 法一：暴力 一秒能想到的思路，明显会超时，舍弃： var myPow = function(x, n) { let res = 1; if (n &gt;= 0) { while (n--) res *= x; } else { while (n++) res /= x; } return res; }; 法二：快速幂 + 递归 分治思路，每次减半，时间复杂度 O(logn)O(logn)O(logn)，由于递归函数会调用栈空间，因此空间复杂度为 O(logn)O(logn)O(logn)： var myPow = function(x, n) { let tmp = 0; // 存放计算结果，避免重复计算 if (n === 0) return 1; if (n === 1) return x; if (n === -1) return 1 / x; // 不论奇偶均向下取整 奇数多乘一次本身 if (n % 2) { tmp = myPow(x, (n - 1) / 2); // n &gt;&gt; 1 return tmp * tmp * x; } else { tmp = myPow(x, n / 2); // n &gt;&gt; 1 return tmp * tmp; } }; 法三：快速幂 + 迭代 把递归转化为迭代能够降低空间复杂度为 O(1)O(1)O(1)： var myPow = function(x, n) { if (x === 0) return 0; let res = 1; if (n &lt; 0) { // 把负次幂转化为正次幂计算 x = 1 / x; n = -n; } while (n) { if (n &amp; 1) res *= x; x *= x; // 这里需要使用无符号位移，因为是超过了有符号范围的正数 n &gt;&gt;&gt;= 1; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_16/"},{"title":"07. 重建二叉树","content":"知识点 JavaScript 的for in的坑 看下面的例子，可以发现for in遍历的属性值是字符串而不是数字： const inorder = [1,2,3]; for (let i = 0; i &lt; inorder.length; ++i) console.log(i, typeof i); // 0 'number', 1 'number', 2 'number' for (const i in inorder) console.log(i, typeof i); // 0 string, 1 string, 2 string 题解 ###分治 前序遍历数组： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序； 中序遍历数组： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序； 因此本题思路为：在前序遍历中顺序遍历node作为根节点，在中序遍历中根据node将数组划分为 [ 左子树 | 根节点 | 右子树 ]。 分治算法： 递推参数： 根节点在前序遍历的索引 rootrootroot、子树在中序遍历的左右边界 leftleftleft和rightrightright； 终止条件： 当 left&gt;rightleft &gt; rightleft&gt;right，代表已经越过叶节点，返回 nullnullnull； 递推工作： 建立根节点 nodenodenode：节点值为 preorder[root]preorder[root]preorder[root]； 划分左右子树：查找根节点在中序遍历 inorderinorderinorder 中的索引 iii； 构建左右子树：左右子树递归处理； 返回值： 回溯返回 nodenodenode，作为上一层递归中根节点的左 / 右子节点。 var buildTree = function(preorder, inorder) { const map = new Map(); for (let i = 0; i &lt; inorder.length; ++i) map.set(inorder[i], i); return dfs(0, 0, inorder.length - 1); // root 是 preorder 中的下标，left 和 right 是 inorder 中的下标 function dfs(root, left, right) { if (left &gt; right) return null; const node = new TreeNode(preorder[root]); // index 表示 preorder 中的根节点在 inorder 中的下标 const index = map.get(preorder[root]); node.left = dfs(root + 1, left, index - 1); // index - left 表示当前节点左子树的长度 node.right = dfs(root + 1 + index - left, index + 1, right); return node; }; }; 一开始想要使用slice()方法把左右数组切出来，发现处理下标会非常麻烦，还是这种只根据下标操作的方法有可行性。 ","link":"https://AriesSK.github.io/post/jianzhi_07/"},{"title":"68 - II. 二叉树的最近公共祖先","content":"知识点 最近公共祖先 最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。 题解 法一：两次遍历 沿用了68 - I. 二叉搜索树的最近公共祖先中的法三思路，存下两个目标节点的访问路径，输出路径中index最大的相同节点： var lowestCommonAncestor = function(root, p, q) { const paths = [], path = []; let res; dfs(root); for (let i = 0;;++i) { if (paths[0][i] !== paths[1][i]) break; res = paths[0][i]; } return res; function dfs(root) { if (!root) return; path.push(root); dfs(root.left); dfs(root.right); if (root === p || root === q) paths.push([...path]); path.pop(); }; }; 法二：递归 若 rootrootroot 是 ppp，qqq 的最近公共祖先 ，则只可能为以下情况之一： ppp 和 qqq 在 rootrootroot 的子树中，且分列 rootrootroot 的左、右子树中（异侧）； p=rootp = rootp=root，且 qqq 在 rootrootroot 的左或右子树中； q=rootq = rootq=root，且 ppp 在 rootrootroot 的左或右子树中； var lowestCommonAncestor = function(root, p, q) { // 越过叶子节点返回 null，找到目标节点返回该节点 if (!root || p === root || q === root) return root; let left = lowestCommonAncestor(root.left, p, q); let right = lowestCommonAncestor(root.right, p, q); // 为空说明 p 和 q 不在这个子树中，返回另一个子树，即使也为空 if (!left) return right; if (!right) return left; // left 和 right 同时非空，说明在异侧，当前节点就是最近公共祖先 return root; }; ","link":"https://AriesSK.github.io/post/jianzhi_68_ii/"},{"title":"68 - I. 二叉搜索树的最近公共祖先","content":"知识点 迭代与递归的空间复杂度 目前来看，迭代的空间复杂度往往优于递归的空间复杂度。 递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度： 每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理相同）， 看递归算法的空间消耗，就是要看调用栈所占用的大小。一次递归结束，调用栈就把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。 题解 法一：迭代 注意审题！本题的树是二叉搜索树，因此判断是否是公共祖先的方法比较简单，只有在一左一右或者其中一个本身是公共祖先的时候成立： 若p.val &gt; root.val &amp;&amp; q.val &gt; root.val，说明公共祖先在root的右子树； 若p.val &lt; root.val &amp;&amp; q.val &lt; root.val，说明公共祖先在root的左子树； 其他情况下root就是所求的公共祖先。 迭代的方法时间复杂度 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1)： var lowestCommonAncestor = function(root, p, q) { while (root) { if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) root = root.right; else if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) root = root.left; else break; } return root; }; 法二：递归 递归的方法时间复杂度 O(n)O(n)O(n)，空间复杂度 O(n)O(n)O(n)： var lowestCommonAncestor = function(root, p, q) { if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q); if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q); return root; }; 法三：两次遍历 还可以两次遍历树找两个目标节点并记录其路径，然后输出两条路径index最大的相同节点（二叉搜索树的遍历）。 ","link":"https://AriesSK.github.io/post/jianzhi_68_i/"},{"title":"64. 求1+2+...+n","content":"知识点 逻辑运算符的短路特性 &amp;&amp;：对于表达式A &amp;&amp; B，如果A为 falsefalsefalse，则整个表达式已经可以被确定为 falsefalsefalse，就不会执行B； ||：对于表达式A || B，如果A为 truetruetrue，则整个表达式已经可以被确定为 truetruetrue，就不会执行B。 题解 逻辑符短路 该题的常规解法有三种：平均计算、迭代和递归。第一种需要乘除法，第二种需要循环，第三种需要判断语句。前两种无法替代，因此需要一种能够替代判断语句用来终止递归的方法，可以使用逻辑运算符的短路特性，将递归出口作为A &amp;&amp; B中的A，函数主体作为B： ar sumNums = function(n) { n &amp;&amp; (n += sumNums(n - 1)); return n; }; ","link":"https://AriesSK.github.io/post/jianzhi_64/"},{"title":"55 - II. 平衡二叉树","content":"知识点 自顶向下与自底向上 目前来看，我感觉在深度优先搜索中，自顶向下的思路比自底向上的思路容易想到，而自底向上的思路往往比自顶向下的思路时间复杂度低，自底向上使用后序遍历，自顶向下使用先序遍历。 题解 法一：先序遍历 + 计算深度（自顶向下） 我的想法是沿用55 - I. 二叉树的深度里的方法，depth()用以计算节点的左右子树的深度，isBalanced()用以遍历所有节点并判断是否平衡，但这种方法在遍历节点时进行了许多的重复计算，时间复杂度O(nlogn)O(nlogn)O(nlogn)： var isBalanced = function(root) { if (!root) return true; // 先处理根节点 再处理左右节点 return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); }; var depth = function(root) { if (!root) return 0; return Math.max(depth(root.left), depth(root.right)) + 1; } 法二：后序遍历 + 剪枝（自底向上） 这道题的最优解法应当延续55 - I. 二叉树的深度的法二，使用后续遍历，自底向上，若判断子树不是平衡树则可以直接剪枝，思路是从叶子节点开始，计算其左右子树的深度，判断其差值的绝对值： 若 abs(depth(root.left)−depth(root.right))&lt;=1abs(depth(root.left) - depth(root.right)) &lt;= 1abs(depth(root.left)−depth(root.right))&lt;=1，返回该树深度 max(depth(root.left),depth(root.right))+1max(depth(root.left), depth(root.right)) + 1max(depth(root.left),depth(root.right))+1 否则返回 -1，并且一直返回至结束递归。 算法复杂度为 O(n)O(n)O(n)： var isBalanced = function(root) { return dfs(root) !== -1; }; var dfs = function(root) { if (!root) return 0; let left = dfs(root.left); if (left === -1) return -1; let right = dfs(root.right); if (right === -1) return -1; return Math.abs(left - right) &lt;= 1 ? Math.max(left, right) + 1 : -1; }; ","link":"https://AriesSK.github.io/post/jianzhi_55_ii/"},{"title":"55 - I. 二叉树的深度","content":"知识点 要掌握 BFS 和 DFS 两种搜索算法的核心思想，结合题目要求，优化自己的代码！ 题解 深度优先遍历 我一开始的想法是自顶向下的，核心思想是遍历每一个叶子节点并记录其深度，取最大值： 使用depth记录当前层的深度，从root开始每向下一层++depth，到达叶子节点后使用max记录深度中更大的那一个； 每返回上一层--depth； 遍历完所有叶子节点，输出最大值。 var maxDepth = function(root) { let max = 0, depth = 0; dfs(root); return max; function dfs(root){ if (!root) return; ++depth; if (!root.left &amp;&amp; !root.right) max = Math.max(max, depth); dfs(root.left); dfs(root.right); --depth; } }; 后来想到一种自底向上的思路来优化代码： 空节点，返回深度 000； 非空节点，返回左右树深度中较大的那个。 自底向上逐步计算，最终返回树的深度： var maxDepth = function(root) { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }; ","link":"https://AriesSK.github.io/post/jianzhi_55_i/"},{"title":"41. 数据流中的中位数","content":"知识点 JavaScript 的堆（优先队列） js 中没有封装好的堆，也不能直接用数组模拟，需要自己封装一个数据结构，下面实现了一个最大堆，最小堆在最大堆的继承基础上实现： class MaxHeap { // 堆顶节点序号为 0 constructor() { this.heap = []; } // 获取父节点：(index - 1 / 2)，向下取整 getParentIndex(index) { return (index - 1) &gt;&gt; 1; } // 获取左节点 getLeftIndex(index) { return index * 2 + 1; } // 获取右节点 getRightIndex(index) { return index * 2 + 2; } // 交换值 swap(index1,index2) { const temp = this.heap[index1]; this.heap[index1] = this.heap[index2]; this.heap[index2] = temp; } // 上移节点 用于插入元素 shiftUp(index) { //到达堆顶就不用上移了 if(index == 0) return; const parentIndex = this.getParentIndex(index); // 最大堆要求父节点比子节点大 if(this.heap[parentIndex] &lt; this.heap[index]) { // 大的值上浮 this.swap(parentIndex,index); // 一直上浮至无法上浮 this.shiftUp(parentIndex); } } //下移节点 用于删除元素 shiftDown(index) { const leftIndex = this.getLeftIndex(index); const rightIndex = this.getRightIndex(index); // 小的值下沉至无法下沉 if(this.heap[leftIndex] &gt; this.heap[index]) { this.swap(leftIndex,index); this.shiftDown(leftIndex); } if(this.heap[rightIndex] &gt; this.heap[index]) { this.swap(rightIndex,index); this.shiftDown(rightIndex); } } //插入节点 插入堆尾 使其上浮 add(value) { this.heap.push(value); this.shiftUp(this.size() - 1); } //删除堆顶元素 移除堆尾节点 将其值给堆顶 使其下沉 pop() { const top = this.heap[0]; if (this.size() === 1) return this.heap.pop(); else { // 在堆只有一个元素的时候不能将堆尾值赋给堆顶，否则会导致没有删除该元素（删了后又新增） this.heap[0] = this.heap.pop(); this.shiftDown(0); } return top; } // 获取堆顶 peek() { return this.heap[0]; } // 获取堆的大小 size() { return this.heap.length; } } class MinHeap extends MaxHeap{ shiftUp(index) { if(index == 0) return; const parentIndex = this.getParentIndex(index); if(this.heap[parentIndex] &gt; this.heap[index]) { this.swap(parentIndex,index); this.shiftUp(parentIndex); } } shiftDown(index) { const leftIndex = this.getLeftIndex(index); const rightIndex = this.getRightIndex(index); if(this.heap[leftIndex] &lt; this.heap[index]) { this.swap(leftIndex,index); this.shiftDown(leftIndex); } if(this.heap[rightIndex] &lt; this.heap[index]) { this.swap(rightIndex,index); this.shiftDown(rightIndex); } } } 题解 堆 对于数据流，要应用堆来一个处理一个的优点，因此这道题建立一个最大堆和一个最小堆，规定： 最小堆保存较大的一半元素； 最大堆保存较小的一半元素； 若元素个数为奇数，最小堆多保存一个元素。 这样设计便可以保证： 元素个数为奇数时，最小堆堆顶是中位数； 元素个数为偶数时，两堆堆顶的平均数是中位数。 而判断元素奇偶的方法是比较两个堆的size()，相同为偶，不同为奇； 为了保证最小堆存较大，最大堆存较小的原则，在插入元素时，若意图插入一个堆，则应当先插入另一个堆，再将其堆顶元素插入目标堆。 var MedianFinder = function() { this.maxHeap = new MaxHeap(); this.minHeap = new MinHeap(); }; /** * @param {number} num * @return {void} */ MedianFinder.prototype.addNum = function(num) { if(this.minHeap.size() !== this.maxHeap.size()) { this.minHeap.add(num); this.maxHeap.add(this.minHeap.pop()); } else { this.maxHeap.add(num); this.minHeap.add(this.maxHeap.pop()); } }; /** * @return {number} */ MedianFinder.prototype.findMedian = function() { return this.minHeap.size() !== this.maxHeap.size() ? this.minHeap.peek() : (this.minHeap.peek() + this.maxHeap.peek()) / 2; }; ","link":"https://AriesSK.github.io/post/jianzhi_41/"},{"title":"40. 最小的k个数","content":"知识点 TopK 问题的两种解法及优劣比较 快速选择 快速选择是基于快速排序思想的方法，关于快速排序请查看45. 把数组排成最小的数。 在解决 TopK 问题时，快速排序需要对整个数组进行 O(nlogn)O(nlogn)O(nlogn) 的排序，事实上我们只需要返回 kkk 个数，并不需要保证其顺序，因此只需要找到某次数组划分后 pivotpivotpivot 是 k+1k + 1k+1，此时返回其左边所有数组即可。 对比快速排序，快速选择每次排序后可以根据 pivotpivotpivot 和 kkk 的大小关系舍弃其中一个区间，因此最终时间复杂度 O(n)O(n)O(n) （n+n2+n4+...++nn=2n−1n + \\frac{n}{2} + \\frac{n}{4} + ... + + \\frac{n}{n} = 2n - 1n+2n​+4n​+...++nn​=2n−1）： var quickSelect = function(nums, l, r, k) { let i = l, j = r, tmp = nums[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) --j; while (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } nums[i] = nums[l]; nums[l] = tmp; // 递归终止条件 注意 slice() 是左闭右开的 if (i === k) return nums.slice(0, k); return i &gt; k ? quickSelect(nums, l, i - 1, k) : quickSelect(nums, i + 1, r, k); } 堆 以前 kkk 小问题为例，思路是用大根堆维护数组的前 kkk 小个数，先将前 kkk 个数插入大根堆，后边的数如果比堆顶小，则弹出堆顶，插入该数，最后返回堆即可，关于 JavaScript 的堆实现，请查看41. 数据流中的中位数。 优劣比较 快速选择相较于堆的优势：快速选择时间复杂度 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1)；堆的时间复杂度 O(nlogk)O(nlogk)O(nlogk)，空间复杂度 O(k)O(k)O(k)，时空复杂度均是快速选择较优； 快速选择相较于堆的劣势： 快速选择需要修改原数组，若不允许修改则需要拷贝数组，增加了空间复杂度； 对于数据流，堆来一个处理一个，最终保存的只是 kkk 大小的堆；而快速选择则需要先保存所有数据再运行算法。因此在处理数据量大的数据流时，使用堆较优。 计数排序 计数排序是一种非基于比较的排序算法，在给定范围的整数排序中，快于任何比较排序算法（牺牲空间换时间），算法复杂度是 O(n+k)O(n + k)O(n+k)，kkk 为整数的范围： 根据待排序数组中数值的范围，申请额外空间； 遍历待排序数组，将其每一个元素的出现次数记录到额外空间对应的元素值处； 遍历额外空间，按顺序与次数输出排序数组。 题解 法一：sort() 最容易想到的思路，排序输出前 kkk 个： var getLeastNumbers = function(arr, k) { arr.sort((a, b) =&gt; a - b); return arr.slice(0, k); }; 法二：快速选择 var getLeastNumbers = function(arr, k) { if (k &gt;= arr.length) return arr; return quickSelect(arr, 0, arr.length - 1, k); }; var quickSelect = function(nums, l, r, k) { // if (l &gt;= r) return; 是快排的递归终止条件，本题不应使用，会导致递归提前结束而出错 let i = l, j = r, tmp = nums[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) --j; while (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } nums[i] = nums[l]; nums[l] = tmp; // 递归终止条件 if (i === k) return nums.slice(0, k); return i &gt; k ? quickSelect(nums, l, i - 1, k) : quickSelect(nums, i + 1, r, k); } 法三：堆 js 需要手写堆的数据结构： var getLeastNumbers = function(arr, k) { let i = 0; const heap = new MaxHeap(), res = []; for (i; i &lt; k; ++i) heap.add(arr[i]); for (i; i &lt; arr.length; ++i) { if (arr[i] &lt; heap.peek()) { heap.pop(); heap.add(arr[i]); } } while (heap.size()) res.push(heap.pop()); return res; }; class MaxHeap{ constructor() { this.heap = []; } getParentIndex(index) { return (index - 1) &gt;&gt; 1; } getLeftIndex(index) { return index * 2 + 1; } getRightIndex(index) { return index * 2 + 2; } swap(index1,index2) { const temp = this.heap[index1]; this.heap[index1] = this.heap[index2]; this.heap[index2] = temp; } shiftUp(index) { if(index == 0) return; const parentIndex = this.getParentIndex(index); if(this.heap[parentIndex] &lt; this.heap[index]) { this.swap(parentIndex,index); this.shiftUp(parentIndex); } } shiftDown(index) { const leftIndex = this.getLeftIndex(index); const rightIndex = this.getRightIndex(index); if(this.heap[leftIndex] &gt; this.heap[index]) { this.swap(leftIndex,index); this.shiftDown(leftIndex); } if(this.heap[rightIndex] &gt; this.heap[index]) { this.swap(rightIndex,index); this.shiftDown(rightIndex); } } add(value) { this.heap.push(value); this.shiftUp(this.heap.length - 1); } pop() { const top = this.heap[0]; if (this.size() === 1) return this.heap.pop(); else{ this.heap[0] = this.heap.pop(); this.shiftDown(0); } return top; } peek() { return this.heap[0]; } size() { return this.heap.length; } } ","link":"https://AriesSK.github.io/post/jianzhi_40/"},{"title":"61. 扑克牌中的顺子","content":"知识点 JavaScript 的自定义sort()函数 sort()支持自定义，输入两个参数 aaa，bbb，计算函数体中表达式（规则）的值： 当值为负数，aaa 排在 bbb 前面，升序排序； 当值为正数，aaa 排在 bbb 后面，降序排序； 当值为 000，顺序不变。 举[45. 把数组排成最小的数]{https://ariessk.github.io/post/jianzhi_45/}为例： // 自定义了排序的规则：如果 a 和 b 的拼接小于 b 和 a 的拼接，则 a 应该排到 b 的前面 nums.sort((a, b) =&gt; (&quot;&quot; + a + b) - (&quot;&quot; + b + a))； 题解 法一：排序 + 哈希 我最先想到的方法： 对数组进行排序，从大到小； 遍历数组将非 0 元素存入Set()，若重复返回 falsefalsefalse，遇到 000 则跳出循环，记下 000 的个数； 从nums[0] - 1开始每轮自建，查看Set()中能否找到对应数字，找到则继续，找不到用 000 替代，同时使 000 的个数自减，若找不到对应数字的同时 000 的个数为 000，则返回 falsefalsefalse，完成遍历返回 truetruetrue。 var isStraight = function(nums) { nums.sort((a, b) =&gt; b - a); let count = 0, num = nums[0] - 1; const set = new Set(); for (const i in nums) { if (!nums[i]) { count = 5 - i; break; } if (!set.has(nums[i])) set.add(nums[i]); else return false; } for (let j = 3; j &gt;= 0; --j) { if (set.has(num--)) continue; if(count) --count; else return false; } return true; }; 法二：哈希 + 遍历 事实上用了Set()就无需排序，本题满足是顺子需要同时满足两个条件： 无重复牌（除大小王）； 最大牌 - 最小牌 &lt; 5。 因此在遍历过程中跳过 000，使用Set()判重，同时记录最大值和最小值即可： var isStraight = function(nums) { const set = new Set(); let min = 13, max = 0; for (const num of nums) { if (!num) continue; max = Math.max(num, max); min = Math.min(num, min); if (set.has(num)) return false; else set.add(num); } return max - min &lt; 5; }; 法三：排序 + 遍历 用了排序就无需Set()： 先对数组执行排序； 判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 nums[i]=nums[i+1]nums[i]=nums[i+1]nums[i] = nums[i + 1]nums[i]=nums[i+1]nums[i]=nums[i+1]nums[i]=nums[i+1] 是否成立来判重； 获取最大值和最小值： 排序后，数组末位元素 nums[4]nums[4]nums[4] 为最大牌；元素 nums[joker]nums[joker]nums[joker] 为最小牌，其中 jokerjokerjoker 为大小王的数量。 var isStraight = function(nums) { let count = 0; nums.sort((a, b) =&gt; a - b); for (let i = 0; i &lt; 4; ++i) { if (!nums[i]) ++count; else if (nums[i] === nums[i + 1]) return false; } return nums[4] - nums[count] &lt; 5; }; ","link":"https://AriesSK.github.io/post/jianzhi_61/"},{"title":"45. 把数组排成最小的数","content":"知识点 快速排序 快速排序一轮需要遍历 nnn 的数，而每一轮理想情况下能将数组等半分割，因此需要 O(log2n)O(log_2n)O(log2​n) 轮，因此平均时间复杂度为 O(nlogn)O(nlogn)O(nlogn)，并且是不稳定的排序算法。 原地快排模板，注意设置中枢在哪侧则另一侧的指针先动： var quickSort = function(nums, l, r) { // 递归的终止条件 if (l &gt;= r) return; // 这里需要声明 tmp，不能在 while 中声明 let i = l, j = r, tmp = nums[i]; // 声明本轮快排的中枢，这样写是为了容易看懂，其实 l 等同于 pivot const pivot = l; while (i &lt; j) { // 从右侧开始找第一个比中枢小的，从左侧开始找第一个比中枢大的，交换 // 需要取等号是为了防止把 pivot 交换出去，只有在一轮遍历结束后才交换 pivot while (i &lt; j &amp;&amp; nums[j] &gt;= nums[pivot]) --j; while (i &lt; j &amp;&amp; nums[i] &lt;= nums[pivot]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } // 上面的交换一直重复至 i === j，此时 i 指向的位置就是中枢最终的位置，交换 nums[i] = nums[pivot]; nums[pivot] = tmp; quickSort(nums, l, i - 1); quickSort(nums, i + 1, r); } 新建数组的快排，利用了新建左右两个数组和连接函数concat()，简单易懂，但需要额外的数组空间： var quickSort = function(nums) { if (nums.length &lt;= 1) return nums; const pivot = nums[0]; let left = [], right = []; for (let i = 1; i &lt; nums.length; ++i) { if (nums[i] &lt;= pivot) left.push(nums[i]); else right.push(nums[i]); } return quickSort(left).concat([pivot], quickSort(right)); } 题解 这道题本质上是一个排序问题，难点就在于其排序判断的规则： 若拼接字符串 x+y&gt;y+xx +y &gt; y + xx+y&gt;y+x，则 xxx 排在 yyy 之后； 反之，则 xxx 排在 yyy 前面； 了解排序规则后，只需要选择一种排序方法对数组进行排序即可。 法一：快速排序 在原地快速排序的基础上修改判定的条件实现： var minNumber = function(nums) { quickSort(nums, 0, nums.length - 1); // 通过 join() 能够把数组元素以特定的分隔符连成一个字符串，这里用 &quot;&quot; 作为分隔符 return nums.join(&quot;&quot;); }; var quickSort = function(nums, l, r) { if (l &gt;= r) return; let i = l, j = r, tmp = nums[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; &quot;&quot; + nums[j] + nums[l] &gt;= &quot;&quot; + nums[l] + nums[j]) --j; while (i &lt; j &amp;&amp; &quot;&quot; + nums[i] + nums[l] &lt;= &quot;&quot; + nums[l] + nums[i]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } nums[i] = nums[l]; nums[l] = tmp; quickSort(nums, l, i - 1); quickSort(nums, i + 1, r); } 法二：sort()函数 通过自定义内置sort()函数实现排序： var minNumber = function(nums) { return nums.sort((a, b) =&gt; { // 如果 a 和 b 的拼接小于 b 和 a 的拼接，则 a 应该排到 b 的前面 if(&quot;&quot; + a + b &lt; &quot;&quot; + b + a){ // 返回结果小于0，a 在 b 的前面 return -1; }else{ // 返回结果大于0，a 在 b 的后面 return 1; } }).join(''); }; 甚至还能一行写完： var minNumber = function(nums) { return nums.sort((a, b) =&gt; (&quot;&quot; + a + b) - (&quot;&quot; + b + a)).join(''); }; ","link":"https://AriesSK.github.io/post/jianzhi_45/"},{"title":"54. 二叉搜索树的第k大节点","content":"知识点 运算符优先级 关于运算符的优先级，见21. 调整数组顺序使奇数位于偶数前面 下面两种的运算结果是一样的，这题中都可以： let k = 1; console.log(!--k); // true k = 1; console.log(!(--k)); // true 不过这样写容易出错，还是老实写： let k = 1; console.log(--k == 0); // true 题解 深度优先搜索 二叉搜索树的中序遍历就是升序数组，本题进行逆向的中序遍历，并且设置isFound标志找到了目标，提前结束递归（题目规定不会有空树的情况）： var kthLargest = function(root, k) { let isFound = false, res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (isFound) return; if (k - 1) --k; else { res = root.val; isFound = true; } dfs(root.left); } }; 后来发现isFound可以省略，当k减到 000 时即代表找到了目标： var kthLargest = function(root, k) { let res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (!k) return; // 先自减再判断是否为 0 if (!--k) res = root.val; dfs(root.left); } }; ","link":"https://AriesSK.github.io/post/jianzhi_54/"},{"title":"36. 二叉搜索树与双向链表","content":"知识点 二叉搜索树（二叉查找树，二叉排序树） 定义： 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。 二叉搜索树（Binary Search Tree, BST）的中序遍历是升序序列。 三种深度优先搜索 前中后指的是root节点在三个节点中的位置 前序遍历： var dfs = function(root) { if (!root) return; console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.left); dfs(root.right); } 中序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.right); } 后序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); dfs(root.right); console.log(root.val); // 操作 root 节点，比如打印其值 } 题解 法一：使用队列 我一开始想到的方法，在中序遍历的同时使用一个队列按顺序保存每一个节点，再按顺序输出节点并连接： var treeToDoublyList = function(root) { if (!root) return root; const list = []; dfs(root); const head = list.shift(); let ptr = head; while(list.length) { ptr.right = list.shift(); ptr.right.left = ptr; ptr = ptr.right; } ptr.right = head; head.left = ptr; return head; function dfs(root) { if (!root) return; dfs(root.left); list.push(root); dfs(root.right); } }; 法二：原地算法 事实上并不需要使用队列保存节点，使用一个``pre和一个curr`指针分别保存上一个节点和当前节点即可： var treeToDoublyList = function(root) { let pre, curr; // 空树 if (!root) return root; dfs(root); // 完成中序遍历后还需将头节点和尾节点连接起来成环 head.left = pre; pre.right = head; return head; function dfs(curr) { if (!curr) return; // 先找到最左侧的叶子节点，是链表的头节点 dfs(curr.left); if (pre) pre.right = curr; else head = curr; curr.left = pre; // 更新 curr pre = curr; dfs(curr.right); } }; ","link":"https://AriesSK.github.io/post/jianzhi_36/"},{"title":"34. 二叉树中和为某一值的路径","content":"知识点 JavaScript 的坑 做这道题的过程中遇到了两个坑，记录一下。 声明全局变量 这道题中我需要在dfs(root, target)中使用path和res，所以一开始在最外层声明了变量，即全局变量，像下面这样： const path = [], res = []; var pathSum = function(root, target) {} var dfs = function(root, target) {} 这样写能够通过 Leetcode 的测试用例，但同样的用例在正式提交时却会报错，这是因为上一次用例运行留下的全局变量并没有被销毁，会使之后的用例运行出错，所以应当将dfs(root, target)设置为局部函数： var pathSum = function(root, target) { const path = [], res = []; function dfs(root, target) {} } 引用值 这道题里的path是引用对象，使用res.push([path])是将这个引用对象放入了res中，而后续path对象改变时，res中的path的会随之改变，输出错误结果，正确处理需要深拷贝path存入res中，需要用到展开运算符...。 res.push([...path]); 对于一级基础数据，展开运算符实现深拷贝； 对于二级及以上的复杂数据，展开运算符实现浅拷贝。 题解 深度优先搜索 这道题需要遍历到叶子节点并且输出所有可能，因此无法剪枝。 使用path保存当前遍历的路径，res保存符合要求的路径，需要注意的是在返回上一层递归的时候需要通过path.pop()将path恢复至上一层节点： var pathSum = function(root, target) { const path = [], res = []; dfs(root, target); return res; // 声明函数 function dfs(root, target) { if (!root) return; path.push(root.val); target -= root.val; // 深拷贝 path 并存入 res if (!root.left &amp;&amp; !root.right &amp;&amp; !target) res.push([...path]); dfs(root.left, target); dfs(root.right, target); // 恢复 path path.pop(); }; }; ","link":"https://AriesSK.github.io/post/jianzhi_34/"},{"title":"13. 机器人的运动范围","content":"知识点 JavaScript 中的函数传值 js 中的所有函数的参数都是按值传递的，这意味着函数外的值会被复制到函数内部的参数中，如果是原始值，就跟原始值变量的复制一样，如果是引用值，就和引用值变量的复制一样。 按值传递参数： 外部的值被复制到函数的一个局部变量中，这两个值相互独立，互不干扰； 按引用传递参数： 外部的值在内存中的位置会被保存到函数的一个局部变量中，意味着对局部变量的修改会反应到函数外部，这在 js 中是不可能的。 原始值的按值传递举例，可以看到传入参数与外部值相互独立，互不干扰： function addOne (num) { num += 1; return num; } let count = 20; let res = addOne(count); // count === 20, res === 30 引用值的按值传递举例，如果是按引用传递，那么在新建obj对象的时候，person应该自动将指针改为指向&quot;Aries&quot;的对象，但事实上并没有。这证明了是按值传递的，传递了引用值，而引用的对象是保存在全局作用域，因此可以通过obj访问引用对象修改属性： function setName(obj) { obj.name = &quot;AriesSK&quot;; obj = new Object(); obj.name = &quot;Aries&quot; return num; } let person = new Object(); setName(person); // person.name === &quot;AriesSK&quot; 题解 法一：深度优先搜索 我的解法： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k, res); }; var dfs = function(visit, i, j, k, res) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &lt; 0 || i &gt;= visit.length || j &lt; 0 || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return res; visit[i][j] = 1; res = dfs(visit, i + 1, j, k, res); res = dfs(visit, i - 1, j, k, res); res = dfs(visit, i, j + 1, k, res); res = dfs(visit, i, j - 1, k, res); return ++res; } dfs 解法的优化，省略了不必要的res，并且由于从 (0,0)(0,0)(0,0) 开始，由图可以看出仅通过向右和向下两个方向即可访问所有可达解： var movingCount = function(m, n, k) { const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k); }; var dfs = function(visit, i, j, k) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if ( i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return 0; visit[i][j] = 1; return 1 + dfs(visit, i + 1, j, k) + dfs(visit, i, j + 1, k); } 法二：广度优先搜索 bfs 需要用到队列和循环，无需递归： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); const queue = []; queue.unshift([0, 0]); while(queue.length &gt; 0) { let temp = queue.pop(); let i = temp[0], j = temp[1], s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) continue; visit[i][j] = 1; ++res; queue.unshift([i + 1, j]); queue.unshift([i, j + 1]); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_13/"},{"title":"12. 矩阵中的路径","content":"知识点 深度优先搜索 通过递归的方式，先朝一个方向搜索到底，再回溯至上个节点，沿另一个方向搜索，一次类推。 剪枝 在搜索过程中遇到该路径不可能与目标匹配成功的情况时，应当立即返回，这叫可行性剪枝。 题解 深度优先搜索 + 剪枝 递归终止条件： 返回 false：索引越界 || 当前矩阵元素与目标不匹配（包括已访问）； 返回true：k === word.length - 1，即word已完全匹配。 递推工作： 标记已访问：将board[i][j]修改为 0，防止重复搜索； 搜索下一元素：朝当前元素上、下、左、右四个方向进行下一层递归，使用||连接代表只需找到一条可行路径，记录结果至res； 还原：将board[i][j]还原至初始值word[k]。 var exist = function(board, word) { for (let i = 0; i &lt; board.length; ++i) { for (let j = 0; j &lt; board[0].length; ++j) { if (dfs(board, word, i, j, 0)) return true; } } return false; }; var dfs = function(board, word, i, j, k) { if (i &gt;= board.length || i &lt; 0 || j &gt; board[0].length || j &lt; 0 || board[i][j] !== word[k]) return false; if (k === word.length - 1) return true; // 标记已访问 board[i][j] = 0; const res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1); // 恢复原数组 board[i][j] = word[k]; return res; } ","link":"https://AriesSK.github.io/post/jianzhi_12/"},{"title":"58 - I. 翻转字符单词顺序","content":"知识点 JavaScript 的正则表达式 语法： /正则表达式主体/修饰符(可选) 修饰符不区分大小写： 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配 方括号用于查找某个范围内的字符： 表达式 描述 [abc] 查找方括号之间的任何字符 [0-9] 查找任何从 0 至 9 的数字 (x|y) 查找任何以 | 分隔的选项 元字符是拥有特殊含义的字符： 元字符 描述 \\d 查找数字 \\s 查找空白字符 \\b 匹配单词边界 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 量词: 量词 描述 n+ 匹配任何包含至少一个 n 的字符串 n* 匹配任何包含零个或多个 n 的字符串 n? 匹配任何包含零个或一个 n 的字符串 JavaScript 的字符串函数 本题中使用的一些字符串函数及它们的时间复杂度： trim() // 去除字符串头尾的空格 O(n) split() // 拆分成数组 O(n) reverse() // 反转数组 O(n) join() // 使用特定分隔符将数组连接成字符串 O(n) 其中需要重点说明split()举例如下： let s = &quot;a b c&quot; s.split() // [&quot;a b c&quot;] // 直接返回数组 s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开 s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素 s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数 题解 法一：字符串函数 首先想到使用tirm()删除头尾空格，split(&quot; &quot;)拆分成数组，从数组末尾开始拼接： var reverseWords = function(s) { const arr = s.trim().split(&quot; &quot;); let res = &quot;&quot;; for (let i = arr.length - 1; i &gt;= 0; --i) { if (arr[i] === &quot;&quot;) continue; res += i ? arr[i] + &quot; &quot; : arr[i]; } return res; }; 事实上使用字符串函数代码可以更加简洁： var reverseWords = function(s) { return s.trim().split(/\\s+/).reverse().join(' '); }; 法二：双指针 var reverseWords = function(s) { s = s.trim(); let left = s.length - 1, right = left; let res = &quot;&quot;; // 保证 left 能够取到 0 while (left &gt;= 0) { // 找到第一个空格 while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left; res += s.substring(left + 1, right + 1) + &quot; &quot;; // 忽略空格找到第一个字符 while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left; right = left; } // 删去最后末尾多余的一个空格 return res.trim(); }; ","link":"https://AriesSK.github.io/post/jianzhi_58_i/"},{"title":"57. 和为s的两个数字","content":"知识点 JavaScript 的const 在允许的情况下，推荐使用const进行声明，const声明后无法重新赋值，但可以修改其属性值。 题解 双指针的简单应用： var twoSum = function(nums, target) { let left = 0, right = nums.length - 1; const res = []; // 若允许同一个数自己加自己则取 = while (left &lt; right) { // 在值是正数的情况下，改加为减能够有效防止值溢出 if (nums[left] &gt; target - nums[right]) --right; else if (nums[left] &lt; target - nums[right]) ++left; else { res.push(nums[left]); res.push(nums[right]); // 不适用 break 会导致无限循环入栈至溢出 break; } } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_57/"},{"title":"21. 调整数组顺序使奇数位于偶数前面","content":"知识点 JavaScript 中的运算符优先级 在写代码时需要注意运算符的优先级，如下由于!的运算优先级高于%，因此加不加()是两种结果： let num = 2; console.log(!num % 2); // 0 console.log(!(num % 2)); // true 题解 简单的双指针运用： var exchange = function(nums) { let left = 0, right = nums.length - 1; // while 中是否取等号均可 while (left &lt; right) { if (nums[left] % 2) ++left; else if (!(nums[right] % 2)) --right; else { let temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } return nums; }; ","link":"https://AriesSK.github.io/post/jianzhi_21/"},{"title":"52. 两个链表的第一个公共节点","content":"知识点 这题使用的是一种特别的解题思路： 你变成我，走过我走过的路； 我变成你，走过你走过的路； 然后我们便相遇了… 题解 法一：哈希表 链表 AAA 长度 mmm，链表 BBB 长度为 nnn。 看到这题的第一想法是暴力遍历，时间复杂度是 O(m∗n)O(m * n)O(m∗n)， 第二想法是用哈希表，时间复杂度降低为 O(m+n)O(m + n)O(m+n)，但需要 O(m)O(m)O(m) 的空间： var getIntersectionNode = function(headA, headB) { let ptra = headA, ptrb = headB; const set = new Set(); while(ptra) { set.add(ptra); ptra = ptra.next; } while(ptrb) { if (set.has(ptrb)) return ptrb; ptrb = ptrb.next; } return null; }; 法二：双指针 但题目要求时间复杂度降低为 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1) 。 这题用了一种比较特别的思路： 首先假设链表 AAA 有 aaa 个节点，链表 BBB 有 bbb 个节点， 它们的公共节点有 ccc 个，它们的第一个公共节点为 nodecnodecnodec； 设置指针ptra遍历链表 AAA，随后再从 headBheadBheadB 开始遍历，到达 nodecnodecnodec 时遍历长度为 a+(b−c)a + (b - c)a+(b−c)； 设置指针ptrb遍历链表 BBB，随后再从 headAheadAheadA 开始遍历，到达 nodecnodecnodec 时遍历长度为 b+(a−c)b + (a - c)b+(a−c)。 可以发现此时两指针相交于 nodecnodecnodec 并且遍历过的节点总数是相同的，这就为算法的实现提供了条件——每次使ptra和ptrb同时前进一个节点。 两条链表没有公共节点的情况就等同于两条链表的公共节点是链表结尾的 nullnullnull，因此在完成遍历后两指针同时为 nullnullnull 时会返回 nullnullnull： var getIntersectionNode = function(headA, headB) { let ptra = headA, ptrb = headB; while (ptra !== ptrb) { // 注意每一轮循环只因当修改一次指针的值 若这里使用条件语句则应当用 if else ptra = !ptra ? headB : ptra.next; ptrb = !ptrb ? headA : ptrb.next; } return ptra; }; ","link":"https://AriesSK.github.io/post/jianzhi_52/"},{"title":"25. 合并两个排序的链表","content":"知识点 JavaScript 赋值 js 中将原始值赋值给另一个变量时，原始值会被复制到新变量的位置，而这两个值是完全独立，互不干扰的： let num1 = 6; let num2 = num1; js 中将引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来： let obj1 = new Object(); let obj2 = obj1; obj1.name = &quot;AriesSK&quot;; console.log(obj2.name); // AriesSK 题解 法一：双指针 + 迭代 头指针的应用，注意在比较过程中newHead也会变化，需要使用一个指针res维护它的初值，初始链表为空的情况已经包含在内，不需要另外考虑： var mergeTwoLists = function(l1, l2) { let ptr1 = l1, ptr2 = l2, newHead = new ListNode(); const res = newHead; while (ptr1 &amp;&amp; ptr2) { if (ptr1.val &lt;= ptr2.val) { newHead.next = ptr1; ptr1 = ptr1.next; } else { newHead.next = ptr2; ptr2 = ptr2.next; } newHead = newHead.next; } // 一条为空 接上另一条剩下的 newHead.next = ptr1 ? ptr1 : ptr2; return res.next; }; 法二：递归 空间复杂度 O(n+m)O(n + m)O(n+m)，nnn 和 mmm 分别为两个链表的长度，递归调用函数需要消耗栈空间，栈空间的大小取决于递归调用的深度，这里最多调用 n+mn + mn+m 次： var mergeTwoLists = function(l1, l2) { if (!l1) return l2; else if (!l2) return l1; else if (l1.val &lt;= l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } ","link":"https://AriesSK.github.io/post/jianzhi_25/"},{"title":"22. 链表中的倒数第k个节点","content":"知识点 JavaScript 中 此类题目对头节点并不需要特殊的处理 因此可以不另设头指针。 题解 双指针 两指针减保持 kkk 距离，直到右指针为空时，左指针即为目标节点： var getKthFromEnd = function(head, k) { let left = head, right = left; while (k &gt; 0) { right = right.next; --k; } while (right) { left = left.next; right = right.next; } return left; }; ","link":"https://AriesSK.github.io/post/jianzhi_22/"},{"title":"18. 删除链表的节点","content":"知识点 在链表前设置一个指向头节点的头指针能够使算法不用单独考虑头节点的处理。 题解 双指针 使用 nextnextnext 遍历目标节点，currcurrcurr 记录目标节点的前一节点，以实现断链 推荐设置一个值为 nullnullnull 的头节点（头指针）newHead，能够有效避免删除头节点或链表为空的情况： var deleteNode = function(head, val) { const newHead = new ListNode(); newHead.next = head; let curr = newHead, next = curr.next; while (next) { if (next.val === val) { curr.next = next.next; next.next = null; break; } curr = curr.next; next = next.next; } return newHead.next; }; ","link":"https://AriesSK.github.io/post/jianzhi_18/"},{"title":"48. 最长不含重复字符的子字符串","content":"知识点 JavaScript 的字符串函数 字符串函数的补充说明： slice(start, end) // strat 取到，end 取不到 s = &quot;abcedf&quot; s.slice(-3) // edf s.slice(-3, -1) // ed s.substr(-1) // f s.substr(-3, 2) // ed 逆时针取两位 字符的 ASCII 码范围为 0~127。 题解 法一：动态规划 步骤： 状态定义：设动态规划矩阵 dpdpdp，dp[i]dp[i]dp[i] 代表前 iii 位字符串的最大不重复子串长度； 转移方程：判断以 s[i]s[i]s[i] 结尾的倒数 dp[i−1]dp[i - 1]dp[i−1] 个字符是否是不重复字串，若是，则 dp[i]=dp[i−1]+1dp[i] = dp[i - 1] + 1dp[i]=dp[i−1]+1；否则 dp[i]=dp[i−1]dp[i] = dp[i - 1]dp[i]=dp[i−1]; 初始状态：dp[0]=0dp[0] = 0dp[0]=0，dp[1]=1dp[1] = 1dp[1]=1； 返回结果：dp[n]dp[n]dp[n]。 var lengthOfLongestSubstring = function(s) { let pre = 0, curr = 0; for (let i = 0; i &lt; s.length; ++i) { curr = isRepeat(s.slice(i - pre, i + 1)) ? pre : pre + 1; pre = curr; } return curr; }; var isRepeat = function(s) { let set = new Set(); for (let i of s) { if (set.has(i)) return true; else set.add(i); } return false; }; 上面的方法每遍历一个字符，都需要遍历包含其的一个字串，时间复杂度较高，可以对其加以改进： 状态定义： 设动态规划矩阵 dpdpdp，dp[j]dp[j]dp[j] 代表以 s[j]s[j]s[j] 结尾的最大不重复子串长度； 转移方程： 固定右边界 jjj ，设 s[j]s[j]s[j] 左侧距离最近的相同字符位 s[i]s[i]s[i]。如果 dp[j−1]&lt;j−idp[j - 1] &lt; j - idp[j−1]&lt;j−i ，说明 s[j]s[j]s[j] 使不重复长度变长了一位，dp[j]=dp[j−1]+1dp[j] = dp[j - 1] + 1dp[j]=dp[j−1]+1；否则说明引起了重复，dp[j]=j−idp[j] = j - idp[j]=j−i； dp[i,j]={dp[j−1]+1,dp[j−1]&lt;j−ij−i,dp[j−1]≥j−idp[i, j] = \\begin{cases} dp[j - 1] + 1&amp; {,dp[j - 1] &lt; j - i}\\\\ j - i&amp; {,dp[j - 1] \\geq j - i} \\end{cases} dp[i,j]={dp[j−1]+1j−i​,dp[j−1]&lt;j−i,dp[j−1]≥j−i​ 初始状态： dp[0]=0dp[0] = 0dp[0]=0，dp[1]=1dp[1] = 1dp[1]=1； 返回结果： max(dp)max(dp)max(dp)。 可以通过哈希表记录每个字符最后一次出现的index到达记录i的效果： var lengthOfLongestSubstring = function(s) { let hash = new Map(); let pre = 0, res = 0; for (let j = 0; j &lt; s.length; ++j) { // 哈希表中若没有 s[j] 则设 i 初始为 -1 let i = hash.has(s.charAt(j)) ? hash.get(s.charAt(j)) : -1; hash.set(s.charAt(j), j); pre = pre &lt; j - i ? pre + 1 : j - i; res = Math.max(res, pre); } return res; }; 这种方法的时间复杂度被降低为了 O(n)O(n)O(n)，同时由于字符的 ASCII 码范围为 0~127，因此哈希表的空间复杂度是 O(1)O(1)O(1) 。 法二：滑动窗口 以 (a)bcabcbb 开始的最长不重复子串为 (abc)abcbb； 以 a(b)cabcbb 开始的最长不重复子串为 a(bca)bcbb； 以 ab(c)abcbb 开始的最长不重复子串为 ab(cab)cbb； 以 abc(a)bcbb 开始的最长不重复子串为 abc(abc)bb； 以 abca(b)cbb 开始的最长不重复子串为 abca(bc)bb； 以 abcab(c)bb 开始的最长不重复子串为 abcab(cb)b； 以 abcabc(b)b 开始的最长不重复子串为 abcabc(b)b； 以 abcabcb(b) 开始的最长不重复子串为 abcabcb(b)。 从上面的过程可以看出最长不重复字串的结束位置必然是递增的，因此就可以使用滑动窗口的方法： 使用两个指针表示字符串中的某个子串的左右边界（窗口），左指针代表子串的起始位置，而右指针代表字串的结束位置； 每一次将左指针右移一格，将下一个字符作为起始位置，在保证窗口中没有重复字符的前提下不断右移右指针。在移动结束后，窗口对应以左指针开始的最长不重复子串，记录其长度； 左指针移动到最后一个字符，返回记录长度的最大值。 var lengthOfLongestSubstring = function(s) { let max = 0; for (let left = 0; left &lt; s.length; ++left) { const set = new Set(); for (let right = left; right &lt; s.length; ++right) { // 找到重复字符的情况下 子串的长度为 right - left if (set.has(s.charAt(right))) { max = Math.max(max, right - left); break; } // 需要考虑 right 移至左端仍没有重复节点的情况 此时子串长度为 right - left + 1 else if (right === s.length - 1) max = Math.max(max, right - left + 1); else set.add(s.charAt(right)); } } return max; }; ","link":"https://AriesSK.github.io/post/jianzhi_48/"},{"title":"46. 把数字翻译成字符串","content":"知识点 JavaScript 字符串函数 toString() // 将数字转化为字符串以获取其长度 substr(begin, length) // 返回从下标 begin 开始长度为 length 的字符串 substr() 也可以使用其他两个函数替换: // 两者均是返回 begin 到 end 的字符串 均可以省略第二个参数 表示截取到字符串尾部 slice(begin, end) substring(begin, end) 两者的区别是： substring()会判断两个参数大小，小的作为起始位置，大的作为结束位置，slice()则不会； slice()中的负参数表示从末尾开始计数， 而substring()中负数按 000 处理。 题解 动态规划 这道题的递归思想类似于10 - II. 青蛙跳台阶问题，只不过需要对能否跳进行判断。 所以步骤如下： 状态定义： 设动态规划矩阵 dpdpdp，dp[i]dp[i]dp[i] 代表前 iii 位数字的翻译方案数量； 转移方程： 注意最后两位数除了大于 252525 时无法翻译，小于 101010 也同样无法翻译（无法翻译 000 开头的两位数）。因此： dp[i,j]={dp[i−1]+dp[i−2],10xi−1+xi∈[10,25])dp[i−1],10xi−1+xi∈[0,25)∪(25,99])dp[i, j] = \\begin{cases} dp[i - 1] + dp[i - 2]&amp; {, 10x_{i - 1} + x_i \\in [10, 25])}\\\\ dp[i - 1]&amp; {, 10x_{i - 1} + x_i \\in [0, 25) \\cup (25, 99])} \\end{cases} dp[i,j]={dp[i−1]+dp[i−2]dp[i−1]​,10xi−1​+xi​∈[10,25]),10xi−1​+xi​∈[0,25)∪(25,99])​ 初始状态： dp[0]=1dp[0] = 1dp[0]=1，dp[1]=1dp[1] = 1dp[1]=1； 返回结果： dp[n]dp[n]dp[n]。 var translateNum = function(num) { num = num.toString(); let p = 1, q = 1, r = 1; for (let i = 1; i &lt; num.length; ++i) { r = num.substr(i - 1, 2) &lt;= 25 &amp;&amp; num.substr(i - 1, 2) &gt;= 10 ? p + q : q; p = q; q = r; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_46/"},{"title":"47. 礼物的最大价值","content":"知识点 二维数组的动态规划 如果想要不修改原数组，则需要创建一个二维数组 dp[m,n]dp[m, n]dp[m,n]。 JavaScript 创建二维数组 const m = 4, n = 5; let arr = new Array(m); for (let i = 0; i &lt; n; ++i) arr[i] = new Array(n); 注意在数组为空的时候不能使用for in: let arr = new Array(5); // 数组内的值均是 undefined for (const i in arr) console.log(i); // 无输出 let arr = new Array(5).fill(0); for (const i in arr) console.log(i); // 1, 2, 3, 4, 5 题解 步骤： 状态定义：设动态规划矩阵 dpdpdp，dp(i,j)dp(i, j)dp(i,j) 代表从左上角开始到 (i,j)(i, j)(i,j) 时拿到礼物的最大价值； 转移方程： dp(i,j)={grid(i,j),i=0,j=0grid(i,j)+dp(i,j−1),i=0,j=0grid(i,j)+dp(i−1,j),i=0,j=0grid(i,j)+max[dp(i−1,j),dp(i−1,j)],i=0,j=0dp(i, j) = \\begin{cases} grid(i, j)&amp; {,i = 0, j = 0}\\\\ grid(i, j) + dp(i, j - 1)&amp; {,i = 0, j \\not= 0}\\\\ grid(i, j) + dp(i - 1, j)&amp; {,i \\not= 0, j = 0}\\\\ grid(i, j) + max[dp(i - 1, j), dp(i - 1, j)]&amp; {,i \\not= 0, j \\not= 0} \\end{cases} dp(i,j)=⎩⎪⎪⎪⎨⎪⎪⎪⎧​grid(i,j)grid(i,j)+dp(i,j−1)grid(i,j)+dp(i−1,j)grid(i,j)+max[dp(i−1,j),dp(i−1,j)]​,i=0,j=0,i=0,j​=0,i​=0,j=0,i​=0,j​=0​ 初始状态：dp(0,0)=0dp(0, 0) = 0dp(0,0)=0； 返回结果：dp(m−1)(n−1)dp(m - 1)(n - 1)dp(m−1)(n−1)。 var maxValue = function(grid) { let m = grid.length, n = grid[0].length; for (let i = 0; i &lt; m; ++i) { for (let j = 0; j &lt; n; ++j) { if (i === 0 &amp;&amp; j === 0) continue; if (i === 0) grid[i][j] += grid[i][j - 1]; else if (j === 0) grid[i][j] += grid[i - 1][j]; else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]) } } return grid[m - 1][n - 1]; }; 上面的方法还可以优化，因为当 gridgridgrid 矩阵很大时，i=0i = 0i=0 或 j=0j = 0j=0 的情况仅占极少数，相当循环每轮都冗余了一次判断。可以完成矩阵的第一行和第一列的赋值，再通过循环给剩余的赋值，提高代码运行效率： var maxValue = function(grid) { let m = grid.length, n = grid[0].length; for (let i = 1; i &lt; m; ++i) grid[i][0] += grid[i - 1][0]; for (let j = 1; j &lt; n; ++j) grid[0][j] += grid[0][j - 1]; for (let i = 1; i &lt; m; ++i) for (let j = 1; j &lt; n; ++j) grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]); return grid[m - 1][n - 1]; }; ","link":"https://AriesSK.github.io/post/jianzhi_47/"},{"title":"42. 连续子数组的最大和","content":"知识点 动态规划关键点 ：找到转移方程，用变量记录方程中涉及的状态。 本题关键在于：若前面的累加和为负数，则应当抛弃，从当前数开始累加。 题解 法一：暴力 双重遍历，时间复杂度O(n2)O(n^2)O(n2)： var maxSubArray = function(nums) { let max = nums[0]; for (let i = 0; i &lt; nums.length; ++i) { let sum = 0; for (let j = i; j &lt; nums.length; ++j) { sum += nums[j]; max = Math.max(max, sum); } } return max; }; 法二：动态规划 步骤： 状态定义： 设动态规划列表 dpdpdp，dp[i]dp[i]dp[i] 代表以 nums[i]nums[i]nums[i] 结尾 的连续子数组最大和； 转移方程： 若 dp[i−1]≤0dp[i - 1] \\leq 0dp[i−1]≤0，则 dp[i−1]+nums[i]≤nums[i]dp[i - 1] + nums[i] \\leq nums[i]dp[i−1]+nums[i]≤nums[i] 取 nums[i]nums[i]nums[i]，若 dp[i−1]&gt;0dp[i - 1] &gt; 0dp[i−1]&gt;0，则取 dp[i−1]+nums[i]dp[i - 1] + nums[i]dp[i−1]+nums[i]； 初始状态： max=nums[0max = nums[0max=nums[0]，dp[i−1]=0dp[i - 1] = 0dp[i−1]=0； 返回结果： dpdpdp 的最大值。 使用pre记录 dp[i−1]dp[i - 1]dp[i−1]，curr记录 dp[i]dp[i]dp[i] 的值，max 记录 dpdpdp 中的最大值： var maxSubArray = function(nums) { let max = nums[0], pre = 0; for (num of nums) { let curr = num + Math.max(pre, 0); max = Math.max(max, curr); pre = curr; } return max; }; ","link":"https://AriesSK.github.io/post/jianzhi_42/"},{"title":"63. 股票的最大利润","content":"知识点 动态规划需要解决所有的子问题并且把它们的解记录下来。 题解 法一：暴力 全遍历一遍，时间复杂度 O(n2)O(n^2)O(n2)： var maxProfit = function(prices) { // 设置最低利润为 0 let max = 0; for (let i = 0; i &lt; prices.length - 1; ++i) { for (let j = i + 1; j &lt; prices.length; ++j) { if (max &lt; prices[j] - prices[i]) max = prices[j] - prices[i]; } } return max; }; 法二：动态规划 由于必须得先买后卖，因此花费是到目前为止的最低买入价格。 步骤： 状态定义： 设动态规划列表 dpdpdp，dp[i]dp[i]dp[i] 代表以 prices[i]prices[i]prices[i] 结尾的子数组的最大利润，即前 iii 日的最大利润； 转移方程： dp[i]=max(dp[i−1],prices[i]−min(prices[0:i])dp[i] = max(dp[i - 1], prices[i] - min(prices[0 : i])dp[i]=max(dp[i−1],prices[i]−min(prices[0:i])； 初始状态： dp[0]=0dp[0] = 0dp[0]=0； 返回结果： dp[n−1]dp[n - 1]dp[n−1]， nnn 为列表长度。 var maxProfit = function(prices) { let cost = Number.MAX_VALUE, maxProfit = 0; for (const price of prices) { cost = Math.min(price, cost); // 第 n 天的价格减去目前为止最低的买入价 maxProfit = Math.max(price - cost, maxProfit) } return maxProfit; }; ","link":"https://AriesSK.github.io/post/jianzhi_63/"},{"title":"10 - II. 青蛙跳台阶问题","content":"知识点 类似斐波那契数列的问题，使用动态规划解决，需要注意初始状态的区别。 题解 动态规划 跳上 nnn 级台阶有 F(n)F(n)F(n) 种跳法，在所有跳法中，最后一步只有两种情况： 跳 111 级，有 F(n−1)F(n - 1)F(n−1) 种； 跳 222 级，有 F(n−2)F(n - 2)F(n−2) 种。 所以步骤如下： 状态定义： F(n)F(n)F(n) 表示跳上 nnn 级台阶的跳法总数； 转移方程： F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态： F(0)=1F(0) = 1F(0)=1，F(1)=1F(1) = 1F(1)=1，F(2)=2F(2) = 2F(2)=2； 返回结果： F(n)F(n)F(n)。 var numWays = function(n) { if (n &lt; 2) return 1; let p = 0, q = 1, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % (1e9+7); } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_ii/"},{"title":"10 - I. 斐波那契数列","content":"知识点 动态规划总结 Those who cannot remember the past are condemned to repeat it. 那些不记得过去的人注定要重蹈覆辙。 动态规划(Dynamic Programming, DP) 通过记住求过的解来节省时间，对每一个子问题只求解一次，并将结果存下来。 无后效性： 如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响 最优子结构性质： 大的问题的最优解可以由小问题的最优解推出 判断能否使用 DP 解决： 是否能够将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 步骤： 状态定义： 定义一个状态，这是一个最优解的结构特征； 转移方程： 进行状态递推，得到递推公式； 初始状态： 进行初始化； 返回结果： 返回需要的解。 其中最重要的是状态转移方程。 题解 法一：递归 我第一时间想到的思路，且代码简单，但递归过程中重复的计算过多，导致超出了时间限制，无法通过： var fib = function(n) { if (n === 0) return 0; if (n === 1) return 1; return (fib(n - 1) + fib(n - 2)) % (1e9+7); }; 法二：递归 + 哈希表 法一的优化，将每次计算后的结果存在哈希表中，即可避免重复计算，但需要额外O(n)的空间： var fib = function(n, hash = new Map()) { if (n &lt;= 1) return n; if (hash.has(n)) return hash.get(n); // 注意给 1e9+7 加括号 否则会出错 else hash.set(n, (fib(n - 1, hash) + fib(n - 2, hash)) % (1e9+7)); return hash.get(n); }; 法三：动态规划 状态转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2) 由于只涉及到三个值，因此可以用滚动数组法使得空间复杂度为O(1)： 状态定义：F(n)F(n)F(n) 表示第 nnn 个斐波那契数； 转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态：F(0)=0F(0) = 0F(0)=0，F(1)=1F(1) = 1F(1)=1，F(2)=1F(2) = 1F(2)=1； 返回结果：F(n)F(n)F(n)。 var fib = function(n) { const MOD = 1e9+7; if (n &lt; 2) return n; let p = 0, q = 0, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % MOD; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_i/"},{"title":"28. 对称的二叉树","content":"知识点 深度优先搜索的递归与迭代 dfs 的递归方法修改为迭代方法，常用的方式是引入一个队列来保证处理节点的顺序，同时还需要加入while循环。 JavaScript 树的比较 js 中两个树无法用===比较： // 虽然结构和值都相同，但是是两个不同的树，内存地址不同 let a = new TreeNode(1); let b = new TreeNode(1); a === b; // false 题解 深度优先搜索 递归 递归公式： F(l,r)F(l, r)F(l,r)：表示完成了节点 lll 和 rrr 的对比； F(l,r)=F(l.left,r.right)+F(l.right,r.left)F(l, r) = F(l.left, r.right) + F(l.right, r.left)F(l,r)=F(l.left,r.right)+F(l.right,r.left)。 终止条件： lll 和 rrr 同时为空 表示遍历完成 返回 true； lll 和 rrr 其中一个为空（结构不对称），或者 lll 和 rrr 值不同（值不对称），返回 false。 var isSymmetric = function(root) { return check(root, root); }; var check = function(l, r) { if (!l &amp;&amp; !r) return true; if (!l || !r || l.val !== r.val) return false; return check(l.left, r.right) &amp;&amp; check(l.right, r.left); } 迭代 双端队列，每次左右分别入队，左右分别出队： var isSymmetric = function(root) { const queue = []; queue.unshift(root); queue.push(root); // 这里即使 queue 为空队列也 !== null 不能用 !queue while (queue.length !== 0) { let l = queue.shift(); let r = queue.pop(); if (!l &amp;&amp; !r) continue; if (!l || !r || l.val !== r.val) return false; queue.unshift(l.right); queue.unshift(l.left); queue.push(r.left) queue.push(r.right); } return true; }; 普通队列，每次要比较的一对同时入队与出队： var isSymmetric = function(root) { const queue = []; queue.push(root); queue.push(root); while (queue.length !== 0) { let l = queue.pop(); let r = queue.pop(); if (!l &amp;&amp; !r) continue; if (!l || !r || l.val !== r.val) return false; queue.push(l.left); queue.push(r.right); queue.push(r.left) queue.push(l.right); } return true; }; ","link":"https://AriesSK.github.io/post/jianzhi_28/"},{"title":"27. 二叉树的镜像","content":"知识点 递归公式非常重要！！！ 题解 深度优先搜索 原树操作 递归公式： F(root)F(root)F(root)：完成以root为根节点的树的镜像； F(root)=F(root.left)+F(root.right)F(root) = F(root.left) + F(root.right)F(root)=F(root.left)+F(root.right) + 交换root左右子节点。 终止条件： root为空，即为叶子节点的子节点，返回null。 var mirrorTree = function(root) { if (!root) return null; const left = mirrorTree(root.left); const right = mirrorTree(root.right); root.left = right; root.right = left; return root; }; 复制树 递归公式： F(root)F(root)F(root)：创建新节点并复制root的值 ； F(root)=F(root.left)+F(root.right)F(root) = F(root.left) + F(root.right)F(root)=F(root.left)+F(root.right) + 交换root左右子节点。 终止条件： root为空，即为叶子节点的子节点，返回null。 var mirrorTree = function(root) { if (!root) return null; const newRoot = new TreeNode(root.val); newRoot.left = mirrorTree(root.right); newRoot.right = mirrorTree(root.left); return newRoot; }; ","link":"https://AriesSK.github.io/post/jianzhi_27/"},{"title":"26. 树的子结构","content":"知识点 深度优先遍历 深度优先遍历(DFS) 包括前序、中序、后序三种遍历。 dfs 算法中的前序遍历模板： var dfs = function (node) { // 节点判空必须放在操作前 防止报错 if (!node) return; // 节点为空，返回上一层 console.log(node.val); // 操作根节点 dfs(node.left); // 操作左子树 dfs(node.right); // 操作右子树 } dfs 往往需要使用递归，通常使用递归则不需要使用while循环。 题解 这道题融合了dfs遍历树和判断两树是否相同两道题，是 dfs 的变种，需要嵌套使用两种递归： 首先，遍历 AAA 中的每个节点node； 其次，判断以每个node为根节点的子树是否包含 BBB。 helper() 递归公式 ： F(A,B)F(A, B)F(A,B) ：检查 BBB 为根节点的树是否是 AAA 的子结构 F(A,B)=F(A.left,B.left)+F(A.right,B.right)F(A, B) = F(A.left, B.left) + F(A.right, B.right)F(A,B)=F(A.left,B.left)+F(A.right,B.right) + 检查 AAA, BBB 值和结构是否相同 终止条件： 遍历完 BBB 说明是子结构，return true； AAA 为空而 BBB 非空，说明结构不同，return false； AAA, BBB 的值不同，return false。 isSubStructure()递归公式： F(A,B)F(A, B)F(A,B) ：遍历 AAA 树，同时使用helper()判断 BBB 是否是 AAA 树的子结构； F(A,B)=F(A.left,B)+F(A.right,B)+helper(A,B)F(A, B) = F(A.left, B) + F(A.right, B) + helper(A, B)F(A,B)=F(A.left,B)+F(A.right,B)+helper(A,B)。 终止条件： BBB 是空树，题目给出不是任何树的子结构，return false； 遍历完 AAA，说明没找到 BBB 相同子结构，return false。 var isSubStructure = function(A, B) { if (!A || !B) return false; return helper(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); }; var helper = function(A, B) { if (!B) return true; if (!A || A.val !== B.val) return false; return helper(A.left, B.left) &amp;&amp; helper(A.right, B.right); } 注意 dfs 中判空的操作要放在最前面，不然会出错。比如helper()中的 BBB 判空如果放在判断 AAA, BBB 值是否相同后面，则在 BBB 为空 AAA 不为空的情况下会返回false，但实际上应当返回 true。 ","link":"https://AriesSK.github.io/post/jianzhi_26/"},{"title":"32 - III. 从上到下打印二叉树 III","content":"知识点 JavaScript 的双端队列 js 中的双端队列也是用数组模拟的： 栈： 右进右出，左栈底右栈头； 队列： 右进左出，左队头右队尾。 push() // 队尾入队 unshift(); // 队头入队 题解 深度优先搜索 该题需要判断该层是奇数层还是偶数层： var levelOrder = function(root) { const queue = []; const number = []; if (!root) return number; queue.push(root); while (queue.length) { const count = queue.length; // 在这一步之后 number.length 就等同于当前的层数 number.push([]); for (let i = 0; i &lt; count; ++i) { root = queue.shift(); // 奇数层左到右 偶数层右到左 if (number.length % 2) number[number.length - 1].push(root.val); else number[number.length - 1].unshift(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } } return number; }; 这题判断奇偶的方法有三种，第三种最 smart： // 使用数字记录层数 let tier = 1; ++ tier; // 使用布尔类型记录奇偶 let leftOrder = true; leftOrder = !leftOrder; // 使用 number 的长度奇偶判断，长度即当前层数 if (number.length % 2) // 右到左 else // 左到右 ","link":"https://AriesSK.github.io/post/jianzhi_32_iii/"},{"title":"32 - II. 从上到下打印二叉树 II","content":"知识点 JavaScript 的二维数组 js 中创建二维数组是在一维数组中再添加数组： let array = []; // array = [] 先声明一维数组 array.push([]); // array = [[]] 扩展为二维数组 array.push([]); // array = [[], []] 持续扩展 题解 深度优先搜索 使用双重循环保证每次打印一层： var levelOrder = function(root) { const queue = []; const number = []; if (!root) return number; queue.push(root); while (queue.length) { // 注意这里必须保存队列的长度，因为后面 shift()，push() 均会改变队列的长度 // queue.length 代表了当前层的长度 // 循环中的 const 每次循环会创建新的实例，因此不会报错 const count = queue.length; // 创建二维数组 number.push([]); // 使用 for 循环使每一层的打印在一个 while 循环中完成 for (let i = 0; i &lt; count; ++i) { root = queue.shift(); number[number.length - 1].push(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } } return number; }; ","link":"https://AriesSK.github.io/post/jianzhi_32_ii/"},{"title":"32 - I. 从上到下打印二叉树 I","content":"知识点 广度优先搜索 广度优先搜索(BFS)，也叫层次遍历，是借助队列的先入先出特性(FIFO)实现的。 在 JavaScript 中是用数组来模拟队列的： // 下面四种数组操作均会改变数组的长度 push() // 数组末添加 入队 返回长度 pop() // 数组末弹出 返回弹出元素 unshift() // 数组头添加 返回长度 shift() // 数组头弹出 出队 返回弹出元素 JavaScript 的if表达式 if (a) {} // 只要 a 不为 0, null, undefined, false 均会执行内部操作 题解 深度优先搜索 经典的 Breath First Search： var levelOrder = function(root) { // 数组可以用 const 声明 const queue = []; const number = []; // 空树的特殊情况，不要忘记考虑！ if (!root) return number; queue.push(root); while (queue.length) { // 先弹出后处理 root = queue.shift(); number.push(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } return number; }; ","link":"https://AriesSK.github.io/post/jianzhi_32_i/"},{"title":"50. 第一个只出现一次的字符","content":"知识点 JavaScript 中的for循环 for in，in 指的是数组的下标： var array = [a,b,c,d,e] for (let i in array) { console.log(i); // 0,1,2,3,4 console.log(array[i]); // a,b,c,d,e } for of，of 指的是数组的值： for (let i of array) { console.log(i); // a,b,c,d,e } JavaScript 字符串 Array.from()能够将字符串拆成字符数组。 js 中没有Char只有String，Char是长度为一的String。 js 不能像 java 那样使用单字符相减获得 ASCII 码的差值，因为字符只是单字符的字符串，因此使用一下方法获取 ASCII 码值： 'a'.charCodeAt(0) // 97 题解 应用哈希表，遍历两遍字符串，第一遍存并判断是否只出现一次，第二遍输出： var firstUniqChar = function(s) { let hash = new Map(); for (let i = 0; i &lt; s.length; ++i) { if (!hash.has(s.charAt(i))) hash.set(s.charAt(i), true); else hash.set(s.charAt(i), false); } for (let i = 0; i &lt; s.length; ++i) { if (hash.get(s.charAt(i))) return s.charAt(i); } return ' '; }; // 简单写法 var firstUniqChar = function(s) { let hash = new Map(); let charArray = Array.from(s); for (let c of charArray) { hash.set(c, !hash.has(c)); } for (let c of charArray) { if (hash.get(c)) return c; } return ' '; }; 也可以使用长度26的数组，记录每个字母的出现次数。 ","link":"https://AriesSK.github.io/post/jianzhi_50/"},{"title":"11. 旋转数组的最小数字","content":"知识点 这一题的二分法很特别，因为在numbers[m] = numbers[r]的情况下，无法判断旋转点在哪个半区，因此无法通过常规方法缩小区间，而需要使用--r来缩小区间，而--r的终止条件应当是l === r时，因此本题需要使用模板二，二分法具体模板见53 - I. 在排序数组中查找数字 I。 题解 法一：暴力 找到第一个变小的数字： var minArray = function(numbers) { for (let i = 1; i &lt; numbers.length; ++i) { if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; } // 旋转0个数的情况 return numbers[0]; }; 法二：二分法 要保证每次缩小区间后最小值仍在区间内。 二分会有三种情况： 当 nums[m]&gt;nums[r]nums[m] &gt; nums[r]nums[m]&gt;nums[r] 时： mmm 一定在左排序数组中，即旋转点 xxx 一定在 [m+1,r][m + 1, r][m+1,r] 闭区间内，因此执行 r=m+1r = m + 1r=m+1； 当 nums[m]&lt;nums[r]nums[m] &lt; nums[r]nums[m]&lt;nums[r] 时： mmm 一定在右排序数组中，即旋转点 xxx 一定在 [l,m][l, m][l,m] 闭区间内，因此执行 r=mr = mr=m； 当 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 时： 无法判断 mmm 在哪个排序数组中，即无法判断旋转点 xxx 在 [l,m][l, m][l,m] 还是 [m+1,r][m + 1, r][m+1,r] 区间中，但由于 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 并且 mmm 一定在区间内，因此即使 num[r]num[r]num[r] 是最小值，也可以执行 r=r−1r = r - 1r=r−1 缩小范围。 为什么本题二分法不用 nums[m]nums[m]nums[m] 和 nums[l]nums[l]nums[l] 作比较？ 避免了旋转 000 个数出现的问题。 二分目的是判断 mmm 在哪个排序数组中，从而缩小区间。而在 nums[m]&gt;nums[l]nums[m] &gt; nums[l]nums[m]&gt;nums[l] 情况下，无法判断 mmm 在哪个排序数组中。本质上是由于 rrr 初始值肯定在右排序数组中；但 lll 初始值无法确定在哪个排序数组中。 var minArray = function(numbers) { let l = 0, r = numbers.length; while (l &lt; r) { const m = l + Math.floor((r - l) / 2); if (numbers[m] &gt; numbers[r]) l = m + 1; else if (numbers[m] &lt; numbers[r]) r = m; else --r; } return numbers[l]; }; ","link":"https://AriesSK.github.io/post/jianzhi_11/"},{"title":"04. 二维数组中的查找","content":"知识点 本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。 题解 法一：暴力 注意题目中提示了输入可能是空数组，这种情况需要特别考虑： var findNumberIn2DArray = function(matrix, target) { // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑 if (!matrix.length) return false; let n = matrix.length, m = matrix[0].length; for (let i = 0; i &lt; n; ++i) { for (let j = 0; j &lt; m; ++j) { if (matrix[i][j] === target) return true; } } return false; }; 法二：标志数 将矩阵逆时针旋转 45°，能够发现其结构类似二叉搜索树，左分支更小，右分支更大； 因此从根节点，也就是右上角开始搜索，比target大就向左，否则向右； 矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。 // 右上角开始 var findNumberIn2DArray = function(matrix, target) { if (!matrix.length) return false; let i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &lt; target) ++i; else --j; } return false; }; // 左下角开始 var findNumberIn2DArray = function(matrix, target) { let i = matrix.length - 1, j = 0; // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错 while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &gt; target) --i; else ++j; } return false; }; ","link":"https://AriesSK.github.io/post/jianzhi_04/"},{"title":"53 - II. 0~n-1中缺失的数字","content":"知识点 JavaScript 的排序函数 sort()函数： sort() // 默认按字母升序，40 在 5 前面，是先调用 toString() 再比较 sort(function(a, b){return a - b}) // 按数字升序 sort((a, b) =&gt; a - b) // 按数字升序的简写 sort(function(a, b){return b - a}) // 按数字降序 sort((a, b) =&gt; b - a) // 按数字降序的简写 JavaScript 的箭头函数 // 下面三个等同 var sum = function(a, b) { return a + b; }; var sum = (a, b) =&gt; { return a + b; }; var sum = (a, b) =&gt; a + b; // 一个参数可不用括号 var sum = x =&gt; { retrun x; }; // 没有或多个参数均需要括号 var sum = () =&gt; { return 1; }; 题解 法一：二分法 数组下标与值不同说明已经发生了数字缺失： var missingNumber = function(nums) { let left = 0, right = nums.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === mid) left = mid + 1; else right = mid - 1; } return left; }; 法二：数学 高斯求和公式−目前的和=缺失的数字高斯求和公式 - 目前的和 = 缺失的数字高斯求和公式−目前的和=缺失的数字： var missingNumber = function(nums) { const n = nums.length + 1; let total = Math.floor(n * (n - 1) / 2); let arrSum = 0; for (let i = 0; i &lt; n - 1; i++) { arrSum += nums[i]; } return total - arrSum; }; 法三：暴力 找第一个下标与值不同的位置： var missingNumber = function(nums) { // 如果乱序则先排序 nums.sort((a, b) =&gt; a - b); const n = nums.length + 1; for (let i = 0; i &lt; n - 1; i++) { if (nums[i] !== i) { return i; } } return n - 1; }; ","link":"https://AriesSK.github.io/post/jianzhi_53_ii/"},{"title":"53 - I. 在排序数组中查找数字 I","content":"知识点 二分法总结 有序的序列查找，优先考虑二分法。 无重复元素 查找target在序列中是否出现： const binarySearch(nums, target) { let left = 0, right = nums.length; while (left &lt;= right) { // 能够防止溢出 const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return -1; }; 有重复元素 查找首个大于target的元素序号； 查找首个大于等于target的元素序号（等同于查找首个大于target - 1的元素序号）。 const binarySearch(nums, target) { let left = 0, right = num.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] &lt;= target) left = mid + 1; else right = mid - 1; } return i; } 循环条件写left &lt;= right和left &lt; right的区别 区别在于是否包含最右边的边界值，因为当left==right时，不会再进入循环体，所以right初始化时就取值为len(nums)，这样在for循环中就能保证是在这样一个左闭右开的区间 [left,right)[left,right)[left,right)，且right赋值应该为right = mid而非right = mid-1，因为右半边是开区间，取mid-1就无法验证到mid-1是否是目标值。简单来说区别是right所代表的位置是否参与计算。 两种写法模板 // 模板一 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt;= right 的情况下 right = nums.length - 1 以保证 mid 能够取到 const binarySearch = function(nums, target) { let left = 0, right = nums.length - 1; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return left; } // 模板二 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt; right 的情况下 right = nums.length 因为 mid 最多取到 right - 1 const binarySearch = function(nums, target) { let left = 0, right = nums.length; while (left &lt; right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; } return left; } JavaScript 中的数组越界 js 数组允许越界，越界返回的是undefined。 js 在非严格模式的情况下变量允许不声明直接赋值。 题解 法一：暴力 逐个遍历： var search = function(nums, target) { let start = -1, end = -1; for (let i = 0; i &lt; nums.length; ++i) { if (nums[i] === target) { start = i; break; } } if (start === -1) return 0; // 这里只有在 js 中才行 因为允许数组越界 正常 i = nums.length 时 若nums[i] === target 则 end = nums.length for (let i = start;; ++i) { if (nums[i] !== target) { end = i; break; } } return end - start; }; 法二：二分法 这里的binarySearch()方法目的实际上是寻找tar值能够插入的最右的位置，因此答案为target的右边界减去(target - 1)的右边界。 var search = function(nums, target) { return binarySearch(nums, target) - binarySearch(nums, target - 1); } const binarySearch = function(nums, tar) { let i = 0, j = nums.length - 1; // 用 &lt;= 保证 tar 能够插入最右的位置 而不是 最右的前一位 while (i &lt;= j) { // 不像 java 在 js 中需要手动取整 const m = Math.floor((i + j) / 2); // 由于找最右插入位置 因此即使nums[m] = tar 插入位置也在 m + 1 及之后 if (nums[m] &lt;= tar) i = m + 1; else j = m - 1; } // i 永远比 j 大1 只能返回 i return i; }; // while 中 &lt;= 换为 &lt; 后 改变 j 的初始值 和 j 每次的缩小值 const binarySearch = function(nums, target) { let i = 0, j = nums.length; while (i &lt; j) { const m = i + Math.floor((j - i) / 2); if (nums[m] &lt;= target) i = m + 1; else j = m; } return i; } ","link":"https://AriesSK.github.io/post/jianzhi_53_i/"},{"title":"03. 数组中重复的数字","content":"知识点 JavaScript 中的Map对象与Set对象 Map对象存储键值对，一些常用的方法如下： set(key, value) get(key) has(key) delete(key) Set对象是唯一值的集合，一些常用的方法如下： add(key) clear() // 删除所有 delete(key) entries() keys() values() // 返回值的数组，分别返回键值对、键名、键值，在 Set 中结果相同 has(key) size() Map和Set的 key 可以是任何数据类型。 题解 法一：哈希表 我一开始想到的是使用Map： var findRepeatNumber = function(nums) { let hash = new Map(); for (let i = 0; i &lt; nums.length; ++i) { // 这里需要使用 has()，而不是 get()，防止 get() 取到 0 导致判断出错 if (!hash.has(nums[i])) hash.set(nums[i], i); else return nums[i]; } }; 后来发现Map存储的是键值对，但在这题中只需要存 key，不需要存 value，因此用Set更好： var findRepeatNumber = function(nums) { let set = new Set(); for (let i = 0; i &lt; nums.length; ++i) { if (!set.has(nums[i])) set.add(nums[i]); else return nums[i]; } }; 法二：原地算法 遍历数组nums，设索引初始值为i = 0： 若nums[i] = i：说明此数字已在对应索引位置，无需交换，因此跳过； 若nums[nums[i]] = nums[i]：代表索引nums[i]处和索引i处的元素值都为nums[i]，即找到一组重复值，返回此值nums[i]； 否则：交换索引为i和nums[i]的元素值，将此数字交换至对应索引位置。 若遍历完毕尚未返回，则返回 -1。 var findRepeatNumber = function(nums) { let i = 0; while (i &lt; nums.length) { if (nums[i] === i) { // 直到该位置已放置正确数字再处理下一个位置，以保证数组被完全遍历 ++i; continue; } if (nums[nums[i]] === nums[i]) return nums[i]; let tmp = nums[i]; nums[i] = nums[nums[i]]; // 注意这里 num[i] 已经被修改了值，因此不能用 nums[nums[i]] nums[tmp] = tmp; } return -1; }; ","link":"https://AriesSK.github.io/post/jianzhi_03/"},{"title":"58 - II. 左旋字符串","content":"知识点 JavaScript 的字符串操作函数 charAt(index) // 返回指定索引位置的字符 indexOf() // 返回字符串中检索指定字符第一次出现的位置 replace(searchvalue,newvalue) // 替换第一个子串 replaceAll(searchvalue,newvalue) // 替换所有子串 slice(start, end) // 提取字符串的片段 以新字符串返回 split(separator,limit) // 将字符串分割为子字符串数组 substr(start,length) // 从起始索引号提取字符串中指定数目的字符 substring(start, end) // 提取字符串中两个指定的索引号之间的字符 trim() // 移除字符串首尾空白 题解 substring()： var reverseLeftWords = function(s, n) { return s.substring(n) + s.substring(0, n); }; charAt() + 取余： var reverseLeftWords = function(s, n) { let res = &quot;&quot;; for (let i = 0; i &lt; s.length; ++i) res += s.charAt((i + n) % s.length); return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_58_ii/"},{"title":"05. 替换空格","content":"知识点 JavaScript 中的字符赋值 在 js 中不能直接对字符串中字符赋值： var replaceSpace = function(s) { for (let i = 0; i &lt; s.length; ++i) { if (s[i] === &quot; &quot;) s[i] = &quot;%20&quot;; } return s; }; 正确的做法是使用replace()操作。 题解 不使用字符串方法的解法： var replaceSpace = function(s) { let res = '' for(let i = 0;i &lt; s.length; i++) { if (s[i] === &quot; &quot;) res += &quot;%20&quot;; else res += s[i]; } return res; } 可以使用split()将字符串转化为数组： var replaceSpace = function(s) { arr = s.split(&quot; &quot;); let res = &quot;&quot;; for (let i = 0; i &lt; arr.length; ++i) { if (i === arr.length - 1) res += arr[i]; else res += arr[i] + &quot;%20&quot;; } return res; }; 可以使用字符串的自带函数，注意replace()只替换第一个，而replaceAll()替换全部： var replaceSpace = function(s) { return s.replaceAll(&quot; &quot;, &quot;%20&quot;); }; split()以特定分隔符将字符串拆分为数组，join()则以特定分隔符将数组中元素连接成字符串： var replaceSpace = function(s) { return s.split(&quot; &quot;).join(&quot;%20&quot;); }; ","link":"https://AriesSK.github.io/post/jianzhi_05/"},{"title":"35. 复杂链表的复制","content":"知识点 JavaScript 链表 js 中不提供链表API，是使用对象模拟的，因此解法特殊些。 一个包含三个节点的单链表如下表示（data, next都是对象的属性）： list = { data: 1, next: { data: 2, next: { data: 3, next: null, }, }, }; 题目中的复杂链表实现如下： functuon Node(val, next, random) { this.val = val; this.next = next; this.random = random; } 题解 法一：回溯 + 哈希表 用于将所有b中可枚举属性复制到a中，重名属性则后者覆盖前者： Object.assign(a, b1, b2, ...); 哈希表存值： hashmap.set(key, value); 注意空链表的特殊情况： var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { // 只设置val属性 hash.set(head, {val: head.val}); // 递归复制 next 和 random 属性 Object.assign(hash.get(head), {next: copyRandomList(head.next, hash), random: copyRandomList(head.random, hash)}); } return hash.get(head); }; 也可以在存节点时设置所有的属性，后续递归修改next和random属性的值即可: var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { hash.set(head, {val: head.val, next: head.next, random: head.random}); hash.get(head).next = copyRandomList(head.next, hash); hash.get(head).random = copyRandomList(head.random, hash); } return hash.get(head); }; 法二：迭代 + 节点拆分 先画图后写代码不需要使用哈希表，空间复杂度低： var copyRandomList = function(head) { if (head === null) return null; // 复制节点 for (let node = head; node !== null; node = node.next.next) { const newNode = new Node(node.val, node.next, null); node.next = newNode; } // 复制 random 属性，注意 node.random 指空的情况 for (let node = head; node !== null; node = node.next.next) { const newNode = node.next; newNode.random = (node.random !== null) ? node.random.next : null; } // 创建新的头节点，防止后面断开后找不到新链表的头节点 const newHead = head.next; // 断开新旧链表，注意最后一个节点的 next 指空的情况 for (let node = head; node !== null; node = node.next) { const newNode = node.next; node.next = node.next.next; newNode.next = (newNode.next !== null) ? newNode.next.next : null; } return newHead; }; ","link":"https://AriesSK.github.io/post/jianzhi_35/"},{"title":"24. 反转链表","content":"知识点 递归总结 递归=递归公式+终止条件递归 = 递归公式 + 终止条件递归=递归公式+终止条件 先写出公式，再转换代码。 题解 涉及链表操作的题，建议先把过程画出来，再写成代码。 法一：迭代（双指针） 每次推进一个节点，需要注意提前存next节点，防止断链后找不到后续节点： var reverseList = function(head) { // 从 null 开始 考虑单节点情况 let prev = null; let curr = head; while (curr) { let next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; }; 法二：递归 递归方法需要注意的是递归函数和终止条件： var reverseList = function(head) { // 终止条件： 空链表 或 最后一个节点 if (head == null || head.next == null) return head; // 递归函数：反转 head.next + 处理 head // 反转 head.next let res = reverseList(head.next); // 处理 head，下一个节点指向自己，自己指空 head.next.next = head; head.next = null; return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_24/"},{"title":"06. 从头到尾打印链表","content":"知识点 JavaScript 中的栈 js 中并不存在Stack这个数据结构的API，是使用数组中的两种操作模拟形成的： push() // 向数组末添加元素 pop() // 弹出并返回数组末元素，会改变数组的长度 题解 使用栈倒着打印链表： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.push(ptr.val); ptr = ptr.next; } let number = []; // 下面这行是错误的写法，因为 pop() 改变了 stack.length，导致出错 // for (let i = 0; i &lt; stack.length; ++i) number[i] = stack.pop(); let length = stack.length; for (let i = 0; i &lt; length; ++i) number[i] = stack.pop(); return number; }; 使用unshift()能够直接向数组开头添加元素并返回新长度： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.unshift(ptr.val) ptr = ptr.next; } return stack }; ","link":"https://AriesSK.github.io/post/jianzhi_06/"},{"title":"30. 包含min函数的栈","content":"知识点 JavaScript 的栈 js 中没有栈的API，是使用数组模拟的，因此可以直接通过下标访问栈中任意元素。 题解 利用辅助栈，在主栈与辅助栈同时压入元素。主栈正常，辅助栈比较栈顶与将与将压入元素，选取较小的入栈，保证辅助栈的栈顶元素是就是主栈的 minminmin： var MinStack = function() { this.stack = []; this.min_stack = []; }; /** * @param {number} x * @return {void} */ MinStack.prototype.push = function(x) { this.stack.push(x); // 避免 min_stack 为空时 push 时出错 if (!this.min_stack.length) this.min_stack.push(x); else this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x)); }; /** * @return {void} */ MinStack.prototype.pop = function() { this.stack.pop(); this.min_stack.pop(); }; /** * @return {number} */ MinStack.prototype.top = function() { // java 中 peek() 返回栈顶元素 ，pop()取出并返回栈顶元素 // js 中只有pop() 没有 peek()，访问栈顶元素使用下标 return this.stack[this.stack.length - 1]; }; /** * @return {number} */ MinStack.prototype.min = function() { return this.min_stack[this.min_stack.length - 1]; }; ","link":"https://AriesSK.github.io/post/jianzhi_30/"},{"title":"09. 用两个栈实现队列","content":"知识点 JavaScript 中的prototype js 中使用 prototype 属性给对象的构造函数添加新的属性。 判空 js 中通过长度判空 if(!stack.length) // 如果栈为空 java 中使用isEmpty()判空 题解 使用两个栈实现队列，一个入栈一个出栈，在入栈与出栈中的元素转移时，入栈弹出的是后入元素，应当先压入出栈，从而保证先入先出： // 构造函数 var CQueue = function() { this.inStack = []; this.outStack = []; }; /** * @param {number} value * @return {void} */ // 使用 prototype 给构造函数添加新的属性 // 入队 压入进栈 CQueue.prototype.appendTail = function(value) { this.inStack.push(value); }; /** * @return {number} */ // 出队 CQueue.prototype.deleteHead = function() { if (!this.outStack.length) { // 入栈出栈均为空 队列中没有元素 if (!this.inStack.length) return -1; // 出栈为空 进栈有元素 将进栈元素全部压入出栈 先入先出 while (this.inStack.length) { this.outStack.push(this.inStack.pop()) } } // 出栈有元素 直接弹出 return this.outStack.pop(); }; ","link":"https://AriesSK.github.io/post/jianzhi_09/"}]}