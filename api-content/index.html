{"posts":[{"title":"10 - I. 斐波那契数列","content":"知识点 动态规划总结 Those who cannot remember the past are condemned to repeat it. 那些不记得过去的人注定要重蹈覆辙。 动态规划(Dynamic Programming, DP)通过记住求过的解来节省时间，对每一个子问题只求解一次，并将结果存下来。 无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响 最优子结构性质：大的问题的最优解可以由小问题的最优解推出 判断能否使用 DP 解决：是否能够将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 步骤： 状态定义：定义一个状态，这是一个最优解的结构特征； 转移方程：进行状态递推，得到递推公式； 初始状态：进行初始化； 返回结果。 其中最重要的是状态转移方程。 题解 法一：递归 我第一时间想到的思路，且代码简单，但递归过程中重复的计算过多，导致超出了时间限制，无法通过： var fib = function(n) { if (n === 0) return 0; if (n === 1) return 1; return (fib(n - 1) + fib(n - 2)) % (1e9+7); }; 法二：递归 + 哈希表 法一的优化，将每次计算后的结果存在哈希表中，即可避免重复计算，但需要额外O(n)的空间： var fib = function(n, hash = new Map()) { if (n &lt;= 1) return n; if (hash.has(n)) return hash.get(n); // 注意给 1e9+7 加括号 否则会出错 else hash.set(n, (fib(n - 1, hash) + fib(n - 2, hash)) % (1e9+7)); return hash.get(n); }; 法三：动态规划 状态转移方程：F(n) = F(n - 1) + F(n - 2) 由于只涉及到三个值，因此可以用滚动数组法使得空间复杂度为O(1)： 状态定义：F(n) 表示第 n 个斐波那契数； 转移方程：F(n) = F(n - 1) + F(n - 2)； 初始状态：F(0) = 0; F(1) = 1; F(2) = 1； 返回结果：F(n)。 var fib = function(n) { const MOD = 1e9+7; if (n &lt; 2) return n; let p = 0, q = 0, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % MOD; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_i/"},{"title":"04. 二维数组中的查找","content":"知识点 本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。 题解 法一：暴力 注意题目中提示了输入可能是空数组，这种情况需要特别考虑： var findNumberIn2DArray = function(matrix, target) { // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑 if (!matrix.length) return false; let n = matrix.length, m = matrix[0].length; for (let i = 0; i &lt; n; ++i) { for (let j = 0; j &lt; m; ++j) { if (matrix[i][j] === target) return true; } } return false; }; 法二：标志数 将矩阵逆时针旋转 45°，能够发现其结构类似二叉搜索树，左分支更小，右分支更大； 因此从根节点，也就是右上角开始搜索，比target大就向左，否则向右； 矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。 // 右上角开始 var findNumberIn2DArray = function(matrix, target) { if (!matrix.length) return false; let i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &lt; target) ++i; else --j; } return false; }; // 左下角开始 var findNumberIn2DArray = function(matrix, target) { let i = matrix.length - 1, j = 0; // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错 while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &gt; target) --i; else ++j; } return false; }; ","link":"https://AriesSK.github.io/post/jianzhi_04/"},{"title":"03. 数组中重复的数字","content":"知识点 JavaScript 中的Map对象与Set对象 Map对象存储键值对，一些常用的方法如下： set(key, value) get(key) has(key) delete(key) Set对象是唯一值的集合，一些常用的方法如下： add(key) clear() // 删除所有 delete(key) entries() keys() values() // 返回值的数组，分别返回键值对、键名、键值，在 Set 中结果相同 has(key) size() Map和Set的 key 可以是任何数据类型。 题解 法一：哈希表 我一开始想到的是使用Map： var findRepeatNumber = function(nums) { let hash = new Map(); for (let i = 0; i &lt; nums.length; ++i) { // 这里需要使用 has()，而不是 get()，防止 get() 取到 0 导致判断出错 if (!hash.has(nums[i])) hash.set(nums[i], i); else return nums[i]; } }; 后来发现Map存储的是键值对，但在这题中只需要存 key，不需要存 value，因此用Set更好： var findRepeatNumber = function(nums) { let set = new Set(); for (let i = 0; i &lt; nums.length; ++i) { if (!set.has(nums[i])) set.add(nums[i]); else return nums[i]; } }; 法二：原地算法 遍历数组nums，设索引初始值为i = 0： 若nums[i] = i：说明此数字已在对应索引位置，无需交换，因此跳过； 若nums[nums[i]] = nums[i]：代表索引nums[i]处和索引i处的元素值都为nums[i]，即找到一组重复值，返回此值nums[i]； 否则：交换索引为i和nums[i]的元素值，将此数字交换至对应索引位置。 若遍历完毕尚未返回，则返回 -1。 var findRepeatNumber = function(nums) { let i = 0; while (i &lt; nums.length) { if (nums[i] === i) { // 直到该位置已放置正确数字再处理下一个位置，以保证数组被完全遍历 ++i; continue; } if (nums[nums[i]] === nums[i]) return nums[i]; let tmp = nums[i]; nums[i] = nums[nums[i]]; // 注意这里 num[i] 已经被修改了值，因此不能用 nums[nums[i]] nums[tmp] = tmp; } return -1; }; ","link":"https://AriesSK.github.io/post/jianzhi_03/"},{"title":"05. 替换空格","content":"知识点 JavaScript 中的字符赋值 在 js 中不能直接对字符串中字符赋值： var replaceSpace = function(s) { for (let i = 0; i &lt; s.length; ++i) { if (s[i] === &quot; &quot;) s[i] = &quot;%20&quot;; } return s; }; 正确的做法是使用replace()操作。 题解 不使用字符串方法的解法： var replaceSpace = function(s) { let res = '' for(let i = 0;i &lt; s.length; i++) { if (s[i] === &quot; &quot;) res += &quot;%20&quot;; else res += s[i]; } return res; } 可以使用split()将字符串转化为数组： var replaceSpace = function(s) { arr = s.split(&quot; &quot;); let res = &quot;&quot;; for (let i = 0; i &lt; arr.length; ++i) { if (i === arr.length - 1) res += arr[i]; else res += arr[i] + &quot;%20&quot;; } return res; }; 可以使用字符串的自带函数，注意replace()只替换第一个，而replaceAll()替换全部： var replaceSpace = function(s) { return s.replaceAll(&quot; &quot;, &quot;%20&quot;); }; split()以特定分隔符将字符串拆分为数组，join()则以特定分隔符将数组中元素连接成字符串： var replaceSpace = function(s) { return s.split(&quot; &quot;).join(&quot;%20&quot;); }; ","link":"https://AriesSK.github.io/post/jianzhi_05/"},{"title":"06. 从头到尾打印链表","content":"知识点 JavaScript 中的栈 js 中并不存在Stack这个数据结构的API，是使用数组中的两种操作模拟形成的： push() // 向数组末添加元素 pop() // 弹出并返回数组末元素，会改变数组的长度 题解 使用栈倒着打印链表： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.push(ptr.val); ptr = ptr.next; } let number = []; // 下面这行是错误的写法，因为 pop() 改变了 stack.length，导致出错 // for (let i = 0; i &lt; stack.length; ++i) number[i] = stack.pop(); let length = stack.length; for (let i = 0; i &lt; length; ++i) number[i] = stack.pop(); return number; }; 使用unshift()能够直接向数组开头添加元素并返回新长度： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.unshift(ptr.val) ptr = ptr.next; } return stack }; ","link":"https://AriesSK.github.io/post/jianzhi_06/"},{"title":"09. 用两个栈实现队列","content":"知识点 JavaScript 中的prototype js 中使用 prototype 属性给对象的构造函数添加新的属性。 判空 js 中通过长度判空 if(!stack.length) // 如果栈为空 java 中使用isEmpty()判空 题解 使用两个栈实现队列，一个入栈一个出栈，在入栈与出栈中的元素转移时，入栈弹出的是后入元素，应当先压入出栈，从而保证先入先出： // 构造函数 var CQueue = function() { this.inStack = []; this.outStack = []; }; /** * @param {number} value * @return {void} */ // 使用 prototype 给构造函数添加新的属性 // 入队 压入进栈 CQueue.prototype.appendTail = function(value) { this.inStack.push(value); }; /** * @return {number} */ // 出队 CQueue.prototype.deleteHead = function() { if (!this.outStack.length) { // 入栈出栈均为空 队列中没有元素 if (!this.inStack.length) return -1; // 出栈为空 进栈有元素 将进栈元素全部压入出栈 先入先出 while (this.inStack.length) { this.outStack.push(this.inStack.pop()) } } // 出栈有元素 直接弹出 return this.outStack.pop(); }; ","link":"https://AriesSK.github.io/post/jianzhi_09/"}]}