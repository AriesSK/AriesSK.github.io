{"posts":[{"title":"#每日更新# 知识点导航","content":"JavaScript 知识点 变量 const 声明变量 —— 57. 和为s的两个数字 全局变量的问题 —— 34. 二叉树中和为某一值的路径 函数与方法 函数与方法 —— 59 - II. 队列的最大值 赋值与传值 原始值与引用值 —— 25. 合并两个排序的链表 函数传值 —— 13. 机器人的运动范围 引用对象的问题 —— 34. 二叉树中和为某一值的路径 prototype 通过构造函数的 prototype 原型属性给对象添加新的方法 —— 09. 用两个栈实现队列 this 关键字 this 的指向 —— 59 - II. 队列的最大值 数值 Number 最值 —— 59 - I.滑动窗口的最大值 安全整数 —— 14 - II. 剪绳子 II 判空 通过数组长度判空 —— 09. 用两个栈实现队列 运算符 运算符优先级 —— 21. 调整数组顺序使奇数位于偶数前面 展开运算符 —— 34. 二叉树中和为某一值的路径 逻辑运算符的短路 —— 64. 求1+2+...+n 右移运算符向下取整 按位与取余运算 —— 16. 数组的整数次方 位运算 按位与消去最右的 0 —— 15. 二进制中1的个数 位运算替代加法 —— 65. 不用加减乘除做加法 按位异或找只出现一次的数字 —— 56 - I. 数组中数字出现的次数 I 位运算获取每一位 为每一位赋值 —— 56 - II. 数组中数字出现的次数 II 幂运算 —— 67. 把字符串转换为整数 正则表达式 —— 19. 正则表达式匹配 数组 二维数组创建 赋值 —— 32 - II. 从上到下打印二叉树 II 创建指定大小的二维数组 —— 47. 礼物的最大价值 数字数组赋值 —— 56 - II. 数组中数字出现的次数 II 创建二维数组的问题 —— 29. 顺时针打印矩阵 字符数组的 join —— 38. 字符串的排列 判断数组是否包含某元素 —— 2. 两数相加 栈 数组模拟栈 —— 30. 包含min函数的栈 栈相关的数组操作 —— 06. 从头到尾打印链表 快速判断出栈序列合法 —— 31. 栈的压入、弹出序列 队列 数组模拟队列 —— 32 - I. 从上到下打印二叉树 I 双端队列 —— 32 - III. 从上到下打印二叉树 III 堆 封装堆的数据结构 —— 41. 数据流中的中位数 链表 对象模拟链表 —— 35. 复杂链表的复制 链表删除 —— 19. 删除链表的倒数第 N 个节点 树 对象模拟树 树的比较 —— 28. 对称的二叉树 二叉搜索树 —— 36. 二叉搜索树与双向链表 最近公共祖先 —— 68 - II. 二叉树的最近公共祖先 字符串 字符串中的字符赋值 —— 05. 替换空格 字符串操作函数 —— 58 - II. 左旋字符串 转化为字符数组 获取 ASCII 值 —— 50. 第一个只出现一次的字符 substr slice 与 substring —— 46. 把数字翻译成字符串 slice substr 补充说明 字符 ASCII 范围 —— 48. 最长不含重复字符的子字符串 操作函数的时间复杂度 split 说明 —— 58 - I. 翻转字符单词顺序 判断数字字符 —— 67. 把字符串转换为整数 charAt 越界 —— 14. 最长公共前缀 哈希表 Map 和 Set —— 03. 数组中重复的数字 Map 的 key 和 value —— 39. 数组中出现次数超过一半的数字 排序函数 sort 函数 —— 53 - II. 0~n-1中缺失的数字 自定义 sort 函数 —— 61. 扑克牌中的顺子 箭头函数 箭头函数 —— 53 - II. 0~n-1中缺失的数字 循环遍历 for in 与 for of —— 50. 第一个只出现一次的字符 for in 与 for of 遍历未赋值数组 —— 47. 礼物的最大价值 for in 遍历的属性是字符串 —— 07. 重建二叉树 判断语句 if 判空 —— 32 - I. 从上到下打印二叉树 I 算法知识点 递归与迭代 递归总结 —— 24. 反转链表 迭代与递归的空间复杂度 —— 68 - I. 二叉搜索树的最近公共祖先 双指针 双指针 剪枝 —— 11. 盛水最多的容器 双指针 去重 —— 15. 三数之和 二分法 二分法总结 —— 53 - I. 在排序数组中查找数字 I 广度优先搜索 BFS —— 32 - I. 从上到下打印二叉树 I 层序遍历 保存完整信息 —— 37. 序列化二叉树 深度优先搜索 DFS —— 26. 树的子结构 递归转迭代 —— 28. 对称的二叉树 剪枝 —— 12. 矩阵中的路径 前序 中序 后序遍历 —— 36. 二叉搜索树与双向链表 自顶向下与自底向上 —— 55 - II. 平衡二叉树 前序 中序 后序遍历序列 —— 33. 二叉搜索树的后序遍历序列 字符串排列 —— 17. 电话号码的字母组合 动态规划 动态规划总结 —— 10 - I. 斐波那契数列 二维数组的动态规划 —— 47. 礼物的最大价值 排序 快速排序 —— 45. 把数组排成最小的数 快速选择 计数排序 —— 40. 最小的k个数 归并排序 —— 51. 数组中的逆序对 TopK 问题 TopK 问题两种解法及比较 —— 40. 最小的k个数 超过一半的数 摩尔投票法 —— 39. 数组中出现次数超过一半的数字 剪绳子 两个推论 —— 14 - I.剪绳子 I 滑动窗口 重要性质 —— 57 - II. 和为s的连续正数序列 约瑟夫环 推导 —— 62. 圆圈中最后剩下的数字 有限状态自动机 步骤 —— 20. 表示数值的字符串 思路 —— 8. 字符串转换整数 质数 找质数 丑数 —— 49. 丑数 正推与逆推 两种思路 —— 60. n个骰子的点数 大数 大数处理 —— 17. 打印从1到最大的n位数 大数越界的求余 —— 14 - II. 剪绳子 II 中位数 中位数小技巧 —— 4. 寻找两个正序数组的中位数 回文串 中心扩散法 —— 5. 最长回文子串 模拟 模拟概念 —— 13. 罗马数字转整数 ","link":"https://AriesSK.github.io/post/zhishidian/"},{"title":"Vue","content":"Vue 知识 单向绑定 与 双向绑定 单向绑定：数据改变，页面元素会跟着改变；而页面元素改变，数据不会改变（v-text, v-html, 插值表达式{{}}, v-bind） 双向绑定：页面元素与数据的双向绑定，一方改变另一方也改变（v-model） Vue 的响应式原理 把一个 JS 对象传给 Vue 实例的 data 属性时，Vue 将遍历此对象的所有属性，并且使用 Object.defineProperty 将这些属性转换为 getter/setter Vue 的异步渲染 Vue 实现响应式不是在数据变化后 DOM 立即变化，是按异步策略更新的： 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack） 主线程之外，还存在一个&quot;任务队列&quot;（task queue），只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件 一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行 主线程不断重复上面的第三步 $ 的作用 用于区分 Vue 中自带的实例和用户自定义的属性，有 $ 前缀的是自带的 this Vue 中会定义很多函数或变量，往往需要在 template 或 script 标签中使用： 在 template 中不需要 this 在 script 标签中需要 this（除了在 watch 监听中） Vue 指令 ** v-text 与 v-html** 相同点：均能够展示数据，单向绑定 不同点： v-text 渲染纯文本，浏览器不对其进行 html 解析 v-html 输出 html，浏览器对其进行 html 解析 v-if 与 v-show 相同点：通过变量控制标签内容的显示或隐藏 不同点： v-if 是动态地往 DOM 树中添加或删除元素，在初始条件为假则直接不渲染 DOM（惰性的），在条件切换时会对标签进行适当的创建和销毁 v-show 的本质是给 DOM 节点设置 display: none; 来控制隐藏，不论初始条件真假均会渲染DOM，只在初始化时加载一次 可以看出 v-if 的开销要大于 v-show，因此前者适用于不频繁切换状态的情况，后者则适用于频繁切换的场景 v-for 用于解决模板循环渲染的问题，还可以渲染 Object 对象 &lt;div v-for=&quot;(item, index) in list&quot;&gt;{{index}}{{item}}&lt;/div&gt; &lt;div v-for=&quot;(val, key, index) in listObj&quot;&gt;{{index}}{{item}}&lt;/div&gt; *注意：*v-for 和 v-if 不推荐一起使用，因为处于同一节点时 v-for 的优先级高于 v-if，就会在每一个 v-for 循环中重复运行 v-if，也就意味着即使渲染小部分也要遍历整个数组，造成不必要的计算，影响性能；在 vue3 中 v-if 的优先级高于 v-for 但会导致 v-if 无法访问 v-for 刚定义的变量，因此仍不推荐一起使用 解决方法：使用 computed 属性将需要渲染的列表提前过滤后再给 v-for 渲染 computed: { activeUsers: function () { return this.users.filter( (user)=&gt; { return user.isShow;//返回isShow=true的项，添加到activeUsers数组 }) } } v-on 监听事件，用来监听 DOM 事件来触发一些方法函数，简写 @ &lt;div id='app'&gt; &lt;!-- 鼠标点击事件 --&gt; &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt; &lt;!-- 键盘输入enter --&gt; &lt;input v-model=&quot;username&quot; v-on:keyup.enter=&quot;login&quot; /&gt; &lt;/div&gt; v-bind 用于属性与变量的绑定 &lt;!-- src 属性 imageSrc 变量 --&gt; &lt;img v-bind:src=&quot;imageSrc&quot;&gt; &lt;!-- 简写 --&gt; &lt;img :src=&quot;imageSrc&quot;&gt; v-model 语法糖：计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用 双向绑定，可以结合输入框、复选框、单选框等实现动态地修改数据 v-model 是一个语法糖，本质上包含两个操作： v-bind 绑定一个 value 属性 v-on 给当前元素绑定 input 事件 v-model 的修饰符： v-model.lazy 接管 input 的事件监听事件，在用户输入时不会马上响应在展示层，只有确认改变时才显示 v-model.trim 去除首尾空格 v-model.trim 输入的字符串转化为数字 v-cloak 使用 v-cloak 设置的样式会在 vvue 实例编译完成后从绑定的 html 标签上移除 可以有效防止页面加载的时候出现 vue 的变量名 [v-cloak] { display: none; } &lt;div id=&quot;app&quot; v-cloak&gt; {{msg}} &lt;/div&gt; v-pre 跳过 vue 的编译，直接输出原始值 &lt;!-- 输出 {{msg}} --&gt; &lt;div v-pre&gt;{{msg}}&lt;/div&gt; Vue 全局 API Vue.extend 扩展实例构造器，往往和 $mount 配合使用，创建实例并挂载到元素上 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Vue.extend-扩展实例构造器&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 实现了自定义纯标签的效果 --&gt; &lt;official&gt;&lt;/official&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 定义构造器 var official = Vue.extend({ template:&quot;&lt;p&gt;&lt;a target='_blank' :href='url'&gt;{{name}}&lt;/a&gt;&lt;/p&gt;&quot;, data:function(){ return{ name:'AriesSK的博客', url:'https://ariessk.github.io/' } } }); // 生成实例并挂载到 official DOM 上 new official().$mount('official'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Vue.directive 自定义指令，回调函数有三个参数： el 被绑定的 node 节点 binding 一个对象包含指令的信息 vnode Vue 编译生成的虚拟节点 自定义指令的生命周期函数（钩子函数）： bind 只调用一次，第一次绑定元素被调用，初始化操作 inserted 被绑定元素插入了父节点 update 被绑定的元素模板更新时调用 componentUpdated 被绑定的元素模板完成一次生命周期 unbind 指令和被绑定元素解绑时调用 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Vue.directive 自定义标签&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='app'&gt; &lt;p v-color=&quot;setRed&quot;&gt;我要红&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; window.onload = function () { Vue.directive('color', function(el, binding, vnode){ // 这里的 color 指的是 v-color 的 color，表示指令名 console.log('el', el) // &lt;p style=&quot;color: red;&quot;&gt;我要红&lt;/p&gt; el.style = &quot;color:&quot; + binding.value // binding.value 表示指令绑定的值，这里指 setRed }); new Vue({ el: '#app', // 根据属性绑定 data:{ setRed: 'red' } }) } &lt;/script&gt; &lt;/html&gt; Vue.set 全局操作，Vue 不允许在已创建的实例上动态添加新的根级响应式属性，但可以用 Vue.set 方法将响应式属性添加到嵌套的对象上 下面的例子可以发现，data 的数据是数组或对象时，调用 change 虽然修改了 fruit 的值，但视图并不会更新（失去了getter/setter），而调用 Vue.set(target, key, value) 则会更新视图，说明它能够向响应式对象中添加属性，并确保这个新属性同样是响应式的，且触发视图更新 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Vue.set 全局操作&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='app'&gt; &lt;p v-for=&quot;item in fruit&quot;&gt;{{ item }}&lt;/p&gt; &lt;!-- v-on 的事件处理方法在 Vue 实例内的 methods 声明，也可以在实例外声明函数，前者不用加括号，后者需要 --&gt; &lt;button v-on:click=&quot;change&quot;&gt;变&lt;/button&gt; {{ fruit }} &lt;/div&gt; &lt;!-- onclick 事件不能调用 Vue 实例内的 methods --&gt; &lt;button onclick=&quot;add()&quot;&gt;外部添加&lt;/button&gt; &lt;/body&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function add(){ Vue.set(app.fruit, 1, 'melon'); } var app = new Vue({ el: '#app', data: { fruit: ['apple', 'banana', 'pear', 'grape'] }, methods: { change: function () { this.fruit[1] = 'melon' console.log(this.fruit) // ['apple', 'melon', 'pear', 'grape'] } } }) &lt;/script&gt; &lt;/html&gt; Vue.filter 全局过滤器，注意声明过滤器必须放在声明实例 app 之前，否则不被注入实例中 过滤器可用在插值表达式 {{ message | filter}} 和 v-bind 中 v-bind:msg=&quot;message | filter&quot; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Vue.filter 过滤器&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id='app'&gt; &lt;p&gt;{{ count | sum }}&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.filter(&quot;sum&quot;, function(value) { //声明 sum 过滤器 return value + 4; }); var app = new Vue({ el: '#app', data: { count: 20 }, }) &lt;/script&gt; &lt;/html&gt; Vue.nextTick 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM 应用场景：需要在视图更新之后，基于新的视图进行操作 Vue 生命周期函数 对于单页面开发模式，每个页面都可以理解为一个 Vue 组件，在它们的生命周期中，都有对应的钩子函数： beforeCreate 在组件创建之前 created 在组件创建之后，一般用于初始化一些固定数据 beforeMount 在 DOM 节点渲染之前 mounted 在 DOM 节点渲染完后除法，常通过 ajax 获取服务端的数据 beforeUpdate 数据更新时调用，适用于在更新之前访问现有的 DOM updated DOM 已经更新，执行依赖于 DOM 的操作 activated 被 keep-alive 缓存的组件激活时调用 deactivated 被 keep-alive 缓存的组件停用时调用 beforeDestroy 实例销毁之前调用，这一步实例仍完全可用 destroyed 实例销毁后调用，一般用于销毁页面内创建的 setTimeout 等变量，防止内存泄漏 Vue-Router Vue 官方提供的路由插件 传统页面与单页面跳转的区别 传统页面：传统的开发模式，路由一般是由超链接（a 标签）来控制页面的跳转与切换，每次跳转需要刷新整个页面，体验上不如单页模式 单页面：Vue 的单页面是基于组件和路由的配合，所有的页面都可以视为组件，路由控制访问路径，每一个路径映射一个组件。单页模式中无法使用 a 标签进行路由跳转，因为单页模式本质上就只有一个 index.html 页面。所有的页面组件都放在打包好的 js 文件中，所以要使用 Vue-Router 的路由组件实现跳转 路由模式 Vue-Router 提供了三种路由模式： Hash 模式 History 模式 abstract 模式 Hash 模式 Vue-Router 的默认模式，特点是 URL 始终带着 #，它不会发起对服务端的请求，也不会重加载页面。浏览器的原生方法提供了一个监听事件 hashchange，它能监听到下面的改变： 点击 a 标签改变 URL 地址 浏览器的前进后退行为 通过 window.location 方法改变地址栏 当初始的 html 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架完成加载。由于 hashchange 不会被默认触发，因此需要在 DOMContentLoaded 被触发时执行一次 hashchange 监听方法要执行的函数 HashChange。之后在点击 a 标签改变 URL 地址时会触发 hashchange 事件，获取到 location.hash，执行的 HashChange 函数通过判断 location.hash 的值来匹配相应的组件，简易的实现如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hash 模式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 这两个事件名是确定的，函数名可以改 window.addEventListener('DOMContentLoaded', Load); window.addEventListener('hashchange', HashChange); var routeView = null; function Load() { routeView = document.getElementById('route-view'); HashChange(); } function HashChange() { switch(location.hash) { case '#/page1': routeView.innerHTML = '我是page1'; return; case '#/page2': routeView.innerHTML = '我是page2'; return; default: routeView.innerHTML = '我是page1'; return; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; History 模式 使用 History 模式是使用 html5 的 history API实现路由的模式，表现是去除了 Hash 模式中 URL 的 #，使 URL 比较好看。控制路由会有一些麻烦，根本原因是使用 History 模式，popstate 监听事件无法监听到 pushState、replaceState(前者新建记录，后者修改记录)、a 标签三种形式的变化，可以监听到浏览器的前进和后退。 为了实现路由，可以如下做： 遍历页面上的所有 a 标签，阻止其默认事件，同时加上点击事件的回调函数，在回调函数中获取 a 标签的 href 属性值 通过 pushState 改变浏览器的 location.pathname 属性值为 a 标签的 href 属性值 手动执行 popstate 事件的回调函数，匹配相应的路由 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;History 模式&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.addEventListener('DOMContentLoaded', Load); window.addEventListener('popstate', PopChange); var routeView = null; function Load() { routeView = document.getElementById('route-view'); PopChange(); // 获取所有带有 href 属性的 a 标签 var aList = document.querySelectorAll('a[href]') // 遍历标签，添加点击事件的回调函数，参数 e 代表当前事件 aList.forEach(aNode =&gt; aNode.addEventListener('click', function(e) { // 阻止默认事件 e.preventDefault(); // 获取 href 属性值 var href = aNode.getAttribute('href'); // pushState(state, title. url)，state 对象不需要可填 null，title 表示新页面的标题，url 是新页面的网址 //这个方法的作用就是在 history 对象中添加记录，同时改变地址栏为新的 url history.pushState(null, &quot;&quot;, href); // 因为 popstate 监听不到地址栏的变化，所以需要手动执行 PopChange PopChange(); })); } function PopChange() { switch(location.pathname) { case '/page1' : routeView.innerHTML = '我是page1'; return; case '/page2' : routeView.innerHTML = '我是page2'; return; default : routeView.innerHTML = '我是page1'; return; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; history 模式相对于 hash 模式没有 #，比较符合开发习惯，也比较好看，但由于是 html5 新出的 api，所以不想 hash 模式可以兼容低版本。并且 history 在访问二级页面的时候刷新网页会出现 404 错误，这是因为刷新网页相当于向服务端发送了一次 GET 请求，而服务端并没有定义这样的接口，所以 history 模式需要服务端配合进行路由处理，比如重定向回首页路由 abstract 模式 针对没有浏览器环境的情况，没有浏览器的 API，就会强制切换到 abstract 模式（比如 Weex） 如果在 Vue-Router 的配置项中不填写 mode 的值，则在浏览器环境下默认 Hash 模式，移动客户端环境下使用 abstract 模式 引入与使用 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;!-- 引入静态资源 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Vue Router&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 to 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &lt;a&gt; 标签 --&gt; &lt;router-link to=&quot;/page1&quot;&gt;Go to Page1&lt;/router-link&gt; &lt;br/&gt; &lt;router-link to=&quot;/page2&quot;&gt;Go to Page2&lt;/router-link&gt; &lt;/ul&gt; &lt;!-- 路由匹配到的组件将渲染在&lt;router-view&gt; --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 1. 定义 (路由) 组件 // 可以从其他文件 import 进来，这里简单写 const Page1 = { template: '&lt;div&gt;Page1&lt;/div&gt;' } const Page2 = { template: '&lt;div&gt;Page2&lt;/div&gt;' } // 2. 定义路由 // 每个路由应该映射一个组件，其中 component 可以是通过 Vue.extend() 创建的组件构造器，或者只是一个组件配置对象 const routes = [ { path: '/page1', component: Page1 }, { path: '/page2', component: Page2 } ] // 3. 创建 router 实例，然后传 routes 配置 const router = new VueRouter({ routes: routes }) // 4. 创建和挂载根实例 // 要通过 router 配置参数注入路由，从而让整个应用都有路由功能 const app = new Vue({ router: router }).$mount('#app') &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 获取全局路由跳转参数的变化 同一在入口页面通过 watch $route 对象实现，在上面代码的基础上修改，可以拿到 to 和 from 两个参数，to 代表跳转后的页面参数，from 代表从那个页面跳转来的，通过这两个参数就能够设置一级二级页面，制作过场动画 &lt;script type=&quot;text/javascript&quot;&gt; const app = new Vue({ router: router, watch: { // $ 前缀是让让系统的属性与用户定义的属性区分开来 $route(to, from) { console.log('to', to); console.log('form', from); } } }).$mount('#app') &lt;/script&gt; 路由传参 Page1 跳转到 Page2，Page1通过 传参： &lt;!-- 注意 to 前面需要加 : 即使用了 v-bind --&gt; &lt;router-link :to=&quot;{path: '/page1', query: { id: 123 }}&quot;&gt;Go to Page1&lt;/router-link&gt; 接收参数： const Page1 = { template: '&lt;div&gt;Page1 {{ $route.query.id }}&lt;/div&gt;'} 还有另一种方式： &lt;!-- 注意 to 前面需要加 : 即使用了 v-bind --&gt; &lt;router-link :to=&quot;{path: '/page1/123'}&quot;&gt;Go to Page1&lt;/router-link&gt; // 这里不是 query 而是 params const Page1 = { template: '&lt;div&gt;Page1 {{ $route.params.id }}&lt;/div&gt;'} // 还需要修改 routes const routes = [ { path: 'page1/:id', component: Page1 }, { path: '/page2', component: Page2 } ] 重定向页面 输入一个不存在的路由，Vue-Router 就会无法匹配到，这时候应当默认返回首页，就需要用到重定向匹配，在 * 上面的路径都没被匹配到时，重定向至 /page1 对应的组件 const routes = [ { path: '/page1', component: Page1 }, { path: '/page2', component: Page2 }, {path: '*', redirect: '/page1'} ] Vuex Vuex 是一个专门为 Vue 开发的状态管理模式，集中式存储管理应用的所有组件的状态 是用于管理 Vue 应用跨组件数据的工具 Vuex 与 localStorage、sessionStorage 虽然 localStorage 存储时限长，但比较适合存一些不怎么变化的数据，在 Vue 中不同组件共用的数据，组件需要响应另一个组件对数据的修改，就需要 Vuex Vuex：存储在浏览器内存，集中式存储管理应用的所有组件的状态，不刷新页面则状态会一直保持，刷新网页则状态重置 sessionStorage：会话型存储，用于保存同一窗口或标签页的数据，数据保存在浏览器本地，关闭窗口或标签页后删除数据，就像人之间的会话，人走了会话就结束了 localStorage：持久性存储，与 sessionStorage 类似，不过可以一直存储数据在浏览器本地，直到主动清除或重装浏览器 单向数据流 根据一定规则改变数据，数据触发视图的更新，通过视图中的方法触发数据的更新的闭环 但实际应用中往往有多组件共享状态，这样不同视图的行为需要变更同一个状态，这就破坏了单向数据流 这些复杂的应用场景就需要依靠 Vuex 来解决 虚线框中的部分就是 Vuex 生效的部分，Vue 组件通过 Dispatch 关键字触发 Actions，再通过 Commit 调用 Mutation 里的方法修改 State 数据，组件中如果有依赖 Store 里的数据，就触发 Render 重绘，形成了一个闭环 State 所有状态都被存放在 State 中，类似 Vue 组件中的 data 属性，State 面向整个应用，data 针对单个组件。在 Vue 入口页构造 Vue 实例的时候引入 store，就可以在组件中通过 this.$store.state 拿到 Getter 类似于 Vue 组件中的 computed 属性，计算一些需要二次改造的数据，比如使用 filter 过滤，可以在 store 中定义 getter 属性，state 数据作为参数传入： const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done); }, // 还可以接收其他 getters 作为参数 doneTodesCount: (state, getters) =&gt; { return getters.doneTodos.length; // 1 } } }) 在组件中通过如下访问： this.$store.getters.doneTodos; // [{ id: 1, text: '...', done: true }] Mutation 修改 State 状态需要触发一些方法，这些方法放在 mutations 属性中，mutations 属性中的方法能够接收两个参数，第一个是 state，包含所有的状态值；第二个是提交载荷 Playload，在外部通过 store.commit 方法触发 mutations 时额外带入的值： const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state) { state.count++; } } }) store.commit('increment'); // 无载荷触发 const store = new Vuex.Store({ state: { count: 1 }, mutations: { increment (state, n) { state.count += n; } } }) store.commit('increment', 10); // 带载荷触发 Action 与 Mutation 类似，不过 Action 是提交 mutation 而不是直接修改 State。Action 有异步的能力，能够在请求异步数据后再触发状态的更新： const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state, data) { state.count += data.length; } }, actions: { // 定义一个异步函数，等待 getData 获值后继续执行 commit async increment (ctx) { const data = await getData(); ctx.commit('increment', data); } } }) store.dispatch('increment'); // 分发 Action Module 给状态分模块管理： // 模块 A 的状态及触发更新的方法 const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } // 模块 B 的状态及触发更新的方法 const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } // modules 方法可以将 store 分割成模块，每个模块可以定义自己的 state、getter、mutation、action const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // moduleA 的状态 store.state.b // moduleB 的状态 实例 引入静态资源时，Vuex 要在 Vue 的后面，否则会报错，这是因为 Vuex 内部依赖 Vue 通过 Vuex.Store 生成实例建议使用strict: true严格模式，减少代码紊乱 使用 Mutation 直接修改状态： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.3/vuex.min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Vuex&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{ $store.state.count }}&lt;/div&gt; &lt;button @click=&quot;add&quot;&gt;加1&lt;/button&gt; &lt;button @click=&quot;dec&quot;&gt;减1&lt;/button&gt; &lt;div&gt; &lt;script&gt; const store = new Vuex.Store({ state: { count: 0 }, // 开启严格模式，开启严格模式后，必须通过 mutation 来修改状态。 strict: true, // 触发 state 中的 count 加减运算的方法 mutations: { add(state) { state.count += 1 }, dec(state) { state.count -= 1 } }, getters: { // 过滤偶数的 getter，没用到 filterEven: state =&gt; { return !(state.count % 2) } } }) const app = new Vue({ el: '#app', store, // 将 Vuex 生成的实例作为 Vue 生成实例的参数 data: { message: 'Hello Vue!' }, methods: { add() { this.$store.commit('add') }, dec() { this.$store.commit('dec') } } }).$mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 使用 Action 异步改变状态： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.3/vuex.min.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Vuex&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{ $store.state.count }}&lt;/div&gt; &lt;button @click=&quot;asyncAdd&quot;&gt;异步加1&lt;/button&gt; &lt;button @click=&quot;asyncDec&quot;&gt;异步减1&lt;/button&gt; &lt;div&gt; &lt;script&gt; // 模拟请求数据，延迟 2 秒返回数据 function AsyncData() { // Promise.resolve(x) 用于将字面量或对象封装成 Promise 实例 return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1) }, 2000) }) } const store = new Vuex.Store({ state: { count: 0 }, // 开启严格模式，开启严格模式后,必须通过 mutation 来修改状态 strict: true, mutations: { add(state, num) { state.count += num }, dec(state, num) { state.count -= num } }, actions: { // async await 异步获取 // async 函数返回一个 Promise 对象 // 参数 ctx 是 context 的缩写，代表着上下文 async add(ctx) { // await 是个运算符，await 表达式的结果取决于后面的内容 // 如果后面不是 Promise 对象，则表达式结果就是后面的内容 // 如果后面是 Promise 对象，则阻塞后面的代码，等待 Promise 对象 resolve，得到其值作为表达式的结果 // AsyncData() 返回一个 Promise 对象，因此 await 会等待 const num = await AsyncData() ctx.commit('add', num) }, async dec(ctx) { const num = await AsyncData() ctx.commit('dec', num) } }, getters: { filterOdd: state =&gt; { return !(state.count % 2) } } }) const app = new Vue({ el: '#app', store, data: { message: 'Hello Vue!' }, methods: { asyncAdd() { // 注意使用 Action 调用的是 dispatch this.$store.dispatch('add') }, asyncDec() { this.$store.dispatch('dec') } } }).$mount('#app'); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 不是所有项目都要用 Vuex，对于小型的项目反而会使项目变得繁琐 前端鉴权 前端鉴权，处理用户的鉴权信息的两种方式： cookie cookie 用于存储变量，在前端请求网络资源或者后端接口时，请求头 Header 里都会带上当前域下的 cookie 信息，服务端通过检测请求头内的 cookie 判断当前用户的登录状态是否过期（或者 cookie是否错误），来判断当前用户能否成功地返回响应 token token 是服务器生成的一串随机字符串或 json 串，作为客户端进行资源请求的令牌。调用登录接口后，服务端返回给前端一个 token，之后将 token 存储到本地环境，每次前端请求接口的时候，都需要在请求头里带上 token 信息，并且 token 还可以在服务端设置过期时间，过期后返回前后端商量好的错误码，跳转到登录节点重新鉴权 ","link":"https://AriesSK.github.io/post/vue/"},{"title":"Less","content":"Less 是一门 CSS 预处理语言，扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展，简单来说就是能够提取大量的重复代码，使 CSS 更加规范。 注释 单行 // 多行 /**/ 变量 使用 @ 声明变量，同名变量后面的会覆盖前面的 @primary: red; .box { color: @primary; } 嵌套 CSS 的预编译器嵌套规则大同小异： .a { color: #fff; .b { width: 20px; } } 编译后如下： .a { color: #fff; } .a .b { width: 20px; } 同级场景使用 &amp; 的情况，&amp; 表示当前节点的 CSS 样式，一般用于处理 CSS 样式的状态 hover、focus、active、link、visited等： .a { color: blue; &amp;:hover { color: red; } } 混合（Mixin） Less 的混合有三种情况： 不带参数，调用时可以不加括号，直接使用 .center { text-align: center; } .red { color: red; } .box { .one { .center; .red; } } 带参数，没有默认值，调用需要加括号，并且括号中必须要传值 .center { text-align: center; } .color(@c) { color: @c; } .box { .one { .center; .color(green); } } 带参数，有设置默认值，调用时要加括号，可以不传参数 .center { text-align: center; } .color(@c: red) { color: @c; } .box { .one { .center; .color; } } 运算 + - * / 可以对任何数字、颜色或变量运算，运算前会进行单位的换算，计算结果以最左侧的单位为准，如果单位无效或失去意义则忽略单位 转义字符 Less 的转义字符为 ~&quot;&quot; 比如~&quot;\\&quot; 作用域 现在当前作用域内查询，找不到则继续向上一级查询，类似 js 导入 Less 文件可以使用 @import 引入另一个 Less 文件，并且还可以使用里面的变量，比如@import './style.less' 应用实例 实例一：画四种方向的三角形 可以使用通用匹配模式 @_ 无论同名的哪一个混合被匹配到，都要先执行通用匹配模式的代码 // 通用匹配模式 下面四种方向的三角形都会先执行该代码 .triangle(@_, @width, @color) { width: 0; height: 0; border-style: solid; } .triangle(Bottom, @width, @color) { border-width: @width; border-color: @color transparent transparent transparent; } .triangle(Left, @width, @color) { border-width: @width; border-color: transparent @color transparent transparent; } .triangle(Top, @width, @color) { border-width: @width; border-color: transparent transparent @color transparent; } .triangle(Right, @width, @color) { border-width: @width; border-color: transparent transparent transparent @color; } // 使用左箭头 .box { .triangle(Left, 100px, red); } 这种方式画三角形是利用了 border 可以分别设置四边的属性，当 width 和 height 为 0，整个可见区就由 broder 填满，调整 border-width 可以改变三角形的大小，设置一边的颜色并将另外三边设为透明则可以出现三角形的效果（四分之一的矩形） @arguments 能够替代 mixin 的所有参数 .border(@width, @mode, @color) { border: @arguments; } .one{ .border(1px, solid, red) } 实例二：文字垂直居中 由于将行高 line-height 和 height 设置成相同就能够让标签内的文字垂直居中，因此比较常用，就可以把它封装起来 .line-text-h (@h: 0) { height: @h; line-height: @h; } .box { .text { .line-height-h(100px); background: grey; width: 200px; } } 实例三：定位上下左右居中 绝对定位相对于已定位的父元素，相对定位相对于元素在文档中的初始位置 .center { // 设置绝对定位 position: absolute; // 设置使元素左上顶点位于中心位置 top: 50%; left: 50%; // 向上和向左平移自身一半的高和宽，使元素中心点位于中心位置 transform: translate(-50%, -50%); } ","link":"https://AriesSK.github.io/post/less/"},{"title":"HTML + CSS","content":"操作快捷键 Ctrl + Enter 换行，不改变光标后面代码 Alt + Shift + up/down 在上一行/下一行复制该行 选中词后 Ctrl + D，向下一次选择相同的词 网页 C/S和B/S C/S：Client/Sever B/S：Browser/Sever 网页三要素：结构、表现、行为 结构：HTML用于描述页面的结构 表现：CSS用于控制页面中元素的样式 行为：JavaScript用于响应用户操作 HTML 超文本标记语言（Hypertext Markup Language, HTML) 超文本指的是使用超链接的方法，将不同空间的文字信息组织在一起的网状文本 &lt;!--HTML的注释--&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 标签一般成对出现，单个出现的称为自结束标签 标签的属性 在开始标签或字节数标签中可以设置标签的属性，属性是一个名值对，属性应当根据文档中的规定编写，有些属性没有属性值 &lt;font color=&quot;red&quot;&gt;红色&lt;/font&gt; 文档声明（DOCTYPE） html5的文档声明： &lt;!DOCTYPE html&gt; 二进制与十六进制 二进制作为计算机底层的进制使用，而一般显示二进制数使，会转换为十六进制 字符编码 字符集（charset）是编码和解码所从用的规则 若编码和解码使用的字符集不同，则会出现乱码问题 UTF-8 万国码 开发时使用 &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; 实体 在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格 使用实体（转义字符） &amp;实体的名字; 空格&amp;nbsp; 大于&amp;gt; 小于&amp;lt; 版权符&amp;copy; meta标签 charset 指定网页的字符集 name 指定的数据的名称 content 指定的数据的内容 &lt;!-- title 标签的内容会作为搜索引擎超链接上的文字显示 --&gt; &lt;!-- keywords 表示网站的关键字 搜索时的关键词 --&gt; &lt;meta name=&quot;keywords&quot; content=&quot;HTML5,CSS3&quot;&gt; &lt;!-- description 表示网站的描述 会显示在搜索引擎的搜索结果中 --&gt; &lt;meta name=&quot;description&quot; content=&quot;这是一个网站&quot;&gt; &lt;!-- refresh 将网页重定向到另一个网站 --&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://ariessk.github.io&quot;&gt; ###语义化标签 HTML负责网页的结构 在使用html标签时，应该关注的是标签的语义，而不是样式 块元素 在页面中独占一行的元素称为块元素（block element） 网页布局主要用块元素 块元素内能放块元素和行内元素 但&lt;p&gt;元素内能放块元素 &lt;h1&gt; h1~h6 h1最重要 仅次于title 一般一个页面只有一个h1 一般只会用h1~h3 相关的标题可以放标题组里 &lt;hgroup&gt; &lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;/hgroup&gt; &lt;p&gt;&lt;/p&gt;段落 &lt;blockquote&gt;&lt;/blockquote&gt;表长引用 &lt;br&gt;换行 行内元素 在页面中不会独占一行的元素称为行内元素（inline element） 主要用于包裹元素 &lt;em&gt;&lt;/em&gt;表示语音语调的加重 &lt;strong&gt;&lt;/strong&gt;表强调 &lt;q&gt;&lt;/q&gt;短引用 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; 超链接 浏览器修正 浏览器在解析网页时，会对网页中不符合规范的内容进行修正 标签卸载了根元素&lt;html&gt;外面 网页主体 &lt;body&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt;&lt;/main&gt; &lt;footer&gt;&lt;/footer&gt; &lt;!-- 导航 --&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!-- 与主体相关的内容（侧边栏） --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;!-- 文章--&gt; &lt;article&gt;&lt;/article&gt; &lt;/body&gt; 列表 列表之间可以互相嵌套 无序列表 &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; 有序列表 &lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 定义列表，dt表示定义的内容，dd对内容进行解释说明 &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; 超链接 &lt;a href=&quot;&quot;&gt;&lt;/a&gt;能够嵌套除它自身的任何元素 目标路径可以是外部网站或内部页面 内部页面通常使用相对路径：./表示当前文件所在的目录（可省略），../表示上一级目录 &lt;!-- 当前页面打开与新的页面打开 --&gt; &lt;a href=&quot;&quot; target=&quot;_self&quot;&gt;&lt;/a&gt; &lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; id 属性 通过超链接到页面中的特定位置，要使用 id 属性 id 属性是唯一不重复的，每个标签可以添加一个 id 属性 &lt;!-- 回到顶部 --&gt; &lt;a href=&quot;#&quot;&gt;&lt;/a&gt; &lt;!-- 回到 id 为bottom的标签处 --&gt; &lt;a href=&quot;#bottom&quot;&gt;&lt;/a&gt; &lt;!--未设置是可以用 javascript:; 占位 点击无反应 --&gt; &lt;a href=&quot;javascript:;&quot;&gt;1&lt;/a&gt; 图片标签 用于引入外部图片 &lt;img width=&quot;&quot; height=&quot;&quot; src=&quot;&quot; alt=&quot;&quot;&gt; 自结束标签 替换元素 alt 是图片的描述，有些浏览器会在图片无法加载时显示，搜索引擎会根据 alt 中的内容来识别图片 width height 只修改其中一个会等比例缩小 一般在 pc 端不建议修改图片的大小，而在移动端经常需要缩放图片（主要是大图缩小确保清晰度） 图片格式 jpeg(jpg) 支持颜色比较丰富，不支持透明效果，不支持动图，一般显示照片 gif 支持颜色比较少，支持简单透明，支持动图，一般显示动图 png 支持颜色丰富，支持复杂透明，不支持动图，专为网页而生 webp 谷歌推出的专门用来表示网页中的图片的一种格式，具备其他图片的所有优点，并且文件特别小，但兼容性不好 base64 将图片使用base64编码，将土拍你转换为字符，通过字符的形式来引入图片，一般用于需要和网页一起加载的图片 内联框架 用于向当前页面中引入一个其他页面 &lt;iframe src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; frameborder 指定内联框架的边框，0无1有 音视频 &lt;audio src=&quot;&quot; controls autoplay loop&gt;&lt;/audio&gt;controls 是否允许用户控制播放，autoplay 自动播放，但大部分浏览器不会自动播放，loop循环播放，都是无值的属性 下面这种写法能够解决浏览器不兼容的问题，不支持&lt;audio&gt;则显示文字，第一个音频无法播放则播放第二个&lt;emobed&gt;支持比较低的浏览器版本，需要设置文件类型以及宽和高，且比较丑。 &lt;audio controls&gt; &lt;!-- 文字和 embed 二选一即可 --&gt; 对不起，您的浏览器不支持播放音频，请升级浏览器！ &lt;source src=&quot;audio.mp3&quot;&gt; &lt;source src=&quot;audio.ogg&quot;&gt; &lt;embed src=&quot;&quot; type=&quot;audio/mp3&quot; width=&quot;&quot; height=&quot;&quot;&gt; &lt;/audio&gt; video 与 audio 使用方法基本相同 &lt;video controls&gt; &lt;source src=&quot;video.webm&quot;&gt; &lt;source src=&quot;video.mp4&quot;&gt; &lt;embed src=&quot;&quot; type=&quot;video/mp4&quot; width=&quot;&quot; height=&quot;&quot;&gt; &lt;/video&gt; CSS 层叠样式表 网页实际上是一个多层的结构，通过css可以分别为网页的每一层来设置样式，而最终我们能看到的是最上边的一层 使用 css 修改元素样式 法一：内联样式、行内样式 在标签内部通过 style 属性来设置元素的样式，只能对一个标签生效，修改很麻烦（不推荐使用） &lt;p style=&quot;color: red; font-size: 60px;&quot;&gt; 法二：内部样式表 将样式编写到 head 中的 style 标签里，同时设置多个标签，方便修改和复用，但只能对一个网页使用 &lt;style&gt; p{ color: red; font-size: 60px } &lt;/style&gt; 法三：外部样式表 将样式编写到外部的 css 文件中，然后在页面中通过 link 标签引入外部的 css 文件，方便多网页复用（最佳），多个网页引用同一个 css 时能够使用到浏览器的缓存机制，加块网站加载速度，提高用户体验 p{ color: red; font-size: 60px; } &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;/head&gt; css 语法 选择器，选择页面中的指定元素 声明块，为指定元素设置样式，声明是名值对结构，名和值以 ::: 连接，以 ;;; 结尾 选择器 常用选择器： 元素选择器，根据标签名选定元素，标签名{} id 选择器，根据元素 id 选中元素，#id属性值{} 类选择器，根据元素 class 选中元素，.class值{}，class 和 id 类似，但 class 可重复使用，可以为一个元素指定多个 class，多个 class 之间使用空格分隔 通配选择器，选中页面中的所有元素，*{} 复合选择器： 交集选择器，选中同时复合多个条件的元素，选择器1选择2选择器3{}，有元素选择器则必须以元素选择器开头 选择器分组（并集选择器），同时选择多个选择器对于的元素，选择器1,选择2,选择器3{} 关系选择器： 父元素：直接包含子元素的元素 祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素 兄弟元素：拥有相同父元素的元素 子元素选择器，选中父元素的指定子元素，父元素 &gt; 子元素{} 后代元素选择器，选中祖先元素内的指定后代元素，祖先元素 后代元素{} 兄弟选择器，选择下一个兄弟，前一个 + 后一个{}，需要直接相邻；选择下边所有兄弟，兄 ~ 弟{} 属性选择器： 选择含有指定属性的元素，[属性名]{}，*[属性名]{}表示所有拥有该属性的标签(* 可省略)，标签名[属性名]{}表示拥有该属性的指定标签，比如a[href]{} 选择含有指定属性和属性值的元素，[属性名=属性值]{} 选择属性值以指定值开头的元素，[属性名^=属性值]{} 选择属性值以指定值结尾的元素，[属性名$=属性值]{} 选择属性值中含有指定值的元素，[属性名*=属性值]{} 伪类选择器： 伪类，特殊的类，用来描述一个元素的特殊状态，比如：第一个元素、被点击的元素、鼠标移入的元素 伪类一般用 ::: 开头： :first-child，第一个子元素 :last-child，最后一个子元素 :nth-child()，第 n 个子元素，括号内可填值表示第几个，其中有特殊值：n 表示选中所有（0~正无穷）；2n 或 even 表示选中偶数位的元素；2n+1 或 odd 表示奇数位的元素 上述的伪类均根据所有的子元素进行排序 :first-of-type :last-of-type :nth-of-type() 上述这三个与前面的功能类似，但是是在相同元素中进行排序 :not()，否定选择器，将复合条件的元素从选择器中去除，比如``ul &gt; li:not(:nth-of-type(1)){}`是排除第一个 超链接的伪类： 其执行顺序是 LoVeHAte，原因如下： 未访问的链接（正常的链接），a:link，专属于超链接标签，无操作便具有:link状态 访问过的链接，a:visited，由于隐私的原因，这个伪类只能修改颜色，专属于超链接标签，访问后具备:link和:visited两种状态 鼠标移入的状态，:hover，鼠标移入访问过的链接，同时具备:link、:visited和:hover三种状态 鼠标点击的状态，:active，点击已访问链接未松开，同时具备:link、:visited、:hover和:active四种状态 伪元素选择器： 伪元素，表示页面中一些特殊的不真实存在的元素（特殊的位置），一般用 :::::: 开头： ::first-letter，第一个字母 ::first-line，第一行 ::selection，选中的内容 ::before，表示元素的开始，插入的内容是无法选中的，重要且常用 ::after，表示元素的结束，插入的内容是无法选中的，重要且常用 /* before 和 after 需要结合 content 属性使用才能看出效果 */ /* 下面的例子是在元素的开头插入红色字符串 'abc' */ div::before{ content: 'abc'; color: red; } 选择器的权重 样式的冲突，通过不同的选择器选中了相同的元素，并且为相同的样式设置了不同的值时，就发生了冲突 此时应用哪个样式有选择器的权重（优先级）决定，选择器越具体优先级越高 选择器的权重（数字仅是为了说明数量级）： 内联样式 1,0,0,0 id 选择器 0,1,0,0 类和伪类选择器 0,0,1,0 元素选择器 0,0,0,1 通配选择器 0,0,0,0 继承的样式 没有优先级，即优先级低于通配 比较优先级是，需要将所有选择器的优先级相加后再比较优先级（除了分组选择器是单独计算的），而选择器的累加不会超过其最大的数量级，类选择器再多也不会超过 id 选择器 相同优先级，后面的会覆盖前面的 可以在某一个样式后边添加!important则会获取到最高的优先级（超过内联样式），需要慎用 .class{ background-color: red !important; } 样式的继承 继承发生在祖先与后代之间，为一个元素设置样式同时也会应用到它的后代元素 继承的设计是为了方便开发，利用继承可以将一些通用的样式设置到共同的祖先元素上，这样只需设置一次 并不是所有的样式都会被继承，比如背景相关的，布局相关的样式等 长度单位 像素（px）：不同屏幕的像素大小是不同的 百分比：能够将属性值设置为相对于其父元素属性的百分比，能够使子元素跟随父元素的改变而改变 em：相对于元素的字体大小来计算的，1em = 1font-size，会随着字体的大小改变 rem：相对于根元素的字体大小来计算 颜色单位 颜色名：在 css 中可以直接使用颜色名来设置颜色，但不常用 RGB：通过三种颜色的不同浓度来调配出不同的颜色，每一种范围在 0 - 255(0% - 100%) 之间，是光的三原色，均为 0 则黑，均为 255 则黑 .box{ background-color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); } RGBA：在 RGB 的基础上多了一个透明度 A，1 表示不透明，0 表示全透明，.5 半透明 十六进制的 RGB 值：语法 #RGB，每种颜色用两位十六进制数表示，00 - ff HSL：H 色相(0 - 360)，S 饱和度(0% - 100%)，L 亮度(0% - 100%) HSLA：多一个透明度 布局 文档流 网页是多层结构，最底下的一层称为文档流，是网页的基础，创建的元素默认都在文档流中进行排列 元素主要有两个状态：在文档流中和不在文档流中（脱离文档流） 元素在文档流中的特点： 块元素：在页面中独占一行（自上向下垂直排列）；默认宽度是父元素的全部（把父元素撑满）；默认高度是被内容（子元素）撑开 行内元素：不会独占页面的一行，只占自身的大小；在页面中从左向右排列，如果在一行中不能容纳，则换到第二行；默认宽度和高度都被内容撑开 盒模型 css 将页面中的所有元素都设置为了一个矩形的盒子，盒子的可见框大小由内容区、内边距和边框共同决定 每一个盒子都由以下击鼓部分组成： 内容区(content)： 元素中的所有子元素和文本内容都在内容区中排列，内容区的大小由 width 和 height 两个属性来设置 内边距(padding)，内容区和边框之间的距离，可以用 padding 简写，也可以用 padding-xxx (xxx 可以是 top right bottom left)，内边距的大小会影响到盒子的大小，背景颜色会延伸到内边距上 边框(border)：属于盒子的边缘，需要设置三个样式 边框的宽度(border-width)，可以用来指定四个方向边框的宽度，四个值（上 右 下 左、顺时针），三个值（上 左右 下），两个值（上下 左右），一个值（上下左右）；或者使用 boder-xxx-width 单独指定某一个边框，默认 3px，边框的大小会直接影响盒子的大小 边框的颜色(border-color)，同样可分别以指定四个边的颜色，规则同上，默认黑 边框的样式(border-style)，实线(solid)，点状虚线(dotted)，虚线(dashed)，双线(double)，默认 none 表示没有边框 boder 还有简写属性，同时设置边框的所有相关样式，并且没有顺序要求border: 10px red solid，也可以使用border-xxx分别设置四个边 外边距(margin)，不影响可见框大小，但影响盒子的位置，有四个方向的外边距，可以用 margin 简写，也可以用 margin-xxx 设置（默认情况下设置 margin-right 不会产生效果，一般由浏览器调整），由于元素默认自左向右排列，因此设置左、上外边距会移动元素自身，而设置右、下外边距会移动其他元素。margin 设置负值则反向移动。margin 会影响盒子实际占用空间 盒模型的水平布局 元素在其父元素中水平方向的位置由以下几个属性共同决定：margin-left，border-left，padding-left，width，padding-right，border-right，margin-right 它们的总和必须等于父元素内容区的宽度 如果等式不成立，称为过度约束，等式自动调整： 若七个值没有 auto 的情况，则自动调整 margin-right 使等式成立； 而 width，margin-left，margin-right能够设置 auto，设置后会自动调整该属性，其中 width 的默认值就是 auto； 宽度和一个外边距设置为 auto，宽度会调整到最大值，外边距为 0 三个都设置为 auto，则外边距都是 0，宽度最大 外边距为 auto，宽度固定，则将外边距设计为相同值（常用于在父元素中水平居中） 盒模型的垂直布局 子元素在父元素的内容区中排列，若子元素的大小超过了父元素，则子元素会从父元素中溢出 使用 overflow 属性来设置父元素如何处理溢出的子元素（在父元素中设置），可选值： visible，默认值，使子元素溢出，在父元素外显示 hidden，溢出内容将被裁剪不会显示 scroll，生成两个滚动条，通过滚动条来查看完整的内容 auto，根据需要生成滚动条 overflow-x 和 overflow-y 可以分别设置横向和纵向的溢出 垂直外边距的重叠(折叠) 相邻的垂直方向的外边距会发生重叠现象： 兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大的（都是正或负值），如果一正一副取两者和，对开发有利，不需要处理 父子元素间的相邻垂直外边距，子元素的会传递给父元素（上外边距），会影响到页面的布局，需要进行处理 行内元素的盒模型 行内元素不支持设置宽度和高度 行内元素可以设置 padding，但不会影响页面的布局 行内元素可以设置 border，垂直方向的 border 不会影响页面的布局 行内元素可以设置 margin，垂直方向的 margin 不会影响页面的布局 display 用来设置元素的显示类型，可选值： inline 将元素设置为行元素 block 将元素设置为块元素 inline-block 将元素设置为行内块元素，可以设置宽高又不会独占一行 table 将元素设置为一个表格 none 元素不在页面中显示 visibility 用来设置元素的显示状态，可选值： visible 默认值，元素在页面中正常显示 hidden 元素在也页面中隐藏不显示，但依然占据页面的位置 默认样式 通常情况浏览器都会为元素设置一些默认样式，会影响到页面的布局，因此需要去除浏览器的默认样式（PC端），可以使用别人的重置样式表，引入 css 文件 ","link":"https://AriesSK.github.io/post/html-css/"},{"title":"前端面试","content":"前端基础 HTML h5 新特性 媒体播放 video 和 audio 本地存储 localStorge 和 sessionStorage 语义化标签 header、nav、article、section、footer 历史管理 history API 新增选择器 document.querySelector()、document.querySelectorAll()，可以方便地获取 DOM 元素，前者返回第一个，后者返回所有，参数为字符串类型的 &quot;选择器语法&quot; 拖拽释放 Drag and drop API iframe 内联框架，往网页中引入另一个网页 优点： 把嵌入的网页原封不动展现 可以将网页公用的部分携程一个页面使用 iframe 来嵌套，有利于网页统一风格，增加代码可重用 多网页引用时只需修改 iframe 内容就可以更改调用它的每一个页面 可以解决加载缓慢的第三方内容 缺点： 阻塞主页面的 onload 事件 与主页面共享连接池，会影响页面的并行加载，并且产生的多个页面不容易管理 可能出现上下左右滚动条，用户体验差 不利于 SEO 搜索引擎优化，爬虫难处理 iframe 中的内容 许多移动端设备不兼容 增加服务器的 http 请求，大型网站不可取 Web Components 提供一套完善的封装机制使 Web 组件化能够标准化，每种框架的组件都统一标准，推动组件的复用 包含四部分： Custom Elements：让开发者自定义 HTML 元素，包括组成、样式和行为 HTML Imports：在 HTML 中引用和复用其他 HTML 文档的方式 HTML Templates：模板 Shadow DOM：提供更好的组织页面元素的方式，类似 DOM 中的 DOM，其元素和样式独立于原始 DOM JavaScript 字面量 字面量，和常量差不多，其表达的信息如字面所示 Object.assign(target, ...sources) 将 source 中的可枚举属性复制给 target，重名属性后面的覆盖前面的 复制的是属性值，如果属性值是引用类型则复制引用地址，会出现引用共享的问题（修改其中的一个会影响到别的） constructor constructor 属性是专门为 function 设计的，存在于每一个 function 函数的 prototype 原型属性中，是指向 prototype 所在函数的指针 当我们调用该函数作为构造函数创建一个新实例后，该实例中将包含一个指向构造函数中的 prototype 的指针 proto 如果以等于一个以对象字面量形式创建的新对象，constructor 不再指向该构造函数，比如 var person={ name:&quot;Jack&quot;, age:10 }; map 和 forEach const arr = [1,2,3]; // map 遍历数组并给每个数翻倍 const arr1 = arr.map(x=&gt;x*2); //[2,4,6] // forEach 遍历数组，有三个参数，分别是：当前遍历的数组元素 item、当前的元素下标 index、数组本身 arr let sum = 0; arr.forEach(function(item, index, arr) { if (arr[index] &gt; 0) sum += item; }) 相同点： 均循环遍历数组每一项 只能遍历数组 匿名函数都支持三个参数 item、index、arr 匿名函数中的 this 指向 window 不同点： map 创建新数组并返回，forEach 无返回 forEach 可以修改原数组，map 不会 for of es6 的新增方法，只限于迭代器(iterator)，也就是可迭代对象，比如 Array、Map、Set、String、arguments、TyoedArray 等 js 静态类型检查 静态类型语言：变量在定义的时候有类型声明，类型的检查发生在编译时，在运行的时候无法修改变量类型，编译器可以确定运行时需要的内存总量 动态类型语言：变量在定义的时候无类型声明，类型的检查发生在运行时，在运行的时候可以修改变量类型 对比：静态类型可以尽早发现错误，减少了复杂的错误处理，将数据和行为分离，也有利于代码重构；动态类型的代码比较精简，并且不需要花时间掌握类型 js 的静态类型检查方法：Flow是 Facebook 的 js 静态类型检查工具，能够找出类型错误；TypeScript 在 js 的基础上添加静态类型定义，并且会被编译成 js indexOf str.indexOf(searchValue[, fromIndex]) 找到返回第一个匹配字串的起始下标，未找到返回 0 searchValue 不设置会查找字符串 'undefined' fromIndex 是可选的，不填默认 0，负数等同 0，大于字符串长度等同于字符串长度 严格区分大小写 变量提升 js 是单线程语言，是按顺序执行，但是一段一段地分析执行，代码执行前的编译阶段会检测到所有的变量和函数声明，添加到叫做 Lexical Environment 的 js 数据结构的内存中，所以能够在真正被声明前使用 HashMap 和 Array HashMap 散列表 是 数组 + 链表 查找效率：HashMap 根据 hashcode 直接算出 index，在数组每个下标的链表只有一个元素的时候，能达到 O(1)；Array 二分查找，受数组长度影响较大 扩容数量：HashMap 初始长度 16，每次扩容申请双倍，扩容次数少；Array 小于 4 申请 4，小于 8 申请 8，大于 8 申请 size * 1.5，申请空间少 扩容效率：HashMap 扩容重新计算每个元素的位置，然后放到新的位置；Array 直接赋值数组，效率更高 内存消耗：Array 使用了独特的方式重复利用因为数组扩容遗留的数组空间，HashMap 没有 总的来说，数据量小且使用频繁使用 Array，数据量大使用 HashMap HashMap 和 Object 两者累次允许按键存取值，删除键，检测键是否有值，不过 Map 有些优势： 意外的键：Map 默认不包含任何键；Object 有原型，可能与插入的键名冲突 键的类型：Map 键可以是任意值；Object 只能是 String 或 Symbol 键的顺序：Map 键是有序的，迭代时以插入顺序返回；Object 无序 Size：Map 通过 size 容易获取键值对个数；Object 手动计算 迭代：Map 可直接迭代；获取 Object 的键值后才能迭代 性能：Map 在频繁增删时性能更优；Object 无优化 ","link":"https://AriesSK.github.io/post/qian-duan-mian-shi/"},{"title":"19. 删除链表的倒数第 N 个节点","content":"知识点 链表删除 链表删除有两个要注意的点： 要删除链表的一个节点，需要知道它的前一个节点，才能进行删除操作； 根据上面这一点，可以发现删除头节点与删除别的节点不同，因为头节点没有前一个节点，这种情况可以设置一个**头指针（哑巴节点）**指向头节点，这样就可以不用单独处理头节点。 题解 双指针 使用双指针，根据 nnn 的值设置双指针的间距，然后保持该间距遍历链表至右指针为空，再进行删除操作，思路很简单，就要注意上面说的两个点： var removeNthFromEnd = function(head, n) { const hptr = new ListNode(0, head); let l = hptr, r = head; while (n--) r = r.next; while (r) { l = l.next; r = r.next; } const tmp = l.next; l.next = tmp.next; tmp.next = null; return hptr.next; }; ","link":"https://AriesSK.github.io/post/top_19/"},{"title":"17. 电话号码的字母组合","content":"知识点 字符串排列的深度优先搜索 每次只考虑当前位的一种情况，然后考虑下一位直到形成一个完整的字符串，再回溯上来考虑上一位的其他情况，最终完成所有情况的遍历。 题解 深度优先搜索 回溯 每次固定一位，深度优先遍历，然后回溯上来考虑别的情况。 需要注意的就是回溯的时候要把字符串末尾的字符删除： var letterCombinations = function(digits) { if (digits === &quot;&quot;) return []; const res = []; let str = &quot;&quot;; const map = new Map([ [&quot;2&quot;, &quot;abc&quot;], [&quot;3&quot;, &quot;def&quot;], [&quot;4&quot;, &quot;ghi&quot;], [&quot;5&quot;, &quot;jkl&quot;], [&quot;6&quot;, &quot;mno&quot;], [&quot;7&quot;, &quot;pqrs&quot;], [&quot;8&quot;, &quot;tuv&quot;], [&quot;9&quot;, &quot;wxyz&quot;] ]); dfs(0); return res; function dfs(x) { if (x === digits.length) { res.push(str); return; } const s = map.get(digits.charAt(x)); for (let i = 0; i &lt; s.length; ++i) { str += s.charAt(i); dfs(x + 1); str = str.slice(0, -1); } } }; ","link":"https://AriesSK.github.io/post/top_17/"},{"title":"15. 三数之和","content":"知识点 双指针 在排序的前提下使用双指针，能够将 O(n2)O(n^2)O(n2) 的遍历时间复杂度降低至 O(n)O(n)O(n)。 题解 排序 + 双指针 这道题的难点是要输出所有的解，并且要保证解不能重复： 首先可以对数组进行排序，使最终的输出中 a≤b≤ca \\leq b \\leq ca≤b≤c，这样可以保证对同样下标的数不会重复输出； 但是不同下标但是值相同的情况仍有重复的可能，因此在遍历过程中，aaa 和 bbb 在遍历时，要保证与之前的自己值不同，而保证了 aaa 和 bbb 不同，ccc 必然不同。 var threeSum = function(nums) { if (nums.length &lt; 3) return []; const res = []; nums.sort((a, b) =&gt; a - b); for (let i = 0; i &lt; nums.length - 2; ++i) { // 最小数大于 0，后面无可能，终止 if (nums[i] &gt; 0) break; // 排除 a 重复 if (i &amp;&amp; nums[i] === nums[i - 1]) continue; let l = i + 1, r = nums.length - 1; while (l &lt; r) { if (nums[l] + nums[r] === -nums[i]) { res.push([nums[i], nums[l], nums[r]]); ++l; // 排除 b 重复 while (nums[l] === nums[l - 1]) ++l; } else if (nums[l] + nums[r] &lt; -nums[i]) ++l; else --r; } } return res; }; ","link":"https://AriesSK.github.io/post/top_15/"},{"title":"14. 最长公共前缀","content":"知识点 charAt()越界 js 字符串中的charAt()函数中的值若是超过了字符串的长度，也就是越界，并不会报错，而是返回一个空字符串&quot;&quot;。 题解 法一：纵向对比 逐个比较每个字符串相同位的字符： var longestCommonPrefix = function(strs) { for (let i = 0; i &lt; strs[0].length; ++i) { const s = strs[0].charAt(i); for (const str of strs) { if (str.charAt(i) !== s) return strs[0].slice(0, i); } } return strs[0]; }; 题解 法二：纵向对比 把第一个字符串作为最长公共前缀，与后一个字符串比较，更新最长公共前缀，再与下一个字符串比较，以此类推至遍历完或最长公共前缀为空字符串： var longestCommonPrefix = function(strs) { let res = strs[0]; for (let i = 1; i &lt; strs.length; ++i) { for (let j = 0; j &lt; res.length; ++j) { if (res.charAt(j) !== strs[i].charAt(j)) { res = res.slice(0, j); break; } } if (res === &quot;&quot;) break; } return res; }; ","link":"https://AriesSK.github.io/post/top_14/"},{"title":"13. 罗马数字转整数","content":"知识点 模拟 根据题目表述进行筛选提取关键要素，按需求书写代码解决实际问题。 简单来说就是照着葫芦画瓢，按着题目意思来。 题解 模拟 模拟读取的过程即可，正常是大数在前小数在后，加上每一个字符代表的数值，若发现逆序则改加为减： var romanToInt = function(s) { let res = 0; const table = new Map([['I', 1], ['V', 5], ['X', 10], ['L', 50], ['C', 100], ['D', 500], ['M', 1000]]); for (let i = 0; i &lt; s.length - 1; ++i) { const m = table.get(s.charAt(i)), n = table.get(s.charAt(i + 1)); res += m &gt;= n ? m : -m; } res += table.get(s.charAt(s.length - 1)); return res; }; ","link":"https://AriesSK.github.io/post/top_13/"},{"title":"11. 盛水最多的容器","content":"知识点 双指针 剪枝 双指针的解法，加上剪枝的思想。 对于本题，暴力解法遍历考虑每两块板构成的方案，而这些方案中有许多不可能成为最大值的方案，所以全多遍历造成了时间复杂度的提升。 而双指针移动短板的方法就是在不断排除不可能成为最大值的方案，剪去了考虑这些方案的时间复杂度，获取可能的方案中的最大值，得到最终解。 题解 双指针 设定左右指针 lll、rrr，由于短板决定盛水面积，得到面积公式： S(l,r)=min(height[l],height[r])∗(r−l)S(l, r) = min(height[l], height[r]) * (r - l) S(l,r)=min(height[l],height[r])∗(r−l) 使 lll、rrr 分别从两端开始向内遍历至相遇，排除不可能成为最大值的方案，记录可能方案中的最大值即为所求结果。 在遍历过程中应当移动短板，也就是指向高度较低的指针。因为短板决定盛水面积，移动长板只会使盛水的长度变小导致面积变小；而短板在移动过程中可能变大使盛水面积变大。 var maxArea = function(height) { let l = 0, r = height.length - 1, res = 0; while (l &lt; r) { res = height[l] &lt; height[r] ? Math.max(res, (r - l) * height[l++]) : Math.max(res, (r - l) * height[r--]); } return res; }; ","link":"https://AriesSK.github.io/post/top_11/"},{"title":"10. 正则表达式匹配","content":"知识点 本题与剑指offer的19题相同，具体思路请移步19. 正则表达式匹配。 题解 动态规划 这道题新做了一遍，对代码进行了一些优化，并且有了些新的理解： var isMatch = function(s, p) { const m = s.length, n = p.length; const dp = new Array(m + 1); for (let i = 0; i &lt; m + 1; ++i) dp[i] = new Array(n + 1).fill(false); dp[0][0] = true; // i 不能从 1 开始，因为 a 为空串可以匹配 p 的单字符和 * 的组合 for (let i = 0; i &lt; m + 1; ++i) { // j 可以直接从 1 开始，因为 p 为空串无法匹配 a 的串 for (let j = 1; j &lt; n + 1; ++j) { // 能够匹配的情况下尝试多匹配一个字符直到完全匹配或无法匹配，无法匹配就扔掉 if (p.charAt(j - 1) === &quot;*&quot;) dp[i][j] = helper(i, j - 1) ? dp[i][j] = dp[i - 1][j] || dp[i][j - 2] : dp[i][j - 2]; else dp[i][j] = helper(i, j) ? dp[i - 1][j - 1] : false; } } return dp[m][n]; function helper(i, j) { // 空串不能和任何字符匹配 if(!i) return false; if (s.charAt(i - 1) === p.charAt(j - 1) || p.charAt(j - 1) === &quot;.&quot;) return true; return false; } }; ","link":"https://AriesSK.github.io/post/top_10/"},{"title":"8. 字符串转换整数","content":"知识点 有限状态自动机 对于字符串处理的问题，往往有着复杂的流程和条件，这时候可以使用有限状态自动机来解决覆盖所有情况。 有限状态机使程序在每个时刻有一个状态 sss，每次从序列中输入一个字符 ccc，并根据字符 ccc 转移到下一个状态 s′s&#x27;s′。这样，我们只需要建立一个覆盖所有情况的从 sss 与 ccc 映射到 s′s&#x27;s′ 的表格即可解决题目中的问题。 题解 法一：模拟 逐个字符处理，分情况讨论即可： var myAtoi = function(s) { let i = 0; // 跳过空格 while (s.charAt(i) === &quot; &quot;) ++i; // 记录数字起始位置 const j = i; // 跳过符号 if (s.charAt(i) === &quot;+&quot; || s.charAt(i) === &quot;-&quot;) ++i; // 符号后非数字 if (s.charAt(i) &lt; &quot;0&quot; || s.charAt(i) &gt; &quot;9&quot;) return 0; // 找到数字结束位置 while (s.charAt(i) &gt;= &quot;0&quot; &amp;&amp; s.charAt(i) &lt;= &quot;9&quot;) ++i; const res = +s.slice(j, i); return res &gt;= 0 ? Math.min(res, 2**31 - 1) : Math.max(res, -(2**31)); }; 法二：有限状态自动机 定义状态，使用哈希表存储状态转移表，然后遍历字符串，进行状态转移和处理： 空格 符号(+/-) 数字 其他 起始空格的（状态 0） 0 1 2 3 数字前的符号（状态 1） 3 3 2 3 数字（状态 2） 3 3 2 3 数字结束后的其他字符（状态 3） 3 3 3 3 对于本题来说一旦转移到状态 333 即可停止遍历字符串。 var myAtoi = function(s) { let res = 0, sym = 1; const state = [ new Map([[&quot; &quot;, 0], [&quot;s&quot;, 1], [&quot;n&quot;, 2], [&quot;?&quot;, 3]]), new Map([[&quot; &quot;, 3], [&quot;s&quot;, 3], [&quot;n&quot;, 2], [&quot;?&quot;, 3]]), new Map([[&quot; &quot;, 3], [&quot;s&quot;, 3], [&quot;n&quot;, 2], [&quot;?&quot;, 3]]) ]; let p = 0, t = &quot; &quot;; for (let c of s.split(&quot;&quot;)) { if (c === &quot; &quot;) t = &quot; &quot;; else if (c === &quot;+&quot; || c === &quot;-&quot;) { t = &quot;s&quot;; // 注意这里只有空格后面的 +/- 才代表数字的符号，比如 &quot;-1+2&quot; 中 + 不应当修改数组的符号 if (p === 0) sym = c === &quot;+&quot; ? 1 : -1; } else if (c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot;) { t = &quot;n&quot;; res = res * 10 + Number(c); } else t = &quot;?&quot;; p = state[p].get(t); if (p === 3) break; } res *= sym; return res &gt;= 0 ? Math.min(res, 2**31 - 1) : Math.max(res, -(2**31)); }; ","link":"https://AriesSK.github.io/post/top_8/"},{"title":"7. 整数反转","content":"知识点 对于大数的问题往往可以通过转化为字符串来解决。 题解 字符串 由于题目要求不能存储超过上限的数字，所以不能直接反转后判断是否超过上限，只能转成字符串后逐位判断： 如果 数字位数&lt;上限位数数字位数 &lt; 上限位数数字位数&lt;上限位数，不会越界，直接反转； 如果 数字位数=上限位数数字位数 = 上限位数数字位数=上限位数，从数字的最后一位和上限的第一位开始逐个比较：数字大则越界，返回 000；否则不越界，反转数字。 var reverse = function(x) { let sym = 1, num = &quot;&quot;; if (x &lt; 0) { sym = -1; x = -x; num += 2**31; } else num += 2**31 - 1; const n = num.length; x += &quot;&quot;; if (x.length === n) { for (let i = 0; i &lt; n; ++i) { if (x.charAt(n - 1 - i) === num.charAt(i)) continue; else if (x.charAt(n - 1 - i) &gt; num.charAt(i)) return 0; else break; } } return x.split(&quot;&quot;).reverse().join(&quot;&quot;) * sym; }; ","link":"https://AriesSK.github.io/post/top_7/"},{"title":"5. 最长回文子串","content":"知识点 回文串的判断 重要性质：对于一个回文串，如果其长度大于 222，那么删去其首尾两个字符，它仍是回文串。 回文中心：回文串的中心字符，可以是一个字符或者两个相同的字符。 可以设定回文中心，然后对其进行扩展，在两端个新增一个字符，若两个字符相同则扩展成功，到无法扩展后就得到了该回文中心的最长回文串。 题解 法一：动态规划 根据重要性质，不难推出状态转移方程： dp[i,j]dp[i, j]dp[i,j] 表示 s[i,j]s[i, j]s[i,j] 是否是回文串，则 dp[i,j]=dp[i+1,j−1]且(s[i]=s[j])dp[i, j] = dp[i + 1, j - 1] 且 (s[i] = s[j])dp[i,j]=dp[i+1,j−1]且(s[i]=s[j]) 法二：中心扩散法 遍历字符串，把每个字符作为回文串的回文中心尝试扩散，记录最长的回文串： var longestPalindrome = function(s) { let res = &quot;&quot;; for (let i = 0; i &lt; s.length; ++i) { // 回文中心有两种：单字符 和 相同双字符，每次遍历两种均考虑，取长的 const s1 = helper(i, i), s2 = helper(i, i + 1); const s = s1.length &gt; s2.length ? s1 : s2; res = s.length &gt; res.length ? s: res; } return res; function helper(l, r) { while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s.charAt(l) === s.charAt(r)) { --l; ++r; } return s.slice(l + 1, r); } }; ","link":"https://AriesSK.github.io/post/top_5/"},{"title":"4. 寻找两个正序数组的中位数","content":"知识点 中位数的小技巧 求中位数一般需要分奇偶两种情况，对于长度为 nnn 的数组 numsnumsnums： 若 nnn 为奇数，则中位数为第 (n+1)/2(n + 1) / 2(n+1)/2 个； 若 nnn 为偶数，则中位数为第 n/2n / 2n/2 个和第 (n+2)/2(n + 2) / 2(n+2)/2 个数的平均值； 事实上可以不分奇偶计算第 (n+1)/2(n + 1) / 2(n+1)/2 和 (n+2)/2(n + 2) / 2(n+2)/2 个数（均向下取整）的平均值，对于奇数这两个是同一个数，对于偶数则是对应的两个数，与上面的等价。 这样写的好处是转换为代码后比较精简。 题解 法一：合并有序数组 简单，时间复杂度 O(m+n)O(m + n)O(m+n)，不满足题目要求。 法二：二分法 这题的二分法很难理解，量力而行吧。 题目要求时间复杂度 O(log(m+n))O(log(m + n))O(log(m+n))，这个时间复杂度就容易想到要用二分法。 根据小技巧，需要在两个数组中找到第 (m+n+1)/2(m+n+1) / 2(m+n+1)/2 个和 (m+n+2)/2(m+n+2) / 2(m+n+2)/2 个数并求平均值，因此转换为了求第 KKK 小个数的问题。 本题二分法的条件是（所有 /// 均表示整数除法）： 如果 A[k/2−1]&lt;=B[k/2−1]A[k / 2 − 1] &lt;= B[k / 2 − 1]A[k/2−1]&lt;=B[k/2−1]，则比 A[k/2−1]A[k / 2−1]A[k/2−1] 小的数最多只有 AAA 的前 k/2−1k / 2 − 1k/2−1 个数和 BBB 的前 k/2−1k / 2 − 1k/2−1 个数，即 k−2k−2k−2 个，因此 A[k/2−1]A[k / 2 − 1]A[k/2−1] 不可能是第 kkk 个数，它之前的也都可以全部排除； 如果 A[k/2−1]&gt;B[k/2−1]A[k / 2 − 1] &gt; B[k / 2 − 1]A[k/2−1]&gt;B[k/2−1]，则排除 B[0]B[0]B[0] 到 B[k/2−1]B[k / 2 - 1]B[k/2−1]。 三种特殊情况，后两种是递归出口： k/2−1k / 2 − 1k/2−1 超过了某一个数组的长度，则另一个数组的 [k/2−1][k / 2 - 1][k/2−1] 和前面的数均可以排除，因为比其小的数不可能达到 k−1k - 1k−1 个； 一个数组为空，则返回另一个数组的第 kkk 小元素； 如果 kkk 为一，即找最小的数，返回两个数组首元素的最小值即可。 var findMedianSortedArrays = function(nums1, nums2) { const m = nums1.length, n = nums2.length, l = m + n + 1 &gt;&gt; 1, r = m + n + 2 &gt;&gt; 1; return (findKth(nums1, 0, nums2, 0, l) + findKth(nums1, 0, nums2, 0, r)) / 2; function findKth(nums1, i, nums2, j, k) { // 其一为空，返回另一个的第 k 小 if (i &gt;= nums1.length) return nums2[j + k - 1]; if (j &gt;= nums2.length) return nums1[i + k - 1]; // 为 1，返回最小首元素 if (k === 1) return Math.min(nums1[i], nums2[j]); // 超过数组长度，则赋最大值以保证排除另一个数组的前 k / 2 个元素 const mid1 = (i + k / 2 - 1 &lt; nums1.length) ? nums1[i + (k &gt;&gt; 1) - 1] : Number.MAX_SAFE_INTEGER; const mid2 = (j + k / 2 - 1 &lt; nums2.length) ? nums2[j + (k &gt;&gt; 1) - 1] : Number.MAX_SAFE_INTEGER; // 小的数组的前 k / 2 个元素均可以排除，递归排除剩余的 if (mid1 &lt; mid2) return findKth(nums1, i + (k &gt;&gt; 1), nums2, j, k - (k &gt;&gt; 1)); else return findKth(nums1, i, nums2, j + (k &gt;&gt; 1), k - (k &gt;&gt; 1)); } }; ","link":"https://AriesSK.github.io/post/top_4/"},{"title":"3. 无重复字符的最长字串","content":"知识点 本题与剑指offer的48题相同，只记录一下之前方法的思路，具体请移步48. 最长不含重复字串的子字符串。 题解 法一：动态规划 思路： 状态定义：使用 dp[i]dp[i]dp[i] 记录以下标 iii 结尾的最长不重复字串长度； 转移方程：对于 s[i]s[i]s[i]，未出现则记入哈希表，出现则更新，将 s[i]s[i]s[i] 和在它前面的相同字符的距离与 dp[i−1]dp[i - 1]dp[i−1] 比较，若大于则说明 s[i]s[i]s[i] 使不重复长度加一，dp[i]=dp[i−1]+1dp[i] = dp[i - 1] + 1dp[i]=dp[i−1]+1，否则不变； 初始状态：dp[0]=0,dp[1]=1dp[0] = 0, dp[1] = 1dp[0]=0,dp[1]=1； 返回结果：dpdpdp 数组中的最大值。 法二：滑动窗口 使用左指针代表子串的起始位置，而右指针代表字串的结束位置； 左指针每轮右移一格，将下一个字符作为起始位置，在保证窗口中没有重复字符的前提（哈希表）下不断右移右指针。在移动结束后，窗口对应以左指针开始的最长不重复子串，记录其长度； 容易忘记：左指针移动到最后一个字符，返回记录长度的最大值。 新增 重新做了一遍想出了另一种滑动窗口的方法： 右指针右移并将字符和下标记入哈希表： 遇重复元素，记录区间长度，更新左指针位置为哈希表中记录的重复元素的下标（注意不能左移），重复操作至右指针遍历完字符串； 当右指针遍历完，更新一次区间的长度（最后一段不重复长度最长的情况）； 返回最大区间长度。 var lengthOfLongestSubstring = function(s) { const map = new Map(); let l = 0, r = 0, res = 0; while (r &lt; s.length) { if (map.has(s.charAt(r))) { res = Math.max(res, r - l); // 取最大值保证左指针不会左移 l = Math.max(l, map.get(s.charAt(r)) + 1); } map.set(s.charAt(r), r); ++r; } // 遍历完后更新区间长度 res = Math.max(res, r - l); return res; }; ","link":"https://AriesSK.github.io/post/top_3/"},{"title":"2. 两数相加","content":"知识点 仔细考虑题目，想到每种情况！ 修改冗余部分，不断精简代码！ JavaScript 判断数组是否包含某元素 const arr = [&quot;Aries&quot;, &quot;AriesSK&quot;]; arr.includes(&quot;Aries&quot;); // true 题解 模拟 遍历链表，模拟加法，注意进位，在两链表均遍历完后仍有进位的情况很容易遗漏： var addTwoNumbers = function(l1, l2) { let lptr = l1, rptr = l2, flag = false, node = new ListNode(); const res = node; // 两链表均非空，值相加 while(lptr &amp;&amp; rptr) { let tmp = lptr.val + rptr.val; // 进位 if (flag) { tmp += 1; flag = false; } if (tmp &gt;= 10) { tmp %= 10; flag = true; } node.next = new ListNode(tmp); node = node.next; lptr = lptr.next; rptr = rptr.next; } // 一链表为空，考虑另一链表 if (!lptr) { while (rptr) { let tmp = rptr.val; if (flag) { tmp += 1; flag = false; } if (tmp &gt;= 10) { tmp %= 10; flag = true; } node.next = new ListNode(tmp); node = node.next; rptr = rptr.next; } } else { while (lptr) { let tmp = lptr.val; if (flag) { tmp += 1; flag = false; } if (tmp &gt;= 10) { tmp %= 10; flag = true; } node.next = new ListNode(tmp); node = node.next; lptr = lptr.next; } } // 两链表均空，考虑进位 if (flag) node.next = new ListNode(1); return res.next; }; 上面的解法思路正确但代码过于冗杂，看了题解后作出了如下的优化： lptrlptrlptr 和 rptrrptrrptr 并无必要，直接使用 l1l1l1 与 l2l2l2 即可； flagflagflag 表示进位也并无必要，使用两链表值之和除 101010 向下取整即可获取进位值，进位加 111 不进加 000； 循环可以直到两链表均遍历完再停止，一个链表先遍历完后直接用 000 替代其 valvalval 即可。 var addTwoNumbers = function(l1, l2) { let carry = 0, node = new ListNode(); const res = node; while(l1 || l2) { const n1 = l1 ? l1.val : 0; const n2 = l2 ? l2.val : 0; let sum = n1 + n2 + carry; node.next = new ListNode(sum % 10); node = node.next; carry = sum &gt;= 10 ? 1 : 0; if (l1) l1 = l1.next; if (l2) l2 = l2.next; } if (carry) node.next = new ListNode(1); return res.next; }; ","link":"https://AriesSK.github.io/post/top_2/"},{"title":"1. 两数之和","content":"知识点 数组初始有序则使用双指针的方法，无序则使用哈希表。 不推荐将数组排序后使用双指针，因为排序后数组变化，值对应的下标也变化。 题解 哈希表 判断差值能够避免自身匹配和同值覆盖的问题： var twoSum = function(nums, target) { let map = new Map(); for (let i = 0; i &lt; nums.length; ++i) { if (map.has(target - nums[i])) return [i, map.get(target - nums[i])]; else map.set(nums[i], i); } return []; }; ","link":"https://AriesSK.github.io/post/top_1/"},{"title":"44. 数字序列中某一位的数字","content":"知识点 找规律的题目，多动笔多思考。 题解 数学 找出题目中的数学规律： 一位数字 101010 个，占 101010 位，得到第一个两位数的起始下标为 101010; 两位数字 909090 个，占 90×290 \\times 290×2 位，得到第一个三位数的起始下标为 10+90×210 + 90 \\times 210+90×2； 三位数字 900900900 个，占 900×3900 \\times 3900×3 位，得到第一个四位数的起始下标为 10+90×2+900×310 + 90 \\times 2 + 900 \\times 310+90×2+900×3； 所以 iii 位数字 9×10i−19 \\times 10^{i - 1}9×10i−1 个，占 9×10i−1×i9 \\times 10^{i - 1} \\times i9×10i−1×i 位，第一个i+1i + 1i+1位数的起始下标为 10+90×2+...+9×10i−1×i10 + 90 \\times 2 + ... + 9 \\times 10^{i - 1} \\times i10+90×2+...+9×10i−1×i。 而想知道第 nnn 位的值，只需要找到它是几位数中的第几个数的第几位即可： 几位数：通过上面的规律找到 nnn 所在的区间范围即可得到对应的位数； 第几个数：nnn 减去它的位数的起始下标，再整除其位数即可得到； 第几位：nnn 减去它的位数的起始下标，再对其位数取模即可得到。 假设位数为 iii，整除得 aaa，取模得 bbb，则 nnn 所在的数是 10i−1+a10^{i - 1} + a10i−1+a，它的第 bbb 位就是结果。 var findNthDigit = function(n) { // 单独处理一位数 if (n &lt; 10) return n; let p = 10, q = 10, i = 2; // 找到 n 的位数 i，以及 i 位数的起始下标 p for (i = 2;; ++i) { q += 9 * 10 ** (i - 1) * i; if (q &gt; n) break; p = q; } // 找到第几个数第几位 let a = Math.floor((n - p) / i), b = (n - p) % i; return +(10 ** (i - 1) + a).toString().charAt(b); }; ","link":"https://AriesSK.github.io/post/jianzhi_44/"},{"title":"43. 1~n整数中1出现的次数","content":"知识点 这类数学题能找到规律就能做，找不到规律就没办法。 题解 法一：暴力 第一时间想到暴力，转成字符串后每有一个 111 都能使分割后的数组长度加一，不过考虑到本题 n 的最大值为 231−12^{31} - 1231−1，果断排除暴力法，因为split()的时间复杂度已经是 O(n)O(n)O(n) 了： var countDigitOne = function(n) { let res = 0; for (let i = 1; i &lt;= n; ++i) res += (&quot;&quot; + i).split(&quot;1&quot;).length - 1; return res; }; 法二：数学 第二想法就是用动态规划，于是尝试找转移方程，结果先发现了数学的方法，假设 iii 位数中 111 的出现次数为 dp[i]dp[i]dp[i]，nnn 中右数第 iii 位的值为 num[i]num[i]num[i]： 对于 111 来说，在它之前没有出现过 111，故 dp[0]=0dp[0] = 0dp[0]=0； 对于 101010 来说，在它之前出现过一次 111，故 dp[1]=1dp[1] = 1dp[1]=1； 那么对于两位数，我们可以通过其十位数的值 num[2]num[2]num[2] 知道个位数已经出现了num[2] * dp[1]次 111，还需要计算十位数 111 出现的次数，分为两种情况： num[2]=1num[2] = 1num[2]=1，那么次数是其个位的值nums[1] + 1(个位从 0 开始)，所以res = num[2] * dp[1] + nums[1] + 1； num[2]&gt;1num[2] &gt; 1num[2]&gt;1，那么十位数为 111 的数已经全部出现过，出现了 10110^1101 次，所以res = num[2] * dp[1] + 10**1。 并且可以知道 dp[2] = 10 * dp[1] + 10**1。 同理可以将其扩展至 iii 位数，首先dp[i] = 10 * dp[i - 1] + 10**(i - 1)；其次通过其iii 位数的值num[i]知道 i−1i - 1i−1 位数已经出现了 num[i] * dp[i - 1] 次 111，还需要计算 iii 位数 111 出现的次数，分为两种情况： num[i]=1num[i] = 1num[i]=1，那么次数是其低位的值Number(&quot;&quot; + num[i- 1] + ... +num[1]) + 1，所以res = num[2] * dp[1] + Number(&quot;&quot; + num[i- 1] + ... +num[1]) + 1； num[i]&gt;1num[i] &gt; 1num[i]&gt;1，那么十位数为 111 的数已经全部出现过，出现了 10i10^i10i 次，所以res = num[2] * dp[i - 1] + 10**i。 var countDigitOne = function(n) { let res = 0, num = &quot;&quot; + n; const len = num.length; let dp = 0; // i 记录当前位 从个位开始 从低位到高位 for (let i = len - 1; i &gt;= 0; --i) { let curr = len - i - 1; res += dp * Number(num.charAt(i)); dp = dp * 10 + 10 ** curr; if (num.charAt(i) &gt; 1) res += 10 ** curr; if (num.charAt(i) == 1) res += (Number(num.slice(i + 1)) + 1); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_43/"},{"title":"14 - II. 剪绳子 II","content":"知识点 Javascript 的安全整数范围 安全整数范围： 指的是能够安全的用来进行算数运算的范围，当值超出这个范围的数字值将不再准确。 js 的安全整数范围是 −(253−1)至253−1-(2^{53} - 1) 至 2^{53} - 1−(253−1)至253−1 大数越界的求余问题 求余运算规则：(xy)⊙p=[(x⊙p)(y⊙p)]⊙p(xy) \\odot p = [(x \\odot p)(y \\odot p)] \\odot p(xy)⊙p=[(x⊙p)(y⊙p)]⊙p 法一：循环求余 根据求余运算性质推出： xa⊙p=[(xa−1⊙p)(x⊙p)]⊙p=[(xa−1⊙p)x]⊙px^{a} \\odot p=\\left[\\left(x^{a-1} \\odot p\\right)(x \\odot p)\\right] \\odot p=\\left[\\left(x^{a-1} \\odot p\\right) x\\right] \\odot p xa⊙p=[(xa−1⊙p)(x⊙p)]⊙p=[(xa−1⊙p)x]⊙p 因此可以通过循环依次求 x1⊙p,x2⊙p...xa⊙px^1 \\odot p, x^2 \\odot p ... x^a \\odot px1⊙p,x2⊙p...xa⊙p： // 本题中 x 均小于 p var function = remainder(x, a, p) { rem = 1; for (let i = 0; i &lt; a; ++i) rem = rem * x % p; return rem; } 法二：快速幂求余 根据求余运算性质推出： xa⊙p=(x2)a/2⊙p=(x2⊙p)a/2⊙px^{a} \\odot p=(x^2)^{a/2} \\odot p=(x^2 \\odot p)^{a/2} \\odot p xa⊙p=(x2)a/2⊙p=(x2⊙p)a/2⊙p 这种方法又需要分奇偶： xa⊙p={(x2)a/2⊙p=(x2⊙p)a//2⊙p,a为偶数[(x⊙p)(xa−1⊙p)]⊙p=[x(x2⊙p)a//2]⊙p,a为奇数x^{a} \\odot p=\\begin{cases} (x^2)^{a/2} \\odot p=(x^2 \\odot p)^{a//2} \\odot p &amp;,a为偶数\\\\ [(x \\odot p)(x^{a-1}\\odot p)] \\odot p = [x(x^2 \\odot p)^{a//2}] \\odot p &amp;,a为奇数 \\end{cases} xa⊙p={(x2)a/2⊙p=(x2⊙p)a//2⊙p[(x⊙p)(xa−1⊙p)]⊙p=[x(x2⊙p)a//2]⊙p​,a为偶数,a为奇数​ var function = remainder(x, a, p) { rem = 1; while (a &gt; 0) { if (a % 2) rem = rem * x % p; // 碰到奇数时，因为整除并向下取整，因此需额外乘 x 到最终结果中，不论奇偶最终 a 均会为 1，更新得到所求结果 x = x ** 2 % p; // x 变为原先的平方，在此过程中取余防止越界 a &gt;&gt;= 1; // a 变为原先的一半 向下取整 } return rem; } 注意： 法二的时间复杂度优于法一，但法二的使用范围比法一小，在 js 中本题无法使用法二，只能使用法一，具体见下方题解。 题解 数学 解题思路参考14 - I. 剪绳子 I，与本题的区别是本题涉及大数越界情况下的求余问题，因为当 aaa 增大时，返回的 3a3^a3a 以质数增长，可能超出表示范围，选用快速幂求余，但 js 的安全整数无法保证 100000000721000000007^210000000072 的正确存储，因此这种方法不行： var cuttingRope = function(n) { const p = 1e9 + 7; if (n &lt;= 3) return n - 1; let rem = 1, x = 3; // 为了方便后续讨论 b 为 1 时需要拆一个 3，a 需要减 1 let a = Math.floor(n / 3) - 1, b = n % 3; for (a; a &gt; 0; a &gt;&gt;= 1) { if (a % 2) rem = rem * x % p; x = x * x % p; } if (b === 0) return rem * 3 % p; if (b === 1) return rem * 4 % p; return rem * 6 % p; }; 因此只能使用循环求余： var cuttingRope = function(n) { const p = 1e9 + 7, b = n % 3; if (n &lt;= 3) return n - 1; let rem = 1, a = Math.floor(n / 3); for (let i = 0; i &lt; a - 1; ++i) rem = rem * 3 % p; if (b === 0) return rem * 3 % p; if (b === 1) return rem * 4 % p; return rem * 6 % p; }; ","link":"https://AriesSK.github.io/post/jianzhi_14_ii/"},{"title":"51. 数组中的逆序对","content":"知识点 归并排序 归并排序体现了分治的思想： 分：不断将数组对半分开，将整个数组的排序文体转化为子数组的排序问题； 治：划分到子数组长度为 111 时停止，向上进行合并，将较短排序数组合并为较长排序数组，直至合并至原数组长度，排序完成。 var mergeSort = function(nums) { // 因为会直接在 nums 中修改，因此需要一个 tmp 数组来存储原数组 const tmp = new Array(nums.length); merge(0, nums.length - 1); function merge(l, r) { // 分至数组只有一个元素 if (l &gt;= r) return; let m = l + r &gt;&gt; 1; merge(l, m); merge(m + 1, r); // i，j 分别指向左右数组的第一个元素 let i = l, j = m + 1; // 保存原数组 for (let k = l; k &lt;= r; ++k) tmp[k] = nums[k]; for (let k = l; k &lt;= r; ++k) { // 每次选左右数组中较小的元素入 nums，一边遍历完可直接复制另一边 if (i === m + 1 || tmp[i] &gt; tmp[j]) nums[k] = tmp[j++]; else if (j === r + 1 || tmp[i] &lt;= tmp[j]) nums[k] = tmp[i++]; } } return nums; }; 题解 归并排序 本题所求的逆序对实际上与归并排序息息相关，可以在滚并排序的过程中顺便记录逆序对的数量： var reversePairs = function(nums) { let tmp = new Array(nums.length); return mergeSort(0, nums.length - 1); function mergeSort(l, r) { if (l &gt;= r) return 0; let m = l + r &gt;&gt; 1; let res = mergeSort(l, m) + mergeSort(m + 1, r); let i = l, j = m + 1; for (let k = l; k &lt;= r; ++k) tmp[k] = nums[k]; for (let k = l; k &lt;= r; ++k) { if (i === m + 1) nums[k] = tmp[j++]; else if (j === r + 1 || tmp[i] &lt;= tmp[j]) nums[k] = tmp[i++]; else { // 在比较左右数组元素大小时，发现一次逆序对，则左数组中此元素及其右侧元素均可与右数组的当前元素构成逆序对 nums[k] = tmp[j++]; res += m - i + 1; } } return res; } }; ","link":"https://AriesSK.github.io/post/jianzhi_51/"},{"title":"17. 打印从1到最大的n位数","content":"知识点 大数 各种语言中存储数值的数据类型都是有范围的，大数指的是超过了上限所以无法被存储的数字，处理此类问题时，往往采用字符串替代的方式。 题解 法一：暴力 暴力法没啥好说的，对于这道题来说，暴力是时空复杂度最优的解法： var printNumbers = function(n) { const res = []; for (let i = 1; i &lt; 10 ** n; ++i) res.push(i); return res; }; 法二：转字符串 不过这道题如果要考察不会这么简单，会涉及到大数的处理，就要转化为字符串处理，这道题的思路和38. 字符串的排列的思路类似，也是使用深度优先搜索的方式，从低位开始逐步固定每一位的值，到最后一位则记录这种可能。 本题需要注意的是因为结果代表的是数，因此在字符串中最左侧的字符不能是 000： var printNumbers = function(n) { const res = []; let num = &quot;&quot;; for (let len = 1; len &lt;= n; ++len) dfs(0, len); return res; // x 表示当前位，len 表示准备生成的数的长度 function dfs(x, len) { if (x === len) { res.push(num); return; } // 如果正在考虑第一位，则第一位不能为 0 let start = !x ? 1 : 0; for (let i = start; i &lt;= 9; ++i) { num += i; dfs(x + 1,len); num = num.slice(0, -1); } } }; 由于大数无法保存，最后以字符串数组的形式输出，不过 js 会尝试自动转换成想要的输出Number，所以也可以执行通过。 ","link":"https://AriesSK.github.io/post/jianzhi_17/"},{"title":"60. n个骰子的点数","content":"知识点 正推与逆推 很多题会有正推和逆推两种思考的方式，当一种实现起来困难的时候，不如尝试一下另一种，有时候有惊喜，别让思维受到局限！ 题解 动态规划 这题可以很容易地想到 nnn 个骰子可看作是 n−1n - 1n−1 个骰子再新增一个，因此应当使用动态规划。假设 dp[n][x]dp[n][x]dp[n][x] 表示求 nnn 个骰子点数和为 xxx 的概率，由于新加入的骰子有六种等概率的点数可能性，可以得到递推公式： dp(n,x)=∑i=16f(n−1,x−i)×16dp(n, x)=\\sum_{i=1}^{6} f(n-1, x-i) \\times \\frac{1}{6} dp(n,x)=i=1∑6​f(n−1,x−i)×61​ 但是这个公式转化为代码存在问题，比如求 dp[3][16]dp[3][16]dp[3][16] 应当用到 dp[2][10]dp[2][10]dp[2][10] 至 dp[2][15]dp[2][15]dp[2][15]，但事实上 dp[2]dp[2]dp[2] 的最大点数和只有 121212，也就是只能用到 dp[2][10]dp[2][10]dp[2][10] 至 dp[2][12]dp[2][12]dp[2][12]，这在转换为代码时就会出现越界的问题。 上述递推思想是逆推，如果用正推的思想即可避免越界： 由于新增一个骰子的点数在 111 至 666 之间，所以 dp[n−1][x]dp[n - 1][x]dp[n−1][x] 仅与 dp[n][x+1]dp[n][x + 1]dp[n][x+1] 至 dp[n][x+6]dp[n][x + 6]dp[n][x+6] 有关，所以遍历 dp[n−1]dp[n - 1]dp[n−1] 的各点数和的概率，将其加入到其在 dp[n]dp[n]dp[n] 中相关的项中即可完成正推。 由于数组从 000 开始，因此需注意公式与下标之间的转化： var dicesProbability = function(n) { const dp = new Array(n); dp[0] = new Array(6).fill(1 / 6); for (let i = 1; i &lt; n; ++i) dp[i] = new Array((i + 1) * 5 + 1).fill(0); for (let i = 1; i &lt; n; ++i) { for (let j = 0; j &lt; dp[i - 1].length; ++j) { for (let k = 0; k &lt; 6; ++k) { dp[i][j + k] += dp[i - 1][j] / 6; } } } return dp[n - 1]; }; 上面的方法是定义了一个二维数组，但事实上 dp[n]dp[n]dp[n] 的值仅与 dp[n−1]dp[n - 1]dp[n−1] 有关，因此可以通过两个一维数组来降低空间复杂度，类似于10 - I. 斐波那契数列中的滑动数组思想： var dicesProbability = function(n) { let dp = new Array(6).fill(1 / 6); for (let i = 2; i &lt;= n; ++i) { const tmp = new Array(5 * i + 1).fill(0); // 注意 js 要赋值，否则为 NaN for (let j = 0; j &lt; dp.length; ++j) { for (let k = 0; k &lt; 6; ++k) { tmp[j + k] += dp[j] / 6; } } dp = tmp; } return dp; }; ","link":"https://AriesSK.github.io/post/jianzhi_60/"},{"title":"49. 丑数","content":"知识点 找前 n 个素数(质数) 法一： 首先可以排除所有偶数，然后对奇数使用试除法，对于 nnn，使用 [0,n][0, \\sqrt{n}][0,n​]范围内的整数逐个试除即可，只需要到 n\\sqrt{n}n​ 的原因是如果 nnn 不是素数，则一定有一个非 111 的因数小于 n\\sqrt{n}n​。 法二：埃氏筛法 从 222 开始每找到一个素数，就把它的倍数全部筛掉，如果一个数没有被比它小的素数“筛掉”，那它就是素数。需要使用额外的数组空间来记录该数是否已经被筛掉。 法三：欧拉筛法 法二的优化算法，法二对于 666 这些多个素数的倍数会重复标记，欧拉筛法就是要保证每个数只被筛掉一次。欧拉筛法比较难理解。 // 找 n 以内的所有素数 var find = function(n) { // num 存素数，mark 标记是否被筛掉 const num = new Array(n), mark = new Array(n).fill(false); let count = 0; for (let i = 2; i &lt;= n; ++i) { // 未被更小的数筛掉，是素数 if (!mark[i]) num[count++] = i; // 遍历素数 for (let j = 0; num[j] &lt;= n / i; ++j) { // 筛掉当前数的素数倍 mark[num[j] * i] = true; // 防止重复标记，以 i = 6, nums[j] = 2 为例，上一行已经通过 2 筛掉了 6，如果不跳出，接下来又会通过 3 筛掉 6，导致重复计算 if (i % num[j] === 0) break; } } return num; } Tips 111 不是质数，但与任何数互质。 互质是指两个整数只有 111 一个公因数。 题解 法一：暴力 我想到了 较大的丑数=较小的丑数∗(2/3/5)较大的丑数 = 较小的丑数 * (2/3/5)较大的丑数=较小的丑数∗(2/3/5)，因此使用哈希集合存储丑数，并对每个数遍历判断，如果其因子有 2/3/5，并且除以因子后仍是丑数，则该数是丑数。可惜这种方法超时了，说明还有优化的空间： var nthUglyNumber = function(n){ const set = new Set(); set.add(1); let i = 1; n -= 1; while (n) { ++i; if (!(i % 2) &amp;&amp; set.has(i / 2) || !(i % 3) &amp;&amp; set.has(i / 3) || !(i % 5) &amp;&amp; set.has(i / 5)) { --n; set.add(i); } } return i; }; 法二：动态规划 上面我的思路是对的，但是没想到可以从头开始递推，只需要从 2 开始每次找 2/3/5 的倍数中最小的那一个，就是要找的丑数，可以通过动态规划的方式： 状态定义： dp[i]dp[i]dp[i] 表示第 i+1i + 1i+1 个丑数； 转移方程： dp[i]=min(dp[a]∗2,dp[b]∗3,dp[c]∗5)dp[i] = min(dp[a] * 2, dp[b] * 3, dp[c] * 5)dp[i]=min(dp[a]∗2,dp[b]∗3,dp[c]∗5)，其中 a,b,ca, b, ca,b,c 从 000 开始，并且丑数选择了哪一个，则其对应的索引自增； 初始状态： dp[0]=1dp[0] = 1dp[0]=1； 返回结果： dp[n−1]dp[n - 1]dp[n−1]。 var nthUglyNumber = function(n){ let a = 0, b = 0, c = 0; const dp = []; dp.push(1); for (let i = 1; i &lt; n; ++i) { const n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5; dp[i] = Math.min(Math.min(n2, n3), n5); if (dp[i] === n2) ++a; if (dp[i] === n3) ++b; if (dp[i] === n5) ++c; } return dp[n - 1]; }; 上面的两种方法中： 动态规划的时间复杂度是 O(n)O(n)O(n)，只需要遍历 nnn 个丑数； 一开始我以为我的方法也是 O(n)O(n)O(n) 的时间复杂度，但后来发现应该是 O(k)O(k)O(k)，其中 kkk 表示第 nnn 个丑数，因为需要遍历每个小于 kkk 的数，显然 kkk 是大于 nnn 的，所以导致了超时。 ","link":"https://AriesSK.github.io/post/jianzhi_49/"},{"title":"19. 正则表达式匹配","content":"知识点 JavaScript 正则表达式 与本题无关，记录一下 js 的正则表达式，格式/正则表达式主体/修饰符(可选)。 正则表达式修饰符(不区分大小写) 修饰符 说明 i 不区分大小写 g 全局匹配（不是找到第一个就停止） m 多行匹配 正则表达式模式 表达式 说明 [abc] 查找方括号之间的任何字符 [0-9] 查找任何从 0 到 9 的数字 (x|y) 查找任何以 | 分隔的选项 元字符(拥有特殊含义的字符) 说明 \\d 查找数字 \\s 查找空白字符 \\b 匹配单词边界 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 量词 说明 n+ 匹配任何包括至少一个 n 的字符串 n* 匹配任何包括零个或多个 n 的字符串 n? 匹配任何包括零个或一个 n 的字符串 Tips &quot;.&quot; 在正则表达式中是表示任意一个字符的通配符，若要使用点字符，则应为 &quot;\\.&quot; // 可以通过 RegExp() 将字符串转换为正则表达式，test() 是该对象的一个方法，用于检测字符串中是否匹配某个模式 const s = &quot;a*&quot;, test = &quot;a&quot;; const p = new RegExp(s); console.log(p); // /a*/ console.log(p.test(test)); // true 题解 动态规划 用 dp[i][j]dp[i][j]dp[i][j] 表示 sss 的前 iii 个字符与 ppp 中的前 jjj 个字符是否能够匹配。在进行状态转移时，考虑 ppp 的第 jjj 个字符的匹配情况: 如果 ppp 的第 jjj 个字符是普通字符，那么我们必须在 sss 中匹配一个相同的字符，即 f[i][j]={f[i−1][j−1],s[i]=p[j] false, s[i]≠p[j]f[i][j]= \\begin{cases}f[i-1][j-1], &amp; s[i]=p[j] \\\\ \\text { false, } &amp; s[i] \\neq p[j]\\end{cases} f[i][j]={f[i−1][j−1], false, ​s[i]=p[j]s[i]​=p[j]​ 如果 sss 的第 iii 个字符与 ppp 的第 jjj 个字符不相同，那么无法进行匹配；否则可以匹配，而完整的匹配结果取决于前面的部分。 如果 ppp 的第 jjj 个字符是 ∗*∗ ，在匹配的过程中，本质上只会有两种情况: 匹配 sss 末尾的一个字符，则还可以继续进行匹配，直到无法匹配再将该组合扔掉； 不匹配字符，将该组合视作出现 000 次，扔掉，不再继续匹配。 如上可以写出状态转移方程: f[i][j]={f[i−1][j] or f[i][j−2],s[i]=p[j−1]f[i][j−2],s[i]≠p[j−1]f[i][j]= \\begin{cases}f[i-1][j] \\text { or } f[i][j-2], &amp; s[i]=p[j-1] \\\\ f[i][j-2], &amp; s[i] \\neq p[j-1]\\end{cases} f[i][j]={f[i−1][j] or f[i][j−2],f[i][j−2],​s[i]=p[j−1]s[i]​=p[j−1]​ 在任意情况下，只要 p[j]p[j]p[j] 是 ...，那么 p[j]p[j]p[j] 一定成功匹配 sss 中的任意一个字符。 最终的状态转移方程如下: f[i][j]={ if (p[j]≠∗)={f[i−1][j−1], match (s[i],p[j]) false, otherwise otherwise ={f[i−1][j] or f[i][j−2], match (s[i],p[j−1])f[i][j−2], otherwise f[i][j]= \\begin{cases}\\text { if }\\left(p[j] \\neq{ }^{*}\\right)= \\begin{cases}f[i-1][j-1], &amp; \\text { match }(s[i], p[j]) \\\\ \\text { false, } &amp; \\text { otherwise }\\end{cases} \\\\ \\text { otherwise }= \\begin{cases}f[i-1][j] \\text { or } f[i][j-2], &amp; \\text { match }(s[i], p[j-1]) \\\\ f[i][j-2], &amp; \\text { otherwise }\\end{cases} \\end{cases}f[i][j]=⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​ if (p[j]​=∗)={f[i−1][j−1], false, ​ match (s[i],p[j]) otherwise ​ otherwise ={f[i−1][j] or f[i][j−2],f[i][j−2],​ match (s[i],p[j−1]) otherwise ​​ 其中match(x, y)判断两个字符是否匹配的辅助函数，只有当 yyy 是 ... 或者 xxx 和 yyy 本身相同时，才会返回 truetruetrue。 注意：大部分语言中，字符串的字符下标是从 000 开始的，但本题中 000 用来表示空串而不是第一个元素的下标，因此在实现上面的状态转移方程时，需要注意状态中每一维下标与实际字符下标的对应关系。 var isMatch = function(s, p) { let m = s.length, n = p.length; // 由于 0 表示空串，因此数组的长度需要增加一位 const dp = new Array(m + 1); // 初始化时需要填充 false，因为对于 i 或 j 为 0，也就是空串匹配应当默认无法匹配，代码中不进行赋值，而在 js 中不赋值为 undefined，会影响结果 for (let i = 0; i &lt;= m; ++i) dp[i] = new Array(n + 1).fill(false); // s, p 均为空串，则可以匹配 dp[0][0] = true; for (let i = 0; i &lt;= m; ++i) { for (let j = 1; j &lt;= n; ++j) { if (p.charAt(j - 1) === &quot;*&quot;) { // dp[i - 1][j] 能够匹配则会短路后面的半部分，一直匹配 s 的前一个字符直到完全匹配或无法匹配，无法匹配则扔掉 p 的最后两个字符 if (match(s, p, i, j - 1)) dp[i][j] = dp[i - 1][j] || dp[i][j - 2]; else dp[i][j] = dp[i][j - 2]; } else { if (match(s, p, i, j)) dp[i][j] = dp[i - 1][j - 1]; } } } return dp[m][n]; function match(i, j) { // 需要注意下标与实际字符下标的对应关系 if (!i) return false; if (p.charAt(j - 1) === &quot;.&quot;) return true; return s.charAt(i - 1) === p.charAt(j - 1); } }; ","link":"https://AriesSK.github.io/post/jianzhi_19/"},{"title":"38. 字符串的排列","content":"知识点 Tips 回溯与深度优先搜索的思想不要局限在树、图当中，思维要开阔！ join() // 在未设置参数时，默认以 &quot;,&quot; 分隔 题解 回溯 标准的深度优先搜素，但由于字符可能出现重复的情况，因此需要加入剪枝的操作，使用一个Set()记录已在该位放置过的字符，遇重复时可直接跳过： 本题的深度优先遍历思想是：先固定每一位获取排列的可能，再逐步回溯，考虑每一位的不同可能。简单来说就是当前位固定一个元素后，先不考虑该位的其他可能，尝试固定下一位，在后面的位考虑完后再回溯上来。 var permutation = function(s) { const c = s.split(&quot;&quot;), res = []; dfs(0); return res; function dfs(x) { // 由于最后一位在前一位确定后已经确定，因此直接记录结果并返回 if (x === c.length - 1) { res.push(c.join(&quot;&quot;)); return; } const set = new Set(); // x 指向本轮讨论的位置，i 指向准备放置的字符 for (let i = x; i &lt; c.length; ++i) { // 剪枝 if (set.has(c[i])) continue; set.add(c[i]); swap(x, i); dfs(x + 1); // 注意需要恢复初始排列，保证 dfs 的正确 swap(x, i); } } function swap(a, b) { let tmp = c[a]; c[a] = c[b]; c[b] = tmp; } }; ","link":"https://AriesSK.github.io/post/jianzhi_38/"},{"title":"37. 序列化二叉树","content":"知识点 二叉树的遍历序列 对二叉树的遍历常用的有深度优先遍历的前序遍历、中序遍历、后序遍历以及广度优先遍历的层序遍历，但这些遍历的序列包含的二叉树的信息是不完整的，一个序列可以对应多种可能的二叉树，如果需要完整保存二叉树的信息，则需要将叶子节点之下的 nullnullnull 也记录在序列中，本题就是这种序列的应用。 Tips Number(&quot;null&quot;); // NaN Number(null); // 0 题解 层序遍历 我的解法，我的想法和官方解基本一致，层序遍历一直记录到最后一个叶子节点，并将遍历过程中的 nullnullnull 也记录下来。不过我为了让字符串和示例的一致，将最后一个节点之后的 nullnullnull 全部删除了，这会导致在反序列化的过程中对于最后一个父节点无右孩子的情况容易出错，需要添加额外判断： var serialize = function(root) { if (!root) return &quot;&quot;; const res = [], queue = []; queue.push(root); while (queue.length) { const tmp = queue.shift(); if (tmp) { res.push(tmp.val); queue.push(tmp.left); queue.push(tmp.right); } else res.push(&quot;null&quot;); // 如果是 null 的话转化为最终拼接时字符串会变成 &quot;&quot; } for (let i = res.length - 1; i &gt;= 0; --i) { // 删除最后一个节点后多余的 null if (res[i] !== &quot;null&quot;) break; res.pop(); } return res.join(&quot;,&quot;); }; var deserialize = function(data) { if (data === &quot;&quot;) return null; // 注意这里是返回 null 而不是 [] const arr = data.split(&quot;,&quot;), queue = []; const root = new TreeNode(Number(arr.shift())); queue.push(root); while (arr.length) { const tmp = queue.shift(); const left = arr.shift(); if (left !== &quot;null&quot;) { tmp.left = new TreeNode(Number(left)); queue.push(tmp.left); } if (arr.length) { // 最后一个父节点可能没有右孩子导致出错，额外判断 const right = arr.shift(); if (right !== &quot;null&quot;) { tmp.right = new TreeNode(Number(right)); queue.push(tmp.right); } } } return root; }; 如果序列化的时候不删除序列末尾的 nullnullnull 则还可以简化部分代码。 ","link":"https://AriesSK.github.io/post/jianzhi_37/"},{"title":"59 - II. 队列的最大值","content":"知识点 JavaScript 的函数与方法 函数(function)与方法(methods)本质上相同。方法是函数的特例，将函数值赋给对象的属性。可以说对象里的函数是方法。 JavaScript 的this关键字 js 中的this会随着执行环境的改变而改变： 在方法中，this表示该方法所属的对象； 单独使用，this表示全局对象； 在函数中，this表示全局对象； 在函数中，在严格模式下，this是 undefinedundefinedundefined； 在事件中，this表示接收事件的元素； 类似call()和apply()方法可以将this引用到任何对象。 题解 单调队列 与59 - I. 滑动窗口的最大值的思想一致，维护一个辅助的非严格递减的单调队列即可： var MaxQueue = function() { this.queue = []; this.max_queue = []; }; /** * @return {number} */ MaxQueue.prototype.max_value = function() { return this.queue.length ? this.max_queue[0] : -1; }; /** * @param {number} value * @return {void} */ MaxQueue.prototype.push_back = function(value) { this.queue.push(value); while (this.max_queue.length &amp;&amp; this.max_queue[this.max_queue.length - 1] &lt; value) this.max_queue.pop(); this.max_queue.push(value); }; /** * @return {number} */ MaxQueue.prototype.pop_front = function() { if (this.max_queue[0] === this.queue[0]) this.max_queue.shift(); if (!this.queue.length) return -1; return this.queue.shift(); }; ","link":"https://AriesSK.github.io/post/jianzhi_59_ii/"},{"title":"59 - I.滑动窗口的最大值","content":"知识点 JavaScript 中的最值 特别要注意的是MIN_VALUE是极小的正数： Number.MAX_VALUE // 1.7976931348623157e+308 Number.MIN_VALUE // 5e-324 注意这是一个无限接近零的 正数 Number.MAX_SAFE_INTEGER // 2^53 - 1 Number.MIN_SAFE_INTEGER // -(2^53 - 1) 这是负数 如果需要负数可以使用： -Number.MAX_VALUE 题解 法一：暴力 时间复杂度是 O(nk)O(nk)O(nk)，主要问题就是窗口移动时被移除的元素可能就是窗口中的唯一最大值，因此每次都得在窗口中重新遍历获取最大值： var maxSlidingWindow = function(nums, k) { if (!nums.length) return []; const res = []; for (let i = 0; i &lt;= nums.length - k; ++i) { let max = -Number.MAX_VALUE; for (let j = 0; j &lt; k; ++j) { max = Math.max(max, nums[i + j]); } res.push(max); } return res; }; 法二：单调队列 这道题是可以优化到线性时间复杂度 O(n)O(n)O(n) 的，需要用到单调队列（单调递减或递增的队列），在遍历数组的时候维护一个非严格递减的单调队列，队列中仅包含当前窗口内的元素，但不必包含当前窗口内的所有元素： var maxSlidingWindow = function(nums, k) { if (!nums.length) return []; const res = [], queue = []; // 构建初始的单调队列，保存第一个窗口中的一个递减序列 for (let i = 0; i &lt; k; ++i) { while (queue.length &amp;&amp; queue[queue.length - 1] &lt; nums[i]) queue.pop(); queue.push(nums[i]); } res.push(queue[0]); // for (let j = k; j &lt; nums.length; ++j) { // 如果队首是这一轮窗口需要移除的元素，则将其出队，以保证队列中只有当前窗口元素 // nums[j - k] 表示本轮需要移除的元素，如果不等于队首，说明该元素已被队列移除 if (queue[0] === nums[j - k]) queue.shift(); while (queue.length &amp;&amp; queue[queue.length - 1] &lt; nums[j]) queue.pop(); queue.push(nums[j]); res.push(queue[0]); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_59_i/"},{"title":"67. 把字符串转换为整数","content":"知识点 JavaScript 的幂运算 js 中的**表示幂运算，等同于`Math.pow()。 判断字符是否是数字字符 if (s &lt;= '9' &amp;&amp; s &gt;= '0') return true; if (s &gt; '9' || s &lt; '0') return false; 题解 遍历 遍历字符串的每个字符，每个字符的可能情况和处理如下： 若是空格，继续遍历； 若是 +++ 或 −-−，记录并继续遍历； 若是非数字字符，结束遍历； 若是数字字符，转为数字并计入结果（js 中一元运算符的+能进行类型转换）。 若最终结果超题目要求范围，按题目要求返回值即可，因为不会超过 js 的数字表示范围。 var strToInt = function(str) { let res = 0, i = 0, s = 1; if (!str.length) return 0; while (str.charAt(i) === &quot; &quot;) { if (i === str.length) return 0; ++i; } if (str.charAt(i) === '-') s = -1; if (str.charAt(i) === '+' || str.charAt(i) === '-') ++i; for (let j = i; j &lt; str.length; ++j) { if (str.charAt(j) &gt; '9' || str.charAt(j) &lt; '0') break; res = res * 10 + +str.charAt(j); } return s === 1 ? Math.min(res, 2**31 - 1) : Math.max(-res, -(2**31)); }; ","link":"https://AriesSK.github.io/post/jianzhi_67/"},{"title":"20. 表示数值的字符串","content":"知识点 有限状态自动机 定义状态； 画出状态转移图； 编写代码（利用数组和哈希表存储状态转移表）。 题解 最开始利用 js 自身的特性写了一种抖机灵的解法，仅供一乐： var isNumber = function(s) { if(s.trim() === &quot;&quot;) return false; return !isNaN(Number(s)); }; 有限状态自动机 这道题的正统解法还是有限状态自动机： var isNumber = function(s) { // 使用数组存储自动机的九种状态，使用哈希表存储状态转移表 const states = [ new Map([[' ', 0], ['s', 1], ['d', 2], ['.', 4]]), new Map([['d', 2], ['.', 4]]), new Map([['d', 2], ['.', 3], ['e', 5], [' ', 8]]), new Map([['d', 3], ['e', 5], [' ', 8]]), new Map([['d', 3]]), new Map([['s', 6], ['d', 7]]), new Map([['d', 7]]), new Map([['d', 7], [' ', 8]]), new Map([[' ', 8]]) ]; // p 为当前状态， t 为字符类型 let p = 0, t; for (let c of s.split('')) { if (c &gt;= '0' &amp;&amp; c &lt;= '9') t = 'd'; else if (c === '+' || c === '-') t = 's'; else if (c === 'e' || c === 'E') t = 'e'; else if (c === '.' || c === ' ') t = c; else t = '?'; // 无法转移至下一个状态，返回 false if (!states[p].has(t)) return false; p = states[p].get(t); } // 四种合法的结束状态 return p === 2 || p === 3 || p === 7 || p === 8; }; ","link":"https://AriesSK.github.io/post/jianzhi_20/"},{"title":"31. 栈的压入、弹出序列","content":"知识点 快速判断出栈序列是否合法 对于出栈序列中的每个元素，所有在它后面出栈的但比它先入栈的元素，其出栈顺序必定与入栈顺序相反。因为比它先入栈的元素要不先于它出栈，要不还在栈中，而在栈中则必定先进后出。 这种判定方法在适用于选择题中的快速判断，特别在入栈元素是递增时，只需要判断出栈序列中每个元素后面比它小的元素有没有遵循递减排列即可，不过在算法中复杂度比较高。 题解 模拟 使用一个辅助栈来模拟操作，看看能否模拟成功： var validateStackSequences = function(pushed, popped) { const stack = []; let i = 0; for (num of pushed) { // 按入栈顺序入栈 stack.push(num); // 每次入栈后判断，将符合出栈顺序的元素全部出栈 while (stack.length &amp;&amp; stack[stack.length - 1] === popped[i]) { stack.pop(); ++i; } } // 最终栈为空返回 true return !stack.length; }; ","link":"https://AriesSK.github.io/post/jianzhi_31/"},{"title":"29. 顺时针打印矩阵","content":"知识点 JavaScript 二维数组声明的坑 如下声明数组，然后更改第一行第一列的元素，发现居然第一列的元素都被改了，这是由于第一个fill()创建的三个Array()对象指向同一个内存地址，类似浅拷贝，因此修改其中一个就会同时变更其余的： const flag = new Array(3).fill(new Array(3).fill(0)); flag[0][0] = 1; console.log(flag); // [[1,0,0],[1,0,0],[1,0,0]] 所以js里声明二维数组还是老老实实用循环吧： const flag = new Array(3); for (let i = 0; i &lt; n; ++i) flag[i] = new Array(3).fill(0); 题解 错误解法 我的开始的错误想法是通过递归的方式，遵循右下左上的顺序遍历，但后来发现在应当向上遍历的过程中由于向右的优先级更高，会在后段遍历出现顺序的错误： var spiralOrder = function(matrix) { if (!matrix.length) return matrix; const m = matrix.length, n = matrix[0].length; const res = []; const flag = new Array(m); for (let i = 0; i &lt; m; ++i) flag[i] = new Array(n).fill(0); print(0, 0); return res; function print(i, j) { if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || flag[i][j]) return; res.push(matrix[i][j]); flag[i][j] = 1; print(i, j + 1); print(i + 1, j); print(i, j - 1); print(i - 1, j); }; }; 模拟 + 设定边界 顺时针打印矩阵的顺序是“从左向右、从上向下、从右向左、从下向上”循环，因此，设定矩阵的“左、上、右、下”四个边界，模拟以上矩阵遍历顺序。 对四个方向进行循环打印，每个方向步骤为： 根据边界顺序打印元素； 边界向内收缩 111，表示已被打印； 判断打印是否完成，即边界是否相遇，相遇则跳出。 var spiralOrder = function(matrix) { if (!matrix.length) return matrix; let l = 0, r = matrix[0].length - 1, t = 0, b = matrix.length - 1; const res = []; while (true) { for (let i = l; i &lt;= r; ++i) res.push(matrix[t][i]); if (++t &gt; b) break; for (let i = t; i &lt;= b; ++i) res.push(matrix[i][r]); if (--r &lt; l) break; for (let i = r; i &gt;= l; --i) res.push(matrix[b][i]); if (--b &lt; t) break; for (let i = b; i &gt;= t; --i) res.push(matrix[i][l]); if (++l &gt; r) break; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_29/"},{"title":"62. 圆圈中最后剩下的数字","content":"知识点 约瑟夫环 这道题是经典的约瑟夫环问题，其推导过程如下： 对于 ⌈n,m\\lceil n, m⌈n,m 问题」，首轮删除环中第 mmm 个数字后，得到一个长度为 n−1n-1n−1 的数字环。由于有可能 m&gt;m&gt;m&gt; nnn ，因此删除的数字为 (m−1)%n(m-1) \\% n(m−1)%n ，删除后的数字环从下个数字（即 m%n)m \\% n)m%n) 开始，设 t=m%nt=m \\% nt=m%n ，可 得数字环： t,t+1,t+2,…,0,1,…,t−3,t−2t, t+1, t+2, \\ldots, 0,1, \\ldots, t-3, t-2 t,t+1,t+2,…,0,1,…,t−3,t−2 删除一轮后的数字环也变为一个 ⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」，观察以下数字编号对应关系，这里的等价替换是本题的精华部分，就是将一个⌈n,m\\lceil n, m⌈n,m 问题」用一个改变起点的⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」等价替换： ⌈n−1,m 问题」→⌈n,m 问题」删除后 0→t+01→t+1…→…n−2→t−2\\begin{array}{rlr} \\lceil n-1, m \\text { 问题」} &amp; \\rightarrow &amp; \\lceil n, m \\text { 问题」删除后 } \\\\ 0 &amp; \\rightarrow &amp; t+0 \\\\ 1 &amp; \\rightarrow &amp; t+1 \\\\ \\ldots &amp; \\rightarrow &amp; \\ldots \\\\ n-2 &amp; \\rightarrow &amp; t-2 \\end{array} ⌈n−1,m 问题」01…n−2​→→→→→​⌈n,m 问题」删除后 t+0t+1…t−2​ 设 ⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」某数字为 xxx ，则可得递推关系: x→(x+t)%nx \\rightarrow(x+t) \\% n x→(x+t)%n 比如下图中⌈4,3\\lceil 4, 3⌈4,3 问题」的第 000 位实际上是⌈5,3\\lceil 5, 3⌈5,3 问题」的第 0+30 + 30+3 位。 换而言之，若已知 ⌈n−1,m\\lceil n-1, m⌈n−1,m 问题」的解 f(n−1)f(n-1)f(n−1) ，则可通过以上公式计算得到 ⌈n,m\\lceil n, m⌈n,m 问题」的解 f(n)f(n)f(n) ，即: f(n)=(f(n−1)+t)%n=(f(n−1)+m%n)%n=(f(n−1)+m)%n\\begin{aligned} f(n) &amp;=(f(n-1)+t) \\% n \\\\ &amp;=(f(n-1)+m \\% n) \\% n \\\\ &amp;=(f(n-1)+m) \\% n \\end{aligned} f(n)​=(f(n−1)+t)%n=(f(n−1)+m%n)%n=(f(n−1)+m)%n​ 题解 动态规划 我的思路是构建链表来模拟删除过程，但是其时间复杂度是 O(nm)O(nm)O(nm)，这是不可接受的，这道题的正确解法应当是动态规划： 状态定义： dp[i]dp[i]dp[i] 表示 ⌈i,m\\lceil i, m⌈i,m 问题」的解； 转移方程： dp[i]=(dp[i−1]+m)%idp[i] = (dp[i - 1] + m) \\% idp[i]=(dp[i−1]+m)%i； 初始状态： dp[1]=0dp[1] = 0dp[1]=0 ； 返回结果： dp[n]dp[n]dp[n]。 var lastRemaining = function(n, m) { // x 代表最终被剩下的元素在上一级数组中的下标 let x = 0; for (let i = 2; i &lt;= n; ++i) x = (x + m) % i; return x; }; ","link":"https://AriesSK.github.io/post/jianzhi_62/"},{"title":"57 - II. 和为s的连续正数序列","content":"知识点 滑动窗口 滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。 滑动窗口的重要性质是：窗口的左边界和右边界永远只能向右移动，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)O(n)O(n)。 题解 法一：暴力 + 二分 我的思路是start从 111 开始枚举，end通过二分法查找，通过求和公式判断是否为 targettargettarget： var findContinuousSequence = function(target) { const res = []; for (let start = 1; start &lt;= target &gt;&gt; 1; ++start) { let l = start, r = (target &gt;&gt; 1) + 1; while(l &lt;= r) { const end = (l + r) &gt;&gt; 1; if (sum(start, end) === target) { const tmp = []; for (let i = start; i &lt;= end; ++i) tmp.push(i); res.push(tmp); break; } if (sum(start, end) &lt; target) l = end + 1; else r = end - 1; } } return res; }; var sum = function(start, end) { return (start + end) * (end - start + 1) / 2; } 法二：暴力 + 数学优化 上面的方法可以使用数学方法优化，减免查找end的时间复杂度： 我们在知道起点 xxx 和终点 yyy ，那么 xxx 累加到 yyy 的和由求和公式可以知道是 (x+y)×(y−x+1)2\\frac{(x+y) \\times(y-x+1)}{2}2(x+y)×(y−x+1)​ ，那 么问题就转化为了是否存在一个正整数 y(y&gt;x)y(y&gt;x)y(y&gt;x) ，满足等式 (x+y)×(y−x+1)2= target \\frac{(x+y) \\times(y-x+1)}{2}=\\text { target } 2(x+y)×(y−x+1)​= target 转化一下变成 y2+y−x2+x−2× target =0y^{2}+y-x^{2}+x-2 \\times \\text { target }=0 y2+y−x2+x−2× target =0 这是一个关于 yyy 的一元二次方程，其中 a=1,b=1,c=−x2+x−2×a=1, b=1, c=-x^{2}+x-2 \\timesa=1,b=1,c=−x2+x−2× target 直接套用求根公式即可 O(1)O(1)O(1) 解得 yyy ，判断是否整数解需要满足两个条件: 判别式 b2−4acb^{2}-4 a cb2−4ac 开根需要为整数； 最后的求根公式的分子需要为偶数，因为分母为 222。 var findContinuousSequence = function(target) { const res = []; for (let start = 1; start &lt;= target &gt;&gt; 1; ++start) { let delta = 1 - 4 * (start - start * start - 2 * target); if (delta &lt; 0) continue; let sqrt = Math.sqrt(delta); if ((sqrt - 1) % 2 === 0) { let end = (sqrt - 1) / 2; const tmp = []; for (let i = start; i &lt;= end; ++i) tmp.push(i); res.push(tmp); } } return res; }; 法三：滑动窗口（双指针） 这道题是滑动窗口的典型应用，因为两边界只需要向右移动即可找到所有解： var findContinuousSequence = function(target) { let l = 1, r = 2, sum = 3; const res = []; while(l &lt; r) { if (sum === target) { const tmp = []; for (let i = l; i &lt;= r; ++i) tmp.push(i); res.push(tmp); } // 为了找到所有解，不论什么情况都需要移动一侧边界 if (sum &gt;= target) { sum -= l; ++l; } else { ++r; sum += r; } } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_57_ii/"},{"title":"14 - I.剪绳子 I","content":"知识点 数学推导 推论一：将绳子 以相等的长度等分为多段，得到的乘积最大。 以下公式为算术几何均值不等式，等号当且仅当 n1=n2=…=nan_{1}=n_{2}=\\ldots=n_{a}n1​=n2​=…=na​ 时成立。 n1+n2+…+naa≥n1n2…naa\\frac{n_{1}+n_{2}+\\ldots+n_{a}}{a} \\geq \\sqrt[a]{n_{1} n_{2} \\ldots n_{a}} an1​+n2​+…+na​​≥an1​n2​…na​​ 推论二：尽可能将绳子以长度 3 等分为多段时，乘积最大。 设将绳子按照 xxx 长度等分为 aaa 段，即 n=axn=a xn=ax ，则乘积为 xax^{a}xa 。观察以下公式，由于 nnn 为常数 因此当 x1xx \\frac{1}{x}xx1​ 取最大值时， 乘积达到最大值。 xa=xnx=(x1x)nx^{a}=x^{\\frac{n}{x}}=\\left(x^{\\frac{1}{x}}\\right)^{n} xa=xxn​=(xx1​)n 根据分析，可将问题转化为求 y=x1xy=x \\frac{1}{x}y=xx1​ 的极大值，因此对 xxx 求导数。 ln⁡y=1xln⁡x 取对数 1yy˙=1x2−1x2ln⁡x 对 x 求导 =1−ln⁡xx2y˙=1−ln⁡xx2x 整理得 \\begin{array}{rlr} \\ln y &amp; =\\frac{1}{x} \\ln x &amp; \\text { 取对数 } \\\\ \\frac{1}{y} \\dot{y} &amp; =\\frac{1}{x^{2}}-\\frac{1}{x^{2}} \\ln x &amp; \\text { 对 } x \\text { 求导 } \\\\ &amp; =\\frac{1-\\ln x}{x^{2}} &amp; \\\\ \\dot{y} &amp; =\\frac{1-\\ln x}{x^{2}} x &amp; \\text { 整理得 } \\end{array} lnyy1​y˙​y˙​​=x1​lnx=x21​−x21​lnx=x21−lnx​=x21−lnx​x​ 取对数 对 x 求导 整理得 ​ 令 y˙=0\\dot{y}=0y˙​=0 ，则 1−ln⁡x=01-\\ln x=01−lnx=0 ，易得驻点为 x0=e≈2.7x_{0}=e \\approx 2.7x0​=e≈2.7 ；根据以下公式，可知 x0x_{0}x0​ 为极大值点。 y˙{&gt;0,x∈[−∞,e)&lt;0,x∈(e,∞]\\dot{y} \\begin{cases}&gt;0 &amp; , x \\in[-\\infty, e) \\\\ &lt;0 &amp; , x \\in(e, \\infty]\\end{cases} y˙​{&gt;0&lt;0​,x∈[−∞,e),x∈(e,∞]​ 由于切分长度 xxx 必须为整数，最接近 eee 的整数为 2 或 3 。如下式所示，代入 x=2x=2x=2 和 x=3x=3x=3 ， 得出 x=3x=3x=3 时，乘积达到最大。 y(3)=31/3≈1.44y(2)=21/2≈1.41\\begin{aligned} &amp;y(3)=3^{1 / 3} \\approx 1.44 \\\\ &amp;y(2)=2^{1 / 2} \\approx 1.41 \\end{aligned} ​y(3)=31/3≈1.44y(2)=21/2≈1.41​ 题解 法一：数学 这种方法时空复杂度均为 O(1)O(1)O(1)，根据数学方法可以获得推论： 所有绳段长度相等时乘积最大； 每段的最优长度为 333。 从而得出切分规则： 最优：333。把绳子尽可能切为多个长度为 333 的片段，留下的最后一段绳子的长度可能为 0,1,20,1,20,1,2 三种情况； 次优：222。若最后一段绳子长度为 222；则保留，不再拆分； 最差：111。若最后一段绳子长度为 111；则应把一份 3+13 + 13+1 替换为 2+22 + 22+2，因为 2×2&gt;3×12 \\times 2 &gt; 3 \\times 12×2&gt;3×1。 var cuttingRope = function(n) { if (n &lt;= 3) return n - 1; // 注意 js 中因为不分整型和浮点型 因此不是整除 let a = Math.floor(n / 3), b = n % 3; if (b === 0) return Math.pow(3, a); if (b === 1) return Math.pow(3, a - 1) * 4; return Math.pow(3, a) * 2; }; 法二：动态规划 状态定义： dp[i]dp[i]dp[i] 表示将长度为 iii 的绳子剪成至少两段绳子之后，这些绳子长度的最大乘积； 转移方程： 当 i≥2i \\geq 2i≥2 时，假设对长度为 iii 绳子剪出的第一段绳子长度是 j(1≤j&lt;i)j(1 \\leq j&lt;i)j(1≤j&lt;i)，其中 jjj 的需要对每个值进行遍历，则有以下两种方案： 将 iii 剪成 jjj 和 i−ji - ji−j 长度的绳子，且 i−ji - ji−j 不再继续剪，此时的乘积是 j×(i−j)j \\times (i - j)j×(i−j)； 将 iii 剪成 jjj 和 i−ji-ji−j 长度的绳子，且 i−ji-ji−j 继续剪成多段长度的绳子，此时的乘积是 j×dp[i−j]j \\times d p[i-j]j×dp[i−j]； 因此有 dp[i]=max⁡(dp[i],max⁡(j×(i−j),j×dp[i−j]))dp[i] = \\max (dp[i], \\max (j \\times(i - j), j \\times dp[i-j]))dp[i]=max(dp[i],max(j×(i−j),j×dp[i−j])) 。 初始状态： dp[1]=1dp[1] = 1dp[1]=1 ； 返回结果： dp[n]dp[n]dp[n]。 var cuttingRope = function(n) { const dp = new Array(n + 1).fill(0); dp[1] = 1; for (let i = 2; i &lt;= n; ++i) { // dp[i] 记录所有 j 取值中最大的那个 for (let j = 1; j &lt; i; ++j) dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[i - j] * j)); } return dp[n]; }; ","link":"https://AriesSK.github.io/post/jianzhi_14_i/"},{"title":"66. 构建乘积数组","content":"知识点 需要对学过的算法思想学以致用！ 题解 动态规划思想 看到这题我的第一想法就是先遍历数组获取所有元素的乘积，然后每次除其中一个数，获取结果。但这种方法要求数组中不出现 000，而且题目要求了不能使用除法。 事实上，看到这种后一个状态计算与前一个有关的题目，第一时间要想到动态规划，这题的思路就是左右两个 dpdpdp，分别存储下标 iii 左右的数字的累乘结果。 在这道题中两个 dpdpdp 还能使用输出数组替代以降低空间复杂度，由于当前状态只与前一个的状态相关，因此只需要使用一个tmp来存储中间结果即可（逆向的时候）。 var constructArr = function(a) { if (!a.length) return a; const b = new Array(a.length); b[0] = 1; for (let i = 1; i &lt; a.length; ++i) b[i] = b[i - 1] * a[i - 1]; let tmp = 1; for (let j = a.length - 2; j &gt;= 0; --j) { tmp *= a[j + 1]; b[j] *= tmp; } return b; }; ","link":"https://AriesSK.github.io/post/jianzhi_66/"},{"title":"39. 数组中出现次数超过一半的数字","content":"知识点 JavaScript 的Map() Set()和Map()的 keykeykey都是不能重复的，在Map()中重复赋值会覆盖之前的： const map = new Map(); map.set(&quot;name&quot;, &quot;Aries&quot;); map.set(&quot;name&quot;, &quot;AriesSK&quot;); console.log(map); // {&quot;name&quot; =&gt; &quot;AriesSK&quot;} keykeykey 可以不声明，valuevaluevalue不行： const map = new Map(); map.set(name, &quot;Aries&quot;); map.set(name, &quot;AriesSK&quot;); console.log(map); // {&quot;&quot; =&gt; &quot;AriesSK&quot;} const map = new Map(); map.set(name, Aries); map.set(name, AriesSK); console.log(map); // undefined 题解 法一：哈希表 遍历数组，同时用哈希表记录每个数的出现次数，发现超过数组长度一半的直接返回结果： var majorityElement = function(nums) { const map = new Map(); for (const num of nums) { if (map.has(num)) map.set(num, map.get(num) + 1); else map.set(num, 1); if (map.get(num) * 2 &gt; nums.length) return num; } }; 法二：排序 对数组排序，数组中间的数一定是所求数，这里不管怎么排序，只要能让相同的数排在一起，就能输出正确的结果： var majorityElement = function(nums) { //nums.sort(); 这样写是默认按字母升序的，比如 40 会排在 5 前面，不过本题不影响结果 nums.sort((a, b) =&gt; a - b); // 正确的按数字升序 return nums[nums.length &gt;&gt; 1]; }; 法三：摩尔投票法 本题的最优解法，时间复杂度 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1)，其核心思想是票数抵消，票多者胜，拟将超过一半的数称为众数： 由于众数占据超过数组的一半，设其票数为 +1+1+1，其余数票数为 −1-1−1，则票数和为正； 若前几个数字票数和为 000，则剩余数字票数和仍为正，且众数不变。 因此每次设区间的第一个数 xxx 为众数，遍历到出现票数和为 000 的情况，不论 xxx 是不是真正的众数 yyy，在票数和为 000 的区间内，yyy 的出现次数最多占据一半，因此剩余元素中 yyy 仍占据超过一半，因此以此不断缩小空间至遍历完数组，输出最后一个假设数 xxx。 简单来说，不论是众数与非众数对拼消耗还是非众数内部消耗，剩余的数里一定是众数占优： var majorityElement = function(nums) { let vote = 0, res = 0; for (const num of nums) { if (!vote) res = num; vote += num === res ? 1 : -1; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_39/"},{"title":"56 - II. 数组中数字出现的次数 II","content":"知识点 JavaScript 声明特定长度的数组 注意在声明数字数组时一定要记得初始化值，否则会出错： const arr = new Array(5); for (let i = 0; i &lt; 5; ++i) arr[i] += 1; // [NaN, NaN, NaN, NaN, NaN] const arr = new Array(5).fill(0); for (let i = 0; i &lt; 5; ++i) arr[i] += 1; // [1, 1, 1, 1, 1] 位运算获取每一位和为每一位赋值 获取每一位： for (let i = 0; i &lt; 32; ++i) { res[i] += num &amp; 1; // 1 &amp; 0(1) === 0(1) num &gt;&gt;&gt;= 1; } 为每一位赋值： for (let j = 31; j &gt;= 0; --j) { res &lt;&lt;= 1; res |= counts[j] % 3; // 0 | 0(1) === 0(1) } 题解 遍历 + 位运算 这道题没要求空间复杂度，可以使用哈希表，但还有更好的方法： 遍历数组每一个数的每一位，统计每一位 111 出现的次数，对 333 求余后获得所求数： var singleNumber = function(nums) { const counts = new Array(32).fill(0); for (num of nums) { for (let i = 0; i &lt; 32; ++i) { // 每次 &amp; 1 并且右移的操作能够获取 num 的每一位 counts[i] += num &amp; 1; num &gt;&gt;&gt;= 1; } } let res = 0; for (let j = 31; j &gt;= 0; --j) { // 每次左移并且 | 的操作能够为 res 的每一位赋值 res &lt;&lt;= 1; res |= counts[j] % 3; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_56_ii/"},{"title":"56 - I. 数组中数字出现的次数 I","content":"知识点 异或寻找只出现一次的数字 如果数组中只有一个数组出现了一次，其余的都出现了两次，那么解决方法就很简单，只需要对整个数组进行异或运算，成对的数字会两两抵消，剩下的最终结果就是想要找的数字。 题解 分组异或 这道题的难点在于限制了时间复杂度和空间复杂度，所以暴力和哈希都不能使用，并且只出现一次的数字变成了两个，因此无法直接使用异或运算获得结果，需要进行分组，分组目标是： 成对的数字分在同一组； 只出现一次的数字分在不同组。 因此解决方法是： 使用a，b代表两个分组的异或结果，c代表整个数组的异或结果（实际上就是所求两个数字的异或结果）； 使用初始为 111，每次左移一位的tmp与c进行与运算，找到c的第一个为 111的位，这一位是两个数不同的位，以该位为标准将数组划分为两部分，达到分组目标； 两组分别异或，输出结果。 var singleNumbers = function(nums) { let a = 0, b = 0, c = 0, tmp = 1; for (num of nums) c ^= num; // 一元运算符 ! 的优先级仅次于括号 while (!(c &amp; tmp)) tmp &lt;&lt;= 1; for (num of nums) { if (num &amp; tmp) a ^= num; else b ^= num; } return [a, b]; }; ","link":"https://AriesSK.github.io/post/jianzhi_56_i/"},{"title":"65. 不用加减乘除做加法","content":"知识点 位运算替代加法 假设 aaa、bbb的无进位和为 nnn，进位为 ccc，则普通的加法 s=a+bs = a + bs=a+b 可以转化为 s=n+cs = n + cs=n+c。 题解 位运算 观察 aaa，bbb 的无进位和与进位： a(i) b(i) n(i) c(i + 1) 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 根据上表可以发现无进位和和异或运算规律相同，进位和与运算规律相同（需左移一位），由于加上进位后可能出现新的进位，因此需要一直循环直到进位为 000。 递归： var add = function(a, b) { if (!b) return a; return add(a ^ b, (a &amp; b) &lt;&lt; 1); }; 循环： var add = function(a, b) { while (b) { let c = (a &amp; b) &lt;&lt; 1; a ^= b; // a 始终保存当前和 b = c; // b 始终保存进位 } return a; } ","link":"https://AriesSK.github.io/post/jianzhi_65/"},{"title":"15. 二进制中1的个数","content":"知识点 JavaScript 的位运算 运算符 名称 描述 &amp; 按位与 均为 1 返回 1 | 按位或 有一个为 1 返回1 ^ 按位异或 值不同返回 1 ~ 按位非 反转 &lt;&lt; 左移 左移一位，右边填充 0 &gt;&gt; 有符号右移 右移一位，左边填充符号位的值 &gt;&gt;&gt; 无符号右移 右移一位，左边填充 0 题解 按位与 按位与 111，常用于判断奇偶，时间复杂度 O(logn)O(logn)O(logn)，nnn 的二进制位数为 lognlognlogn： var hammingWeight = function(n) { let count = 0; for (let i = 0; i &lt; 32; ++i) { // while (n) { if (n &amp; 1) ++count; n &gt;&gt;&gt;= 1; } return count; }; 巧用 n &amp; (n - 1)，时间复杂度 O(logn)O(logn)O(logn)，nnn 的二进制位数为 lognlognlogn： n−1n - 1n−1 相对于 nnn，最右边的 111 变为 000，此 111 右侧均变为 000； 因此n &amp; (n - 1)起到的作用就是每次消去最右边的 111。 var hammingWeight = function(n) { let count = 0; while (n) { n &amp;= (n - 1); ++count; } return count; }; ","link":"https://AriesSK.github.io/post/jianzhi_15/"},{"title":"33. 二叉搜索树的后序遍历序列","content":"知识点 树的先序、中序、后序遍历序列 对于此类题目： 首先要了解其根、左子树、右子树的在数组中的区间划分； 其次根据题意找出对单个区间的操作； 对每个区间递归处理。 题解 法一：递归分治 每判断一个都需要遍历数组区间，时间复杂度 O(n2)O(n^2)O(n2)。 判断是否是二叉搜索树的后序遍历： 首先在数组区间中的最后一个节点是该树（子树）的根节点； 随后根据根节点判断数组剩余是否分成了小于根节点和大于根节点两部分，并且小于部分位于大于部分左侧； 递归判断每一子树的正确性。 var verifyPostorder = function(postorder) { return dfs(postorder, 0, postorder.length - 1); function dfs(postorder, l, r) { // 超过叶子节点，返回 true if (l &gt; r) return true; // 从区间左侧开始遍历 let i = l; // 找到第一个大于等于根节点的数，可以保证其左侧是小于部分 while (postorder[i] &lt; postorder[r]) ++i; let m = i; // 判断其及其右侧是否是大于部分 while (postorder[i] &gt; postorder[r]) ++i; return i === r &amp;&amp; dfs(postorder, l, m - 1) &amp;&amp; dfs(postorder, m, r - 1); }; }; 法二：栈 使用栈将遍历过的节点储存起来，当遇到递减的节点时，栈中最底下也是值最小的那个是它的父节点（递增才入栈，递减就出栈至空栈，栈底元素值最接近）。 var verifyPostorder = function(postorder) { const stack = []; // 设置初始根节点，值为无限大，原根节点视作其左节点 let root = Number.MAX_VALUE; // 将`preorder`倒序，入栈遍历的元素 for (let i = postorder.length - 1; i &gt;= 0; --i) { // 遍历发现左子树有元素比根节点大，返回 false if (postorder[i] &gt; root) return false; // 发现递减元素，出栈至空，更新 root while (stack.length &amp;&amp; stack[stack.length - 1] &gt; postorder[i]) root = stack.pop(); stack.push(postorder[i]); } // 遍历完毕，均满足规则，返回 true return true; }; ","link":"https://AriesSK.github.io/post/jianzhi_33/"},{"title":"16. 数组的整数次方","content":"知识点 JavaScript 的位移运算 &gt;&gt; // 有符号位移，右移一位，左边补符号位的值，0 正 1 负 &gt;&gt;&gt; // 无符号位移，右移一位，左边补 0 js 中的向下取整往往可以使用&gt;&gt;来实现： 2 &gt;&gt; 1; // 1 3 &gt;&gt; 1; // 1 -3 &gt;&gt; 1; // -2 本题中需要判断奇偶的操作： if (n % 2) (n - 1) / 2; else n / 2; 可以直接简化成： n &gt;&gt; 1; JavaScript 的整数范围 js 符号整数范围 [−231,231−1][-2^{31}, 2^{31}-1][−231,231−1]，即 [-2147483648, 2147483647]，当值为 2147483648 时超出了有符号整数的范围，js 会自动转换为无符号整数。 无符号整数因为多一位数用来保存值，因此范围更大。 对于正数来说，使用&gt;&gt;和&gt;&gt;&gt;效果是一致的，由于本题法三中有测试用例会溢出并转为无符号整数，因此需要使用&gt;&gt;&gt;。 JavaScript 的取余运算 常见的判断奇偶是使用取余运算n % 2，然而用位运算n &amp; 1也可以实现，并且位运算是底层运算，速度较快。 &amp;位运算是在两个数相同位上均为 1 才返回 1，否则返回 0，因此n &amp; 1就能够判断最右一位是否为 1，n &amp; 1返回 1 表示奇数，返回 0 表示偶数。 题解 法一：暴力 一秒能想到的思路，明显会超时，舍弃： var myPow = function(x, n) { let res = 1; if (n &gt;= 0) { while (n--) res *= x; } else { while (n++) res /= x; } return res; }; 法二：快速幂 + 递归 分治思路，每次减半，时间复杂度 O(logn)O(logn)O(logn)，由于递归函数会调用栈空间，因此空间复杂度为 O(logn)O(logn)O(logn)： var myPow = function(x, n) { let tmp = 0; // 存放计算结果，避免重复计算 if (n === 0) return 1; if (n === 1) return x; if (n === -1) return 1 / x; // 不论奇偶均向下取整 奇数多乘一次本身 if (n % 2) { tmp = myPow(x, (n - 1) / 2); // n &gt;&gt; 1 return tmp * tmp * x; } else { tmp = myPow(x, n / 2); // n &gt;&gt; 1 return tmp * tmp; } }; 法三：快速幂 + 迭代 把递归转化为迭代能够降低空间复杂度为 O(1)O(1)O(1)： var myPow = function(x, n) { if (x === 0) return 0; let res = 1; if (n &lt; 0) { // 把负次幂转化为正次幂计算 x = 1 / x; n = -n; } while (n) { if (n &amp; 1) res *= x; x *= x; // 这里需要使用无符号位移，因为是超过了有符号范围的正数 n &gt;&gt;&gt;= 1; } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_16/"},{"title":"07. 重建二叉树","content":"知识点 JavaScript 的for in的坑 看下面的例子，可以发现for in遍历的属性值是字符串而不是数字： const inorder = [1,2,3]; for (let i = 0; i &lt; inorder.length; ++i) console.log(i, typeof i); // 0 'number', 1 'number', 2 'number' for (const i in inorder) console.log(i, typeof i); // 0 string, 1 string, 2 string 题解 ###分治 前序遍历数组： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序； 中序遍历数组： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序； 因此本题思路为：在前序遍历中顺序遍历node作为根节点，在中序遍历中根据node将数组划分为 [ 左子树 | 根节点 | 右子树 ]。 分治算法： 递推参数： 根节点在前序遍历的索引 rootrootroot、子树在中序遍历的左右边界 leftleftleft和rightrightright； 终止条件： 当 left&gt;rightleft &gt; rightleft&gt;right，代表已经越过叶节点，返回 nullnullnull； 递推工作： 建立根节点 nodenodenode：节点值为 preorder[root]preorder[root]preorder[root]； 划分左右子树：查找根节点在中序遍历 inorderinorderinorder 中的索引 iii； 构建左右子树：左右子树递归处理； 返回值： 回溯返回 nodenodenode，作为上一层递归中根节点的左 / 右子节点。 var buildTree = function(preorder, inorder) { const map = new Map(); for (let i = 0; i &lt; inorder.length; ++i) map.set(inorder[i], i); return dfs(0, 0, inorder.length - 1); // root 是 preorder 中的下标，left 和 right 是 inorder 中的下标 function dfs(root, left, right) { if (left &gt; right) return null; const node = new TreeNode(preorder[root]); // index 表示 preorder 中的根节点在 inorder 中的下标 const index = map.get(preorder[root]); node.left = dfs(root + 1, left, index - 1); // index - left 表示当前节点左子树的长度 node.right = dfs(root + 1 + index - left, index + 1, right); return node; }; }; 一开始想要使用slice()方法把左右数组切出来，发现处理下标会非常麻烦，还是这种只根据下标操作的方法有可行性。 ","link":"https://AriesSK.github.io/post/jianzhi_07/"},{"title":"68 - II. 二叉树的最近公共祖先","content":"知识点 最近公共祖先 最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。 题解 法一：两次遍历 沿用了68 - I. 二叉搜索树的最近公共祖先中的法三思路，存下两个目标节点的访问路径，输出路径中index最大的相同节点： var lowestCommonAncestor = function(root, p, q) { const paths = [], path = []; let res; dfs(root); for (let i = 0;;++i) { if (paths[0][i] !== paths[1][i]) break; res = paths[0][i]; } return res; function dfs(root) { if (!root) return; path.push(root); dfs(root.left); dfs(root.right); if (root === p || root === q) paths.push([...path]); path.pop(); }; }; 法二：递归 若 rootrootroot 是 ppp，qqq 的最近公共祖先 ，则只可能为以下情况之一： ppp 和 qqq 在 rootrootroot 的子树中，且分列 rootrootroot 的左、右子树中（异侧）； p=rootp = rootp=root，且 qqq 在 rootrootroot 的左或右子树中； q=rootq = rootq=root，且 ppp 在 rootrootroot 的左或右子树中； var lowestCommonAncestor = function(root, p, q) { // 越过叶子节点返回 null，找到目标节点返回该节点 if (!root || p === root || q === root) return root; let left = lowestCommonAncestor(root.left, p, q); let right = lowestCommonAncestor(root.right, p, q); // 为空说明 p 和 q 不在这个子树中，返回另一个子树，即使也为空 if (!left) return right; if (!right) return left; // left 和 right 同时非空，说明在异侧，当前节点就是最近公共祖先 return root; }; ","link":"https://AriesSK.github.io/post/jianzhi_68_ii/"},{"title":"68 - I. 二叉搜索树的最近公共祖先","content":"知识点 迭代与递归的空间复杂度 目前来看，迭代的空间复杂度往往优于递归的空间复杂度。 递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度： 每次递归所需的空间都被压到调用栈里（这是内存管理里面的数据结构，和算法里的栈原理相同）， 看递归算法的空间消耗，就是要看调用栈所占用的大小。一次递归结束，调用栈就把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。 题解 法一：迭代 注意审题！本题的树是二叉搜索树，因此判断是否是公共祖先的方法比较简单，只有在一左一右或者其中一个本身是公共祖先的时候成立： 若p.val &gt; root.val &amp;&amp; q.val &gt; root.val，说明公共祖先在root的右子树； 若p.val &lt; root.val &amp;&amp; q.val &lt; root.val，说明公共祖先在root的左子树； 其他情况下root就是所求的公共祖先。 迭代的方法时间复杂度 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1)： var lowestCommonAncestor = function(root, p, q) { while (root) { if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) root = root.right; else if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) root = root.left; else break; } return root; }; 法二：递归 递归的方法时间复杂度 O(n)O(n)O(n)，空间复杂度 O(n)O(n)O(n)： var lowestCommonAncestor = function(root, p, q) { if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q); if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q); return root; }; 法三：两次遍历 还可以两次遍历树找两个目标节点并记录其路径，然后输出两条路径index最大的相同节点（二叉搜索树的遍历）。 ","link":"https://AriesSK.github.io/post/jianzhi_68_i/"},{"title":"64. 求1+2+...+n","content":"知识点 逻辑运算符的短路特性 &amp;&amp;：对于表达式A &amp;&amp; B，如果A为 falsefalsefalse，则整个表达式已经可以被确定为 falsefalsefalse，就不会执行B； ||：对于表达式A || B，如果A为 truetruetrue，则整个表达式已经可以被确定为 truetruetrue，就不会执行B。 题解 逻辑符短路 该题的常规解法有三种：平均计算、迭代和递归。第一种需要乘除法，第二种需要循环，第三种需要判断语句。前两种无法替代，因此需要一种能够替代判断语句用来终止递归的方法，可以使用逻辑运算符的短路特性，将递归出口作为A &amp;&amp; B中的A，函数主体作为B： ar sumNums = function(n) { n &amp;&amp; (n += sumNums(n - 1)); return n; }; ","link":"https://AriesSK.github.io/post/jianzhi_64/"},{"title":"55 - II. 平衡二叉树","content":"知识点 自顶向下与自底向上 目前来看，我感觉在深度优先搜索中，自顶向下的思路比自底向上的思路容易想到，而自底向上的思路往往比自顶向下的思路时间复杂度低，自底向上使用后序遍历，自顶向下使用先序遍历。 题解 法一：先序遍历 + 计算深度（自顶向下） 我的想法是沿用55 - I. 二叉树的深度里的方法，depth()用以计算节点的左右子树的深度，isBalanced()用以遍历所有节点并判断是否平衡，但这种方法在遍历节点时进行了许多的重复计算，时间复杂度O(nlogn)O(nlogn)O(nlogn)： var isBalanced = function(root) { if (!root) return true; // 先处理根节点 再处理左右节点 return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right); }; var depth = function(root) { if (!root) return 0; return Math.max(depth(root.left), depth(root.right)) + 1; } 法二：后序遍历 + 剪枝（自底向上） 这道题的最优解法应当延续55 - I. 二叉树的深度的法二，使用后续遍历，自底向上，若判断子树不是平衡树则可以直接剪枝，思路是从叶子节点开始，计算其左右子树的深度，判断其差值的绝对值： 若 abs(depth(root.left)−depth(root.right))&lt;=1abs(depth(root.left) - depth(root.right)) &lt;= 1abs(depth(root.left)−depth(root.right))&lt;=1，返回该子树的深度； 否则返回 -1，并且一直返回至结束递归。 算法复杂度为 O(n)O(n)O(n)： var isBalanced = function(root) { return dfs(root) !== -1; }; var dfs = function(root) { if (!root) return 0; let left = dfs(root.left); if (left === -1) return -1; let right = dfs(root.right); if (right === -1) return -1; return Math.abs(left - right) &lt;= 1 ? Math.max(left, right) + 1 : -1; }; ","link":"https://AriesSK.github.io/post/jianzhi_55_ii/"},{"title":"55 - I. 二叉树的深度","content":"知识点 要掌握 BFS 和 DFS 两种搜索算法的核心思想，结合题目要求，优化自己的代码！ 题解 深度优先遍历 我一开始的想法是自顶向下的，核心思想是遍历每一个叶子节点并记录其深度，取最大值： 使用depth记录当前层的深度，从root开始每向下一层++depth，到达叶子节点后使用max记录深度中更大的那一个； 每返回上一层--depth； 遍历完所有叶子节点，输出最大值。 var maxDepth = function(root) { let max = 0, depth = 0; dfs(root); return max; function dfs(root){ if (!root) return; ++depth; if (!root.left &amp;&amp; !root.right) max = Math.max(max, depth); dfs(root.left); dfs(root.right); --depth; } }; 后来想到一种自底向上的思路来优化代码： 空节点，返回深度 000； 非空节点，返回左右树深度中较大的那个。 自底向上逐步计算，最终返回树的深度： var maxDepth = function(root) { if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; }; ","link":"https://AriesSK.github.io/post/jianzhi_55_i/"},{"title":"41. 数据流中的中位数","content":"知识点 JavaScript 的堆（优先队列） js 中没有封装好的堆，也不能直接用数组模拟，需要自己封装一个数据结构，下面实现了一个最大堆，最小堆在最大堆的继承基础上实现： class MaxHeap { // 堆顶节点序号为 0 constructor() { this.heap = []; } // 获取父节点：(index - 1 / 2)，向下取整 getParentIndex(index) { return (index - 1) &gt;&gt; 1; } // 获取左节点 getLeftIndex(index) { return index * 2 + 1; } // 获取右节点 getRightIndex(index) { return index * 2 + 2; } // 交换值 swap(index1,index2) { const temp = this.heap[index1]; this.heap[index1] = this.heap[index2]; this.heap[index2] = temp; } // 上移节点 用于插入元素 shiftUp(index) { //到达堆顶就不用上移了 if(index == 0) return; const parentIndex = this.getParentIndex(index); // 最大堆要求父节点比子节点大 if(this.heap[parentIndex] &lt; this.heap[index]) { // 大的值上浮 this.swap(parentIndex,index); // 一直上浮至无法上浮 this.shiftUp(parentIndex); } } //下移节点 用于删除元素 shiftDown(index) { const leftIndex = this.getLeftIndex(index); const rightIndex = this.getRightIndex(index); // 小的值下沉至无法下沉 if(this.heap[leftIndex] &gt; this.heap[index]) { this.swap(leftIndex,index); this.shiftDown(leftIndex); } if(this.heap[rightIndex] &gt; this.heap[index]) { this.swap(rightIndex,index); this.shiftDown(rightIndex); } } //插入节点 插入堆尾 使其上浮 add(value) { this.heap.push(value); this.shiftUp(this.size() - 1); } //删除堆顶元素 移除堆尾节点 将其值给堆顶 使其下沉 pop() { const top = this.heap[0]; if (this.size() === 1) return this.heap.pop(); else { // 在堆只有一个元素的时候不能将堆尾值赋给堆顶，否则会导致没有删除该元素（删了后又新增） this.heap[0] = this.heap.pop(); this.shiftDown(0); } return top; } // 获取堆顶 peek() { return this.heap[0]; } // 获取堆的大小 size() { return this.heap.length; } } class MinHeap extends MaxHeap{ shiftUp(index) { if(index == 0) return; const parentIndex = this.getParentIndex(index); if(this.heap[parentIndex] &gt; this.heap[index]) { this.swap(parentIndex,index); this.shiftUp(parentIndex); } } shiftDown(index) { const leftIndex = this.getLeftIndex(index); const rightIndex = this.getRightIndex(index); if(this.heap[leftIndex] &lt; this.heap[index]) { this.swap(leftIndex,index); this.shiftDown(leftIndex); } if(this.heap[rightIndex] &lt; this.heap[index]) { this.swap(rightIndex,index); this.shiftDown(rightIndex); } } } 题解 堆 对于数据流，要应用堆来一个处理一个的优点，因此这道题建立一个最大堆和一个最小堆，规定： 最小堆保存较大的一半元素； 最大堆保存较小的一半元素； 若元素个数为奇数，最小堆多保存一个元素。 这样设计便可以保证： 元素个数为奇数时，最小堆堆顶是中位数； 元素个数为偶数时，两堆堆顶的平均数是中位数。 而判断元素奇偶的方法是比较两个堆的size()，相同为偶，不同为奇； 为了保证最小堆存较大，最大堆存较小的原则，在插入元素时，若意图插入一个堆，则应当先插入另一个堆，再将其堆顶元素插入目标堆。 var MedianFinder = function() { this.maxHeap = new MaxHeap(); this.minHeap = new MinHeap(); }; /** * @param {number} num * @return {void} */ MedianFinder.prototype.addNum = function(num) { if(this.minHeap.size() !== this.maxHeap.size()) { this.minHeap.add(num); this.maxHeap.add(this.minHeap.pop()); } else { this.maxHeap.add(num); this.minHeap.add(this.maxHeap.pop()); } }; /** * @return {number} */ MedianFinder.prototype.findMedian = function() { return this.minHeap.size() !== this.maxHeap.size() ? this.minHeap.peek() : (this.minHeap.peek() + this.maxHeap.peek()) / 2; }; ","link":"https://AriesSK.github.io/post/jianzhi_41/"},{"title":"40. 最小的k个数","content":"知识点 TopK 问题的两种解法及优劣比较 快速选择 快速选择是基于快速排序思想的方法，关于快速排序请查看45. 把数组排成最小的数。 在解决 TopK 问题时，快速排序需要对整个数组进行 O(nlogn)O(nlogn)O(nlogn) 的排序，事实上我们只需要返回 kkk 个数，并不需要保证其顺序，因此只需要找到某次数组划分后 pivotpivotpivot 是 k+1k + 1k+1，此时返回其左边所有数组即可。 对比快速排序，快速选择每次排序后可以根据 pivotpivotpivot 和 kkk 的大小关系舍弃其中一个区间，因此最终时间复杂度 O(n)O(n)O(n) （n+n2+n4+...++nn=2n−1n + \\frac{n}{2} + \\frac{n}{4} + ... + + \\frac{n}{n} = 2n - 1n+2n​+4n​+...++nn​=2n−1）： var quickSelect = function(nums, l, r, k) { let i = l, j = r, tmp = nums[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) --j; while (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } nums[i] = nums[l]; nums[l] = tmp; // 递归终止条件 注意 slice() 是左闭右开的 if (i === k) return nums.slice(0, k); return i &gt; k ? quickSelect(nums, l, i - 1, k) : quickSelect(nums, i + 1, r, k); } 堆 以前 kkk 小问题为例，思路是用大根堆维护数组的前 kkk 小个数，先将前 kkk 个数插入大根堆，后边的数如果比堆顶小，则弹出堆顶，插入该数，最后返回堆即可，关于 JavaScript 的堆实现，请查看41. 数据流中的中位数。 优劣比较 快速选择相较于堆的优势：快速选择时间复杂度 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1)；堆的时间复杂度 O(nlogk)O(nlogk)O(nlogk)，空间复杂度 O(k)O(k)O(k)，时空复杂度均是快速选择较优； 快速选择相较于堆的劣势： 快速选择需要修改原数组，若不允许修改则需要拷贝数组，增加了空间复杂度； 对于数据流，堆来一个处理一个，最终保存的只是 kkk 大小的堆；而快速选择则需要先保存所有数据再运行算法。因此在处理数据量大的数据流时，使用堆较优。 计数排序 计数排序是一种非基于比较的排序算法，在给定范围的整数排序中，快于任何比较排序算法（牺牲空间换时间），算法复杂度是 O(n+k)O(n + k)O(n+k)，kkk 为整数的范围： 根据待排序数组中数值的范围，申请额外空间； 遍历待排序数组，将其每一个元素的出现次数记录到额外空间对应的元素值处； 遍历额外空间，按顺序与次数输出排序数组。 题解 法一：sort() 最容易想到的思路，排序输出前 kkk 个： var getLeastNumbers = function(arr, k) { arr.sort((a, b) =&gt; a - b); return arr.slice(0, k); }; 法二：快速选择 var getLeastNumbers = function(arr, k) { if (k &gt;= arr.length) return arr; return quickSelect(arr, 0, arr.length - 1, k); }; var quickSelect = function(nums, l, r, k) { // if (l &gt;= r) return; 是快排的递归终止条件，本题不应使用，会导致递归提前结束而出错 let i = l, j = r, tmp = nums[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) --j; while (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } nums[i] = nums[l]; nums[l] = tmp; // 递归终止条件 if (i === k) return nums.slice(0, k); return i &gt; k ? quickSelect(nums, l, i - 1, k) : quickSelect(nums, i + 1, r, k); } 法三：堆 js 需要手写堆的数据结构： var getLeastNumbers = function(arr, k) { let i = 0; const heap = new MaxHeap(), res = []; for (i; i &lt; k; ++i) heap.add(arr[i]); for (i; i &lt; arr.length; ++i) { if (arr[i] &lt; heap.peek()) { heap.pop(); heap.add(arr[i]); } } while (heap.size()) res.push(heap.pop()); return res; }; class MaxHeap{ constructor() { this.heap = []; } getParentIndex(index) { return (index - 1) &gt;&gt; 1; } getLeftIndex(index) { return index * 2 + 1; } getRightIndex(index) { return index * 2 + 2; } swap(index1,index2) { const temp = this.heap[index1]; this.heap[index1] = this.heap[index2]; this.heap[index2] = temp; } shiftUp(index) { if(index == 0) return; const parentIndex = this.getParentIndex(index); if(this.heap[parentIndex] &lt; this.heap[index]) { this.swap(parentIndex,index); this.shiftUp(parentIndex); } } shiftDown(index) { const leftIndex = this.getLeftIndex(index); const rightIndex = this.getRightIndex(index); if(this.heap[leftIndex] &gt; this.heap[index]) { this.swap(leftIndex,index); this.shiftDown(leftIndex); } if(this.heap[rightIndex] &gt; this.heap[index]) { this.swap(rightIndex,index); this.shiftDown(rightIndex); } } add(value) { this.heap.push(value); this.shiftUp(this.heap.length - 1); } pop() { const top = this.heap[0]; if (this.size() === 1) return this.heap.pop(); else{ this.heap[0] = this.heap.pop(); this.shiftDown(0); } return top; } peek() { return this.heap[0]; } size() { return this.heap.length; } } ","link":"https://AriesSK.github.io/post/jianzhi_40/"},{"title":"61. 扑克牌中的顺子","content":"知识点 JavaScript 的自定义sort()函数 sort()支持自定义，输入两个参数 aaa，bbb，计算函数体中表达式（规则）的值： 当值为负数，aaa 排在 bbb 前面，升序排序； 当值为正数，aaa 排在 bbb 后面，降序排序； 当值为 000，顺序不变。 举45. 把数组排成最小的数为例： // 自定义了排序的规则：如果 a 和 b 的拼接小于 b 和 a 的拼接，则 a 应该排到 b 的前面 nums.sort((a, b) =&gt; (&quot;&quot; + a + b) - (&quot;&quot; + b + a))； 题解 法一：排序 + 哈希 我最先想到的方法： 对数组进行排序，从大到小； 遍历数组将非 0 元素存入Set()，若重复返回 falsefalsefalse，遇到 000 则跳出循环，记下 000 的个数； 从nums[0] - 1开始每轮自建，查看Set()中能否找到对应数字，找到则继续，找不到用 000 替代，同时使 000 的个数自减，若找不到对应数字的同时 000 的个数为 000，则返回 falsefalsefalse，完成遍历返回 truetruetrue。 var isStraight = function(nums) { nums.sort((a, b) =&gt; b - a); let count = 0, num = nums[0] - 1; const set = new Set(); for (const i in nums) { if (!nums[i]) { count = 5 - i; break; } if (!set.has(nums[i])) set.add(nums[i]); else return false; } for (let j = 3; j &gt;= 0; --j) { if (set.has(num--)) continue; if(count) --count; else return false; } return true; }; 法二：哈希 + 遍历 事实上用了Set()就无需排序，本题满足是顺子需要同时满足两个条件： 无重复牌（除大小王）； 最大牌 - 最小牌 &lt; 5。 因此在遍历过程中跳过 000，使用Set()判重，同时记录最大值和最小值即可： var isStraight = function(nums) { const set = new Set(); let min = 13, max = 0; for (const num of nums) { if (!num) continue; max = Math.max(num, max); min = Math.min(num, min); if (set.has(num)) return false; else set.add(num); } return max - min &lt; 5; }; 法三：排序 + 遍历 用了排序就无需Set()： 先对数组执行排序； 判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 nums[i]=nums[i+1]nums[i]=nums[i+1]nums[i]=nums[i+1] 是否成立来判重； 获取最大值和最小值： 排序后，数组末位元素 nums[4]nums[4]nums[4] 为最大牌；元素 nums[count]nums[count]nums[count] 为最小牌，其中 countcountcount 为大小王的数量。 var isStraight = function(nums) { let count = 0; nums.sort((a, b) =&gt; a - b); for (let i = 0; i &lt; 4; ++i) { if (!nums[i]) ++count; else if (nums[i] === nums[i + 1]) return false; } return nums[4] - nums[count] &lt; 5; }; ","link":"https://AriesSK.github.io/post/jianzhi_61/"},{"title":"45. 把数组排成最小的数","content":"知识点 快速排序 快速排序一轮需要遍历 nnn 的数，而每一轮理想情况下能将数组等半分割，因此需要 O(log2n)O(log_2n)O(log2​n) 轮，因此平均时间复杂度为 O(nlogn)O(nlogn)O(nlogn)，并且是不稳定的排序算法。 原地快排模板，注意设置中枢在哪侧则另一侧的指针先动： var quickSort = function(nums, l, r) { // 递归的终止条件 if (l &gt;= r) return; // 这里需要声明 tmp，不能在 while 中声明 let i = l, j = r, tmp = nums[i]; // 声明本轮快排的中枢，这样写是为了容易看懂，其实 l 等同于 pivot const pivot = l; while (i &lt; j) { // 从右侧开始找第一个比中枢小的，从左侧开始找第一个比中枢大的，交换 // 需要取等号是为了防止把 pivot 交换出去，只有在一轮遍历结束后才交换 pivot while (i &lt; j &amp;&amp; nums[j] &gt;= nums[pivot]) --j; while (i &lt; j &amp;&amp; nums[i] &lt;= nums[pivot]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } // 上面的交换一直重复至 i === j，此时 i 指向的位置就是中枢最终的位置，交换 nums[i] = nums[pivot]; nums[pivot] = tmp; quickSort(nums, l, i - 1); quickSort(nums, i + 1, r); } 新建数组的快排，利用了新建左右两个数组和连接函数concat()，简单易懂，但需要额外的数组空间： var quickSort = function(nums) { if (nums.length &lt;= 1) return nums; const pivot = nums[0]; let left = [], right = []; for (let i = 1; i &lt; nums.length; ++i) { if (nums[i] &lt;= pivot) left.push(nums[i]); else right.push(nums[i]); } return quickSort(left).concat([pivot], quickSort(right)); } 题解 这道题本质上是一个排序问题，难点就在于其排序判断的规则： 若拼接字符串 x+y&gt;y+xx +y &gt; y + xx+y&gt;y+x，则 xxx 排在 yyy 之后； 反之，则 xxx 排在 yyy 前面； 了解排序规则后，只需要选择一种排序方法对数组进行排序即可。 法一：快速排序 在原地快速排序的基础上修改判定的条件实现： var minNumber = function(nums) { quickSort(nums, 0, nums.length - 1); // 通过 join() 能够把数组元素以特定的分隔符连成一个字符串，这里用 &quot;&quot; 作为分隔符 return nums.join(&quot;&quot;); }; var quickSort = function(nums, l, r) { if (l &gt;= r) return; let i = l, j = r, tmp = nums[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; &quot;&quot; + nums[j] + nums[l] &gt;= &quot;&quot; + nums[l] + nums[j]) --j; while (i &lt; j &amp;&amp; &quot;&quot; + nums[i] + nums[l] &lt;= &quot;&quot; + nums[l] + nums[i]) ++i; tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } nums[i] = nums[l]; nums[l] = tmp; quickSort(nums, l, i - 1); quickSort(nums, i + 1, r); } 法二：sort()函数 通过自定义内置sort()函数实现排序： var minNumber = function(nums) { return nums.sort((a, b) =&gt; { // 如果 a 和 b 的拼接小于 b 和 a 的拼接，则 a 应该排到 b 的前面 if(&quot;&quot; + a + b &lt; &quot;&quot; + b + a){ // 返回结果小于0，a 在 b 的前面 return -1; }else{ // 返回结果大于0，a 在 b 的后面 return 1; } }).join(''); }; 甚至还能一行写完： var minNumber = function(nums) { return nums.sort((a, b) =&gt; (&quot;&quot; + a + b) - (&quot;&quot; + b + a)).join(''); }; ","link":"https://AriesSK.github.io/post/jianzhi_45/"},{"title":"54. 二叉搜索树的第k大节点","content":"知识点 运算符优先级 关于运算符的优先级，见21. 调整数组顺序使奇数位于偶数前面 下面两种的运算结果是一样的，这题中都可以： let k = 1; console.log(!--k); // true k = 1; console.log(!(--k)); // true 不过这样写容易出错，还是老实写： let k = 1; console.log(--k == 0); // true 题解 深度优先搜索 二叉搜索树的中序遍历就是升序数组，本题进行逆向的中序遍历，并且设置isFound标志找到了目标，提前结束递归（题目规定不会有空树的情况）： var kthLargest = function(root, k) { let isFound = false, res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (isFound) return; if (k - 1) --k; else { res = root.val; isFound = true; } dfs(root.left); } }; 后来发现isFound可以省略，当k减到 000 时即代表找到了目标： var kthLargest = function(root, k) { let res; dfs(root); return res; function dfs(root) { if (!root) return; dfs(root.right); if (!k) return; // 先自减再判断是否为 0 if (!--k) res = root.val; dfs(root.left); } }; ","link":"https://AriesSK.github.io/post/jianzhi_54/"},{"title":"36. 二叉搜索树与双向链表","content":"知识点 二叉搜索树（二叉查找树，二叉排序树） 定义： 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。 二叉搜索树（Binary Search Tree, BST）的中序遍历是升序序列。 三种深度优先搜索 前中后指的是root节点在三个节点中的位置 前序遍历： var dfs = function(root) { if (!root) return; console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.left); dfs(root.right); } 中序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); console.log(root.val); // 操作 root 节点，比如打印其值 dfs(root.right); } 后序遍历： var dfs = function(root) { if (!root) return; dfs(root.left); dfs(root.right); console.log(root.val); // 操作 root 节点，比如打印其值 } 题解 法一：使用队列 我一开始想到的方法，在中序遍历的同时使用一个队列按顺序保存每一个节点，再按顺序输出节点并连接： var treeToDoublyList = function(root) { if (!root) return root; const list = []; dfs(root); const head = list.shift(); let ptr = head; while(list.length) { ptr.right = list.shift(); ptr.right.left = ptr; ptr = ptr.right; } ptr.right = head; head.left = ptr; return head; function dfs(root) { if (!root) return; dfs(root.left); list.push(root); dfs(root.right); } }; 法二：原地算法 事实上并不需要使用队列保存节点，使用一个``pre和一个curr`指针分别保存上一个节点和当前节点即可： var treeToDoublyList = function(root) { let pre, curr; // 空树 if (!root) return root; dfs(root); // 完成中序遍历后还需将头节点和尾节点连接起来成环 head.left = pre; pre.right = head; return head; function dfs(curr) { if (!curr) return; // 先找到最左侧的叶子节点，是链表的头节点 dfs(curr.left); if (pre) pre.right = curr; else head = curr; curr.left = pre; // 更新 curr pre = curr; dfs(curr.right); } }; ","link":"https://AriesSK.github.io/post/jianzhi_36/"},{"title":"34. 二叉树中和为某一值的路径","content":"知识点 JavaScript 的坑 做这道题的过程中遇到了两个坑，记录一下。 声明全局变量 这道题中我需要在dfs(root, target)中使用path和res，所以一开始在最外层声明了变量，即全局变量，像下面这样： const path = [], res = []; var pathSum = function(root, target) {} var dfs = function(root, target) {} 这样写能够通过 Leetcode 的测试用例，但同样的用例在正式提交时却会报错，这是因为上一次用例运行留下的全局变量并没有被销毁，会使之后的用例运行出错，所以应当将dfs(root, target)设置为局部函数： var pathSum = function(root, target) { const path = [], res = []; function dfs(root, target) {} } 引用值 这道题里的path是引用对象，使用res.push([path])是将这个引用对象放入了res中，而后续path对象改变时，res中的path的会随之改变，输出错误结果，正确处理需要深拷贝path存入res中，需要用到展开运算符...。 res.push([...path]); 对于一级基础数据，展开运算符实现深拷贝； 对于二级及以上的复杂数据，展开运算符实现浅拷贝。 题解 深度优先搜索 这道题需要遍历到叶子节点并且输出所有可能，因此无法剪枝。 使用path保存当前遍历的路径，res保存符合要求的路径，需要注意的是在返回上一层递归的时候需要通过path.pop()将path恢复至上一层节点： var pathSum = function(root, target) { const path = [], res = []; dfs(root, target); return res; // 声明函数 function dfs(root, target) { if (!root) return; path.push(root.val); target -= root.val; // 深拷贝 path 并存入 res if (!root.left &amp;&amp; !root.right &amp;&amp; !target) res.push([...path]); dfs(root.left, target); dfs(root.right, target); // 恢复 path path.pop(); }; }; ","link":"https://AriesSK.github.io/post/jianzhi_34/"},{"title":"13. 机器人的运动范围","content":"知识点 JavaScript 中的函数传值 js 中的所有函数的参数都是按值传递的，这意味着函数外的值会被复制到函数内部的参数中，如果是原始值，就跟原始值变量的复制一样，如果是引用值，就和引用值变量的复制一样。 按值传递参数： 外部的值被复制到函数的一个局部变量中，这两个值相互独立，互不干扰； 按引用传递参数： 外部的值在内存中的位置会被保存到函数的一个局部变量中，意味着对局部变量的修改会反应到函数外部，这在 js 中是不可能的。 原始值的按值传递举例，可以看到传入参数与外部值相互独立，互不干扰： function addOne (num) { num += 1; return num; } let count = 20; let res = addOne(count); // count === 20, res === 30 引用值的按值传递举例，如果是按引用传递，那么在新建obj对象的时候，person应该自动将指针改为指向&quot;Aries&quot;的对象，但事实上并没有。这证明了是按值传递的，传递了引用值，而引用的对象是保存在全局作用域，因此可以通过obj访问引用对象修改属性： function setName(obj) { obj.name = &quot;AriesSK&quot;; obj = new Object(); obj.name = &quot;Aries&quot; return num; } let person = new Object(); setName(person); // person.name === &quot;AriesSK&quot; 题解 法一：深度优先搜索 我的解法： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k, res); }; var dfs = function(visit, i, j, k, res) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &lt; 0 || i &gt;= visit.length || j &lt; 0 || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return res; visit[i][j] = 1; res = dfs(visit, i + 1, j, k, res); res = dfs(visit, i - 1, j, k, res); res = dfs(visit, i, j + 1, k, res); res = dfs(visit, i, j - 1, k, res); return ++res; } dfs 解法的优化，省略了不必要的res，并且由于从 (0,0)(0,0)(0,0) 开始，由图可以看出仅通过向右和向下两个方向即可访问所有可达解： var movingCount = function(m, n, k) { const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); return dfs(visit, 0, 0, k); }; var dfs = function(visit, i, j, k) { let s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if ( i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return 0; visit[i][j] = 1; return 1 + dfs(visit, i + 1, j, k) + dfs(visit, i, j + 1, k); } 法二：广度优先搜索 bfs 需要用到队列和循环，无需递归： var movingCount = function(m, n, k) { let res = 0; const visit = new Array(m); for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0); const queue = []; queue.unshift([0, 0]); while(queue.length &gt; 0) { let temp = queue.pop(); let i = temp[0], j = temp[1], s = &quot;&quot; + i + j, sum = 0; for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]); if (i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) continue; visit[i][j] = 1; ++res; queue.unshift([i + 1, j]); queue.unshift([i, j + 1]); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_13/"},{"title":"12. 矩阵中的路径","content":"知识点 深度优先搜索 通过递归的方式，先朝一个方向搜索到底，再回溯至上个节点，沿另一个方向搜索，一次类推。 剪枝 在搜索过程中遇到该路径不可能与目标匹配成功的情况时，应当立即返回，这叫可行性剪枝。 题解 深度优先搜索 + 剪枝 递归终止条件： 返回 false：索引越界 || 当前矩阵元素与目标不匹配（包括已访问）； 返回true：k === word.length - 1，即word已完全匹配。 递推工作： 标记已访问：将board[i][j]修改为 0，防止重复搜索； 搜索下一元素：朝当前元素上、下、左、右四个方向进行下一层递归，使用||连接代表只需找到一条可行路径，记录结果至res； 还原：将board[i][j]还原至初始值word[k]。 var exist = function(board, word) { for (let i = 0; i &lt; board.length; ++i) { for (let j = 0; j &lt; board[0].length; ++j) { if (dfs(board, word, i, j, 0)) return true; } } return false; }; var dfs = function(board, word, i, j, k) { if (i &gt;= board.length || i &lt; 0 || j &gt; board[0].length || j &lt; 0 || board[i][j] !== word[k]) return false; if (k === word.length - 1) return true; // 标记已访问 board[i][j] = 0; const res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1); // 恢复原数组 board[i][j] = word[k]; return res; } ","link":"https://AriesSK.github.io/post/jianzhi_12/"},{"title":"58 - I. 翻转字符单词顺序","content":"知识点 JavaScript 的字符串函数 本题中使用的一些字符串函数及它们的时间复杂度： trim() // 去除字符串头尾的空格 O(n) split() // 拆分成数组 O(n) reverse() // 反转数组 O(n) join() // 使用特定分隔符将数组连接成字符串 O(n) 其中需要重点说明split()举例如下： let s = &quot;a b c&quot; s.split() // [&quot;a b c&quot;] // 直接返回数组 s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开 s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素 s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数 题解 法一：字符串函数 首先想到使用tirm()删除头尾空格，split(&quot; &quot;)拆分成数组，从数组末尾开始拼接： var reverseWords = function(s) { const arr = s.trim().split(&quot; &quot;); let res = &quot;&quot;; for (let i = arr.length - 1; i &gt;= 0; --i) { if (arr[i] === &quot;&quot;) continue; res += i ? arr[i] + &quot; &quot; : arr[i]; } return res; }; 事实上使用字符串函数代码可以更加简洁： var reverseWords = function(s) { return s.trim().split(/\\s+/).reverse().join(' '); }; 法二：双指针 var reverseWords = function(s) { s = s.trim(); let left = s.length - 1, right = left; let res = &quot;&quot;; // 保证 left 能够取到 0 while (left &gt;= 0) { // 找到第一个空格 while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left; res += s.substring(left + 1, right + 1) + &quot; &quot;; // 忽略空格找到第一个字符 while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left; right = left; } // 删去最后末尾多余的一个空格 return res.trim(); }; ","link":"https://AriesSK.github.io/post/jianzhi_58_i/"},{"title":"57. 和为s的两个数字","content":"知识点 JavaScript 的const 在允许的情况下，推荐使用const进行声明，const声明后无法重新赋值，但可以修改其属性值。 题解 双指针的简单应用： var twoSum = function(nums, target) { let left = 0, right = nums.length - 1; const res = []; // 若允许同一个数自己加自己则取 = while (left &lt; right) { // 在值是正数的情况下，改加为减能够有效防止值溢出 if (nums[left] &gt; target - nums[right]) --right; else if (nums[left] &lt; target - nums[right]) ++left; else { res.push(nums[left]); res.push(nums[right]); // 不适用 break 会导致无限循环入栈至溢出 break; } } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_57/"},{"title":"21. 调整数组顺序使奇数位于偶数前面","content":"知识点 JavaScript 中的运算符优先级 在写代码时需要注意运算符的优先级，如下由于!的运算优先级高于%，因此加不加()是两种结果： let num = 2; console.log(!num % 2); // 0 console.log(!(num % 2)); // true 题解 简单的双指针运用： var exchange = function(nums) { let left = 0, right = nums.length - 1; // while 中是否取等号均可 while (left &lt; right) { if (nums[left] % 2) ++left; else if (!(nums[right] % 2)) --right; else { let temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } return nums; }; ","link":"https://AriesSK.github.io/post/jianzhi_21/"},{"title":"52. 两个链表的第一个公共节点","content":"知识点 这题使用的是一种特别的解题思路： 你变成我，走过我走过的路； 我变成你，走过你走过的路； 然后我们便相遇了… 题解 法一：哈希表 链表 AAA 长度 mmm，链表 BBB 长度为 nnn。 看到这题的第一想法是暴力遍历，时间复杂度是 O(m∗n)O(m * n)O(m∗n)， 第二想法是用哈希表，时间复杂度降低为 O(m+n)O(m + n)O(m+n)，但需要 O(m)O(m)O(m) 的空间： var getIntersectionNode = function(headA, headB) { let ptra = headA, ptrb = headB; const set = new Set(); while(ptra) { set.add(ptra); ptra = ptra.next; } while(ptrb) { if (set.has(ptrb)) return ptrb; ptrb = ptrb.next; } return null; }; 法二：双指针 但题目要求时间复杂度降低为 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1) 。 这题用了一种比较特别的思路： 首先假设链表 AAA 有 aaa 个节点，链表 BBB 有 bbb 个节点， 它们的公共节点有 ccc 个，它们的第一个公共节点为 nodecnodecnodec； 设置指针ptra遍历链表 AAA，随后再从 headBheadBheadB 开始遍历，到达 nodecnodecnodec 时遍历长度为 a+(b−c)a + (b - c)a+(b−c)； 设置指针ptrb遍历链表 BBB，随后再从 headAheadAheadA 开始遍历，到达 nodecnodecnodec 时遍历长度为 b+(a−c)b + (a - c)b+(a−c)。 可以发现此时两指针相交于 nodecnodecnodec 并且遍历过的节点总数是相同的，这就为算法的实现提供了条件——每次使ptra和ptrb同时前进一个节点。 两条链表没有公共节点的情况就等同于两条链表的公共节点是链表结尾的 nullnullnull，因此在完成遍历后两指针同时为 nullnullnull 时会返回 nullnullnull： var getIntersectionNode = function(headA, headB) { let ptra = headA, ptrb = headB; while (ptra !== ptrb) { // 注意每一轮循环只因当修改一次指针的值 若这里使用条件语句则应当用 if else ptra = !ptra ? headB : ptra.next; ptrb = !ptrb ? headA : ptrb.next; } return ptra; }; ","link":"https://AriesSK.github.io/post/jianzhi_52/"},{"title":"25. 合并两个排序的链表","content":"知识点 JavaScript 赋值 js 中将原始值赋值给另一个变量时，原始值会被复制到新变量的位置，而这两个值是完全独立，互不干扰的： let num1 = 6; let num2 = num1; js 中将引用值从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来： let obj1 = new Object(); let obj2 = obj1; obj1.name = &quot;AriesSK&quot;; console.log(obj2.name); // AriesSK 题解 法一：双指针 + 迭代 头指针的应用，注意在比较过程中newHead也会变化，需要使用一个指针res维护它的初值，初始链表为空的情况已经包含在内，不需要另外考虑： var mergeTwoLists = function(l1, l2) { let ptr1 = l1, ptr2 = l2, newHead = new ListNode(); const res = newHead; while (ptr1 &amp;&amp; ptr2) { if (ptr1.val &lt;= ptr2.val) { newHead.next = ptr1; ptr1 = ptr1.next; } else { newHead.next = ptr2; ptr2 = ptr2.next; } newHead = newHead.next; } // 一条为空 接上另一条剩下的 newHead.next = ptr1 ? ptr1 : ptr2; return res.next; }; 法二：递归 空间复杂度 O(n+m)O(n + m)O(n+m)，nnn 和 mmm 分别为两个链表的长度，递归调用函数需要消耗栈空间，栈空间的大小取决于递归调用的深度，这里最多调用 n+mn + mn+m 次： var mergeTwoLists = function(l1, l2) { if (!l1) return l2; else if (!l2) return l1; else if (l1.val &lt;= l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } ","link":"https://AriesSK.github.io/post/jianzhi_25/"},{"title":"22. 链表中的倒数第k个节点","content":"知识点 此类题目对头节点并不需要特殊的处理 因此可以不另设头指针。 题解 双指针 两指针减保持 kkk 距离，直到右指针为空时，左指针即为目标节点： var getKthFromEnd = function(head, k) { let left = head, right = left; while (k &gt; 0) { right = right.next; --k; } while (right) { left = left.next; right = right.next; } return left; }; ","link":"https://AriesSK.github.io/post/jianzhi_22/"},{"title":"18. 删除链表的节点","content":"知识点 在链表前设置一个指向头节点的头指针能够使算法不用单独考虑头节点的处理。 题解 双指针 使用 nextnextnext 遍历目标节点，currcurrcurr 记录目标节点的前一节点，以实现断链 推荐设置一个值为 nullnullnull 的头节点（头指针）newHead，能够有效避免删除头节点或链表为空的情况： var deleteNode = function(head, val) { const newHead = new ListNode(); newHead.next = head; let curr = newHead, next = curr.next; while (next) { if (next.val === val) { curr.next = next.next; next.next = null; break; } curr = curr.next; next = next.next; } return newHead.next; }; ","link":"https://AriesSK.github.io/post/jianzhi_18/"},{"title":"48. 最长不含重复字符的子字符串","content":"知识点 JavaScript 的字符串函数 字符串函数的补充说明： slice(start, end) // strat 取到，end 取不到 s = &quot;abcedf&quot; s.slice(-3) // edf s.slice(-3, -1) // ed s.substr(-1) // f s.substr(-3, 2) // ed 逆时针取两位 字符的 ASCII 码范围为 0~127。 题解 法一：动态规划 步骤： 状态定义：设动态规划矩阵 dpdpdp，dp[i]dp[i]dp[i] 代表前 iii 位字符串的最大不重复子串长度； 转移方程：判断以 s[i]s[i]s[i] 结尾的倒数 dp[i−1]dp[i - 1]dp[i−1] 个字符是否是不重复字串，若是，则 dp[i]=dp[i−1]+1dp[i] = dp[i - 1] + 1dp[i]=dp[i−1]+1；否则 dp[i]=dp[i−1]dp[i] = dp[i - 1]dp[i]=dp[i−1]; 初始状态：dp[0]=0dp[0] = 0dp[0]=0，dp[1]=1dp[1] = 1dp[1]=1； 返回结果：dp[n]dp[n]dp[n]。 var lengthOfLongestSubstring = function(s) { let pre = 0, curr = 0; for (let i = 0; i &lt; s.length; ++i) { curr = isRepeat(s.slice(i - pre, i + 1)) ? pre : pre + 1; pre = curr; } return curr; }; var isRepeat = function(s) { let set = new Set(); for (let i of s) { if (set.has(i)) return true; else set.add(i); } return false; }; 上面的方法每遍历一个字符，都需要遍历包含其的一个字串，时间复杂度较高，可以对其加以改进： 状态定义： 设动态规划矩阵 dpdpdp，dp[j]dp[j]dp[j] 代表以 s[j]s[j]s[j] 结尾的最大不重复子串长度； 转移方程： 固定右边界 jjj ，设 s[j]s[j]s[j] 左侧距离最近的相同字符位 s[i]s[i]s[i]。如果 dp[j−1]&lt;j−idp[j - 1] &lt; j - idp[j−1]&lt;j−i ，说明 s[j]s[j]s[j] 使不重复长度变长了一位，dp[j]=dp[j−1]+1dp[j] = dp[j - 1] + 1dp[j]=dp[j−1]+1；否则说明引起了重复，dp[j]=j−idp[j] = j - idp[j]=j−i； dp[i,j]={dp[j−1]+1,dp[j−1]&lt;j−ij−i,dp[j−1]≥j−idp[i, j] = \\begin{cases} dp[j - 1] + 1&amp; {,dp[j - 1] &lt; j - i}\\\\ j - i&amp; {,dp[j - 1] \\geq j - i} \\end{cases} dp[i,j]={dp[j−1]+1j−i​,dp[j−1]&lt;j−i,dp[j−1]≥j−i​ 初始状态： dp[0]=0dp[0] = 0dp[0]=0，dp[1]=1dp[1] = 1dp[1]=1； 返回结果： max(dp)max(dp)max(dp)。 可以通过哈希表记录每个字符最后一次出现的index到达记录i的效果： var lengthOfLongestSubstring = function(s) { let hash = new Map(); let pre = 0, res = 0; for (let j = 0; j &lt; s.length; ++j) { // 哈希表中若没有 s[j] 则设 i 初始为 -1 let i = hash.has(s.charAt(j)) ? hash.get(s.charAt(j)) : -1; hash.set(s.charAt(j), j); pre = pre &lt; j - i ? pre + 1 : j - i; res = Math.max(res, pre); } return res; }; 这种方法的时间复杂度被降低为了 O(n)O(n)O(n)，同时由于字符的 ASCII 码范围为 0~127，因此哈希表的空间复杂度是 O(1)O(1)O(1) 。 法二：滑动窗口 以 (a)bcabcbb 开始的最长不重复子串为 (abc)abcbb； 以 a(b)cabcbb 开始的最长不重复子串为 a(bca)bcbb； 以 ab(c)abcbb 开始的最长不重复子串为 ab(cab)cbb； 以 abc(a)bcbb 开始的最长不重复子串为 abc(abc)bb； 以 abca(b)cbb 开始的最长不重复子串为 abca(bc)bb； 以 abcab(c)bb 开始的最长不重复子串为 abcab(cb)b； 以 abcabc(b)b 开始的最长不重复子串为 abcabc(b)b； 以 abcabcb(b) 开始的最长不重复子串为 abcabcb(b)。 从上面的过程可以看出最长不重复字串的结束位置必然是递增的，因此就可以使用滑动窗口的方法： 使用两个指针表示字符串中的某个子串的左右边界（窗口），左指针代表子串的起始位置，而右指针代表字串的结束位置； 每一次将左指针右移一格，将下一个字符作为起始位置，在保证窗口中没有重复字符的前提下不断右移右指针。在移动结束后，窗口对应以左指针开始的最长不重复子串，记录其长度； 左指针移动到最后一个字符，返回记录长度的最大值。 var lengthOfLongestSubstring = function(s) { let max = 0; for (let left = 0; left &lt; s.length; ++left) { const set = new Set(); for (let right = left; right &lt; s.length; ++right) { // 找到重复字符的情况下 子串的长度为 right - left if (set.has(s.charAt(right))) { max = Math.max(max, right - left); break; } // 需要考虑 right 移至左端仍没有重复节点的情况 此时子串长度为 right - left + 1 else if (right === s.length - 1) max = Math.max(max, right - left + 1); else set.add(s.charAt(right)); } } return max; }; 上面这种方法由于每轮都重置了右指针，所以时间复杂度 O(n2)O(n^2)O(n2) 不是真正的滑动窗口，事实上右指针应该不左移才能保证时间复杂度，没必要每次重复遍历和记录已经遍历过的字符： var lengthOfLongestSubstring = function(s) { const set = new Set(); const n = s.length; let r = 0, res = 0; for (let l = 0; l &lt; n; ++l) { if (l) set.delete(s.charAt(l - 1)); while (r &lt; n &amp;&amp; !set.has(s.charAt(r))) { set.add(s.charAt(r)); ++r; } res = Math.max(res, r - l); } return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_48/"},{"title":"46. 把数字翻译成字符串","content":"知识点 JavaScript 字符串函数 toString() // 将数字转化为字符串以获取其长度 substr(begin, length) // 返回从下标 begin 开始长度为 length 的字符串 substr() 也可以使用其他两个函数替换: // 两者均是返回 begin 到 end 的字符串 均可以省略第二个参数 表示截取到字符串尾部 slice(begin, end) substring(begin, end) 两者的区别是： substring()会判断两个参数大小，小的作为起始位置，大的作为结束位置，slice()则不会； slice()中的负参数表示从末尾开始计数， 而substring()中负数按 000 处理。 题解 动态规划 这道题的递归思想类似于10 - II. 青蛙跳台阶问题，只不过需要对能否跳进行判断。 所以步骤如下： 状态定义： 设动态规划矩阵 dpdpdp，dp[i]dp[i]dp[i] 代表前 iii 位数字的翻译方案数量； 转移方程： 注意最后两位数除了大于 252525 时无法翻译，小于 101010 也同样无法翻译（无法翻译 000 开头的两位数）。因此： dp[i,j]={dp[i−1]+dp[i−2],10xi−1+xi∈[10,25])dp[i−1],10xi−1+xi∈[0,25)∪(25,99])dp[i, j] = \\begin{cases} dp[i - 1] + dp[i - 2]&amp; {, 10x_{i - 1} + x_i \\in [10, 25])}\\\\ dp[i - 1]&amp; {, 10x_{i - 1} + x_i \\in [0, 25) \\cup (25, 99])} \\end{cases} dp[i,j]={dp[i−1]+dp[i−2]dp[i−1]​,10xi−1​+xi​∈[10,25]),10xi−1​+xi​∈[0,25)∪(25,99])​ 初始状态： dp[0]=1dp[0] = 1dp[0]=1，dp[1]=1dp[1] = 1dp[1]=1； 返回结果： dp[n]dp[n]dp[n]。 var translateNum = function(num) { num = num.toString(); let p = 1, q = 1, r = 1; for (let i = 1; i &lt; num.length; ++i) { r = num.substr(i - 1, 2) &lt;= 25 &amp;&amp; num.substr(i - 1, 2) &gt;= 10 ? p + q : q; p = q; q = r; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_46/"},{"title":"47. 礼物的最大价值","content":"知识点 二维数组的动态规划 如果想要不修改原数组，则需要创建一个二维数组 dp[m,n]dp[m, n]dp[m,n]。 JavaScript 创建二维数组 const m = 4, n = 5; let arr = new Array(m); for (let i = 0; i &lt; n; ++i) arr[i] = new Array(n); 注意在数组内的值未声明(赋初值)的时候默认均为undefined，可以使用for of遍历每个undefined，但不能使用for in获取下标: let arr = new Array(5); // 数组内的值均是 undefined for (const i of arr) console.log(i); // undefined * 5 let arr = new Array(5); // 数组内的值均是 undefined for (const i in arr) console.log(i); // 无输出 let arr = new Array(5).fill(0); for (const i in arr) console.log(i); // 1, 2, 3, 4, 5 题解 步骤： 状态定义：设动态规划矩阵 dpdpdp，dp(i,j)dp(i, j)dp(i,j) 代表从左上角开始到 (i,j)(i, j)(i,j) 时拿到礼物的最大价值； 转移方程： dp(i,j)={grid(i,j),i=0,j=0grid(i,j)+dp(i,j−1),i=0,j=0grid(i,j)+dp(i−1,j),i=0,j=0grid(i,j)+max[dp(i−1,j),dp(i−1,j)],i=0,j=0dp(i, j) = \\begin{cases} grid(i, j)&amp; {,i = 0, j = 0}\\\\ grid(i, j) + dp(i, j - 1)&amp; {,i = 0, j \\not= 0}\\\\ grid(i, j) + dp(i - 1, j)&amp; {,i \\not= 0, j = 0}\\\\ grid(i, j) + max[dp(i - 1, j), dp(i - 1, j)]&amp; {,i \\not= 0, j \\not= 0} \\end{cases} dp(i,j)=⎩⎪⎪⎪⎨⎪⎪⎪⎧​grid(i,j)grid(i,j)+dp(i,j−1)grid(i,j)+dp(i−1,j)grid(i,j)+max[dp(i−1,j),dp(i−1,j)]​,i=0,j=0,i=0,j​=0,i​=0,j=0,i​=0,j​=0​ 初始状态：dp(0,0)=0dp(0, 0) = 0dp(0,0)=0； 返回结果：dp(m−1)(n−1)dp(m - 1)(n - 1)dp(m−1)(n−1)。 var maxValue = function(grid) { let m = grid.length, n = grid[0].length; for (let i = 0; i &lt; m; ++i) { for (let j = 0; j &lt; n; ++j) { if (i === 0 &amp;&amp; j === 0) continue; if (i === 0) grid[i][j] += grid[i][j - 1]; else if (j === 0) grid[i][j] += grid[i - 1][j]; else grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]) } } return grid[m - 1][n - 1]; }; 上面的方法还可以优化，因为当 gridgridgrid 矩阵很大时，i=0i = 0i=0 或 j=0j = 0j=0 的情况仅占极少数，相当循环每轮都冗余了一次判断。可以完成矩阵的第一行和第一列的赋值，再通过循环给剩余的赋值，提高代码运行效率： var maxValue = function(grid) { let m = grid.length, n = grid[0].length; for (let i = 1; i &lt; m; ++i) grid[i][0] += grid[i - 1][0]; for (let j = 1; j &lt; n; ++j) grid[0][j] += grid[0][j - 1]; for (let i = 1; i &lt; m; ++i) for (let j = 1; j &lt; n; ++j) grid[i][j] += Math.max(grid[i][j - 1], grid[i - 1][j]); return grid[m - 1][n - 1]; }; ","link":"https://AriesSK.github.io/post/jianzhi_47/"},{"title":"42. 连续子数组的最大和","content":"知识点 动态规划关键点 ：找到转移方程，用变量记录方程中涉及的状态。 本题关键在于：若前面的累加和为负数，则应当抛弃，从当前数开始累加。 题解 法一：暴力 双重遍历，时间复杂度O(n2)O(n^2)O(n2)： var maxSubArray = function(nums) { let max = nums[0]; for (let i = 0; i &lt; nums.length; ++i) { let sum = 0; for (let j = i; j &lt; nums.length; ++j) { sum += nums[j]; max = Math.max(max, sum); } } return max; }; 法二：动态规划 步骤： 状态定义： 设动态规划列表 dpdpdp，dp[i]dp[i]dp[i] 代表以 nums[i]nums[i]nums[i] 结尾 的连续子数组最大和； 转移方程： 若 dp[i−1]≤0dp[i - 1] \\leq 0dp[i−1]≤0，则 dp[i−1]+nums[i]≤nums[i]dp[i - 1] + nums[i] \\leq nums[i]dp[i−1]+nums[i]≤nums[i] 取 nums[i]nums[i]nums[i]，若 dp[i−1]&gt;0dp[i - 1] &gt; 0dp[i−1]&gt;0，则取 dp[i−1]+nums[i]dp[i - 1] + nums[i]dp[i−1]+nums[i]； 初始状态： max=nums[0max = nums[0max=nums[0]，dp[i−1]=0dp[i - 1] = 0dp[i−1]=0； 返回结果： dpdpdp 的最大值。 使用pre记录 dp[i−1]dp[i - 1]dp[i−1]，curr记录 dp[i]dp[i]dp[i] 的值，max 记录 dpdpdp 中的最大值： var maxSubArray = function(nums) { let max = nums[0], pre = 0; for (num of nums) { let curr = num + Math.max(pre, 0); max = Math.max(max, curr); pre = curr; } return max; }; ","link":"https://AriesSK.github.io/post/jianzhi_42/"},{"title":"63. 股票的最大利润","content":"知识点 动态规划需要解决所有的子问题并且把它们的解记录下来。 题解 法一：暴力 全遍历一遍，时间复杂度 O(n2)O(n^2)O(n2)： var maxProfit = function(prices) { // 设置最低利润为 0 let max = 0; for (let i = 0; i &lt; prices.length - 1; ++i) { for (let j = i + 1; j &lt; prices.length; ++j) { if (max &lt; prices[j] - prices[i]) max = prices[j] - prices[i]; } } return max; }; 法二：动态规划 由于必须得先买后卖，因此花费是到目前为止的最低买入价格。 步骤： 状态定义： 设动态规划列表 dpdpdp，dp[i]dp[i]dp[i] 代表以 prices[i]prices[i]prices[i] 结尾的子数组的最大利润，即前 iii 日的最大利润； 转移方程： dp[i]=max(dp[i−1],prices[i]−min(prices[0:i])dp[i] = max(dp[i - 1], prices[i] - min(prices[0 : i])dp[i]=max(dp[i−1],prices[i]−min(prices[0:i])； 初始状态： dp[0]=0dp[0] = 0dp[0]=0； 返回结果： dp[n−1]dp[n - 1]dp[n−1]， nnn 为列表长度。 var maxProfit = function(prices) { let cost = Number.MAX_VALUE, maxProfit = 0; for (const price of prices) { cost = Math.min(price, cost); // 第 n 天的价格减去目前为止最低的买入价 maxProfit = Math.max(price - cost, maxProfit) } return maxProfit; }; ","link":"https://AriesSK.github.io/post/jianzhi_63/"},{"title":"10 - II. 青蛙跳台阶问题","content":"知识点 类似斐波那契数列的问题，使用动态规划解决，需要注意初始状态的区别。 题解 动态规划 跳上 nnn 级台阶有 F(n)F(n)F(n) 种跳法，在所有跳法中，最后一步只有两种情况： 跳 111 级，有 F(n−1)F(n - 1)F(n−1) 种； 跳 222 级，有 F(n−2)F(n - 2)F(n−2) 种。 所以步骤如下： 状态定义： F(n)F(n)F(n) 表示跳上 nnn 级台阶的跳法总数； 转移方程： F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态： F(0)=1F(0) = 1F(0)=1，F(1)=1F(1) = 1F(1)=1，F(2)=2F(2) = 2F(2)=2； 返回结果： F(n)F(n)F(n)。 var numWays = function(n) { if (n &lt; 2) return 1; let p = 0, q = 1, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % (1e9+7); } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_ii/"},{"title":"10 - I. 斐波那契数列","content":"知识点 动态规划总结 Those who cannot remember the past are condemned to repeat it. 那些不记得过去的人注定要重蹈覆辙。 动态规划(Dynamic Programming, DP) 通过记住求过的解来节省时间，对每一个子问题只求解一次，并将结果存下来。 无后效性： 如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响 最优子结构性质： 大的问题的最优解可以由小问题的最优解推出 判断能否使用 DP 解决： 是否能够将大问题拆成几个小问题，且满足无后效性、最优子结构性质。 步骤： 状态定义： 定义一个状态，这是一个最优解的结构特征； 转移方程： 进行状态递推，得到递推公式； 初始状态： 进行初始化； 返回结果： 返回需要的解。 其中最重要的是状态转移方程。 题解 法一：递归 我第一时间想到的思路，且代码简单，但递归过程中重复的计算过多，导致超出了时间限制，无法通过： var fib = function(n) { if (n === 0) return 0; if (n === 1) return 1; return (fib(n - 1) + fib(n - 2)) % (1e9+7); }; 法二：递归 + 哈希表 法一的优化，将每次计算后的结果存在哈希表中，即可避免重复计算，但需要额外O(n)的空间： var fib = function(n, hash = new Map()) { if (n &lt;= 1) return n; if (hash.has(n)) return hash.get(n); // 注意给 1e9+7 加括号 否则会出错 else hash.set(n, (fib(n - 1, hash) + fib(n - 2, hash)) % (1e9+7)); return hash.get(n); }; 法三：动态规划 状态转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2) 由于只涉及到三个值，因此可以用滚动数组法使得空间复杂度为O(1)： 状态定义：F(n)F(n)F(n) 表示第 nnn 个斐波那契数； 转移方程：F(n)=F(n−1)+F(n−2)F(n) = F(n - 1) + F(n - 2)F(n)=F(n−1)+F(n−2)； 初始状态：F(0)=0F(0) = 0F(0)=0，F(1)=1F(1) = 1F(1)=1，F(2)=1F(2) = 1F(2)=1； 返回结果：F(n)F(n)F(n)。 var fib = function(n) { const MOD = 1e9+7; if (n &lt; 2) return n; let p = 0, q = 0, r = 1; for (let i = 2; i &lt;= n; ++i) { p = q; q = r; r = (p + q) % MOD; } return r; }; ","link":"https://AriesSK.github.io/post/jianzhi_10_i/"},{"title":"28. 对称的二叉树","content":"知识点 深度优先搜索的递归与迭代 dfs 的递归方法修改为迭代方法，常用的方式是引入一个队列来保证处理节点的顺序，同时还需要加入while循环。 JavaScript 树的比较 js 中的树是用对象模拟的，两个树无法用===比较，数组之类的引用数据类型也一样无法直接比较： // 虽然结构和值都相同，但是是两个不同的树，内存地址不同 let a = new TreeNode(1); let b = new TreeNode(1); a === b; // false 题解 深度优先搜索 递归 递归公式： F(l,r)F(l, r)F(l,r)：表示完成了节点 lll 和 rrr 的对比； F(l,r)=F(l.left,r.right)+F(l.right,r.left)F(l, r) = F(l.left, r.right) + F(l.right, r.left)F(l,r)=F(l.left,r.right)+F(l.right,r.left)。 终止条件： lll 和 rrr 同时为空 表示遍历完成 返回 true； lll 和 rrr 其中一个为空（结构不对称），或者 lll 和 rrr 值不同（值不对称），返回 false。 var isSymmetric = function(root) { return check(root, root); }; var check = function(l, r) { if (!l &amp;&amp; !r) return true; if (!l || !r || l.val !== r.val) return false; return check(l.left, r.right) &amp;&amp; check(l.right, r.left); } 迭代 双端队列，每次左右分别入队，左右分别出队： var isSymmetric = function(root) { const queue = []; queue.unshift(root); queue.push(root); // 这里即使 queue 为空队列也 !== null 不能用 !queue while (queue.length !== 0) { let l = queue.shift(); let r = queue.pop(); if (!l &amp;&amp; !r) continue; if (!l || !r || l.val !== r.val) return false; queue.unshift(l.right); queue.unshift(l.left); queue.push(r.left) queue.push(r.right); } return true; }; 普通队列，每次要比较的一对同时入队与出队： var isSymmetric = function(root) { const queue = []; queue.push(root); queue.push(root); while (queue.length !== 0) { let l = queue.pop(); let r = queue.pop(); if (!l &amp;&amp; !r) continue; if (!l || !r || l.val !== r.val) return false; queue.push(l.left); queue.push(r.right); queue.push(r.left) queue.push(l.right); } return true; }; ","link":"https://AriesSK.github.io/post/jianzhi_28/"},{"title":"27. 二叉树的镜像","content":"知识点 递归公式非常重要！！！ 题解 深度优先搜索 原树操作 递归公式： F(root)F(root)F(root)：完成以root为根节点的树的镜像； F(root)=F(root.left)+F(root.right)F(root) = F(root.left) + F(root.right)F(root)=F(root.left)+F(root.right) + 交换root左右子节点。 终止条件： root为空，即为叶子节点的子节点，返回null。 var mirrorTree = function(root) { if (!root) return null; const left = mirrorTree(root.left); const right = mirrorTree(root.right); root.left = right; root.right = left; return root; }; 复制树 递归公式： F(root)F(root)F(root)：创建新节点并复制root的值 ； F(root)=F(root.left)+F(root.right)F(root) = F(root.left) + F(root.right)F(root)=F(root.left)+F(root.right) + 交换root左右子节点。 终止条件： root为空，即为叶子节点的子节点，返回null。 var mirrorTree = function(root) { if (!root) return null; const newRoot = new TreeNode(root.val); newRoot.left = mirrorTree(root.right); newRoot.right = mirrorTree(root.left); return newRoot; }; ","link":"https://AriesSK.github.io/post/jianzhi_27/"},{"title":"26. 树的子结构","content":"知识点 深度优先遍历 深度优先遍历(DFS) 包括前序、中序、后序三种遍历。 dfs 算法中的前序遍历模板： var dfs = function (node) { // 节点判空必须放在操作前 防止报错 if (!node) return; // 节点为空，返回上一层 console.log(node.val); // 操作根节点 dfs(node.left); // 操作左子树 dfs(node.right); // 操作右子树 } dfs 往往需要使用递归，通常使用递归则不需要使用while循环。 题解 这道题融合了dfs遍历树和判断两树是否相同两道题，是 dfs 的变种，需要嵌套使用两种递归： 首先，遍历 AAA 中的每个节点node； 其次，判断以每个node为根节点的子树是否包含 BBB。 helper() 递归公式 ： F(A,B)F(A, B)F(A,B) ：检查 BBB 为根节点的树是否是 AAA 的子结构 F(A,B)=F(A.left,B.left)+F(A.right,B.right)F(A, B) = F(A.left, B.left) + F(A.right, B.right)F(A,B)=F(A.left,B.left)+F(A.right,B.right) + 检查 AAA, BBB 值和结构是否相同 终止条件： 遍历完 BBB 说明是子结构，return true； AAA 为空而 BBB 非空，说明结构不同，return false； AAA, BBB 的值不同，return false。 isSubStructure()递归公式： F(A,B)F(A, B)F(A,B) ：遍历 AAA 树，同时使用helper()判断 BBB 是否是 AAA 树的子结构； F(A,B)=F(A.left,B)+F(A.right,B)+helper(A,B)F(A, B) = F(A.left, B) + F(A.right, B) + helper(A, B)F(A,B)=F(A.left,B)+F(A.right,B)+helper(A,B)。 终止条件： BBB 是空树，题目给出不是任何树的子结构，return false； 遍历完 AAA，说明没找到 BBB 相同子结构，return false。 var isSubStructure = function(A, B) { if (!A || !B) return false; return helper(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B); }; var helper = function(A, B) { if (!B) return true; if (!A || A.val !== B.val) return false; return helper(A.left, B.left) &amp;&amp; helper(A.right, B.right); } 注意 dfs 中判空的操作要放在最前面，不然会出错。比如helper()中的 BBB 判空如果放在判断 AAA, BBB 值是否相同后面，则在 BBB 为空 AAA 不为空的情况下会返回false，但实际上应当返回 true。 ","link":"https://AriesSK.github.io/post/jianzhi_26/"},{"title":"32 - III. 从上到下打印二叉树 III","content":"知识点 JavaScript 的双端队列 js 中的双端队列也是用数组模拟的： 栈： 右进右出，左栈底右栈头； 队列： 右进左出，左队头右队尾。 push() // 队尾入队 unshift(); // 队头入队 题解 广度优先搜索 该题需要判断该层是奇数层还是偶数层： var levelOrder = function(root) { const queue = []; const number = []; if (!root) return number; queue.push(root); while (queue.length) { const count = queue.length; // 在这一步之后 number.length 就等同于当前的层数 number.push([]); for (let i = 0; i &lt; count; ++i) { root = queue.shift(); // 奇数层左到右 偶数层右到左 if (number.length % 2) number[number.length - 1].push(root.val); else number[number.length - 1].unshift(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } } return number; }; 这题判断奇偶的方法有三种，第三种最 smart： // 使用数字记录层数 let tier = 1; ++ tier; // 使用布尔类型记录奇偶 let leftOrder = true; leftOrder = !leftOrder; // 使用 number 的长度奇偶判断，长度即当前层数 if (number.length % 2) // 右到左 else // 左到右 ","link":"https://AriesSK.github.io/post/jianzhi_32_iii/"},{"title":"32 - II. 从上到下打印二叉树 II","content":"知识点 JavaScript 的二维数组 js 中创建二维数组是在一维数组中再添加数组： let array = []; // array = [] 先声明一维数组 array.push([]); // array = [[]] 扩展为二维数组 array.push([]); // array = [[], []] 持续扩展 在创建数组的时候最好使用fill()完成赋值，否则容易出错。 题解 深度优先搜索 使用双重循环保证每次打印一层： var levelOrder = function(root) { const queue = []; const number = []; if (!root) return number; queue.push(root); while (queue.length) { // 注意这里必须保存队列的长度，因为后面 shift()，push() 均会改变队列的长度 // queue.length 代表了当前层的长度 // 循环中的 const 每次循环会创建新的实例，因此不会报错 const count = queue.length; // 创建二维数组 number.push([]); // 使用 for 循环使每一层的打印在一个 while 循环中完成 for (let i = 0; i &lt; count; ++i) { root = queue.shift(); number[number.length - 1].push(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } } return number; }; ","link":"https://AriesSK.github.io/post/jianzhi_32_ii/"},{"title":"32 - I. 从上到下打印二叉树 I","content":"知识点 广度优先搜索 广度优先搜索(BFS)，也叫层次遍历，是借助队列的先入先出特性(FIFO)实现的。 在 JavaScript 中是用数组来模拟队列的： // 下面四种数组操作均会改变数组的长度 push() // 数组末添加 入队 返回长度 pop() // 数组末弹出 返回弹出元素 unshift() // 数组头添加 返回长度 shift() // 数组头弹出 出队 返回弹出元素 JavaScript 的if表达式 if (a) {} // 只要 a 不为 0, null, undefined, false 均会执行内部操作 题解 深度优先搜索 经典的 Breath First Search： var levelOrder = function(root) { // 数组可以用 const 声明 const queue = []; const number = []; // 空树的特殊情况，不要忘记考虑！ if (!root) return number; queue.push(root); while (queue.length) { // 先弹出后处理 root = queue.shift(); number.push(root.val); if (root.left) queue.push(root.left); if (root.right) queue.push(root.right); } return number; }; ","link":"https://AriesSK.github.io/post/jianzhi_32_i/"},{"title":"50. 第一个只出现一次的字符","content":"知识点 JavaScript 中的for循环 for in，in 指的是数组的下标： var array = [a,b,c,d,e] for (let i in array) { console.log(i); // 0,1,2,3,4 console.log(array[i]); // a,b,c,d,e } for of，of 指的是数组的值： for (let i of array) { console.log(i); // a,b,c,d,e } JavaScript 字符串 Array.from()能够将字符串拆成字符数组。 js 中没有Char只有String，Char是长度为一的String。 js 不能像 java 那样使用单字符相减获得 ASCII 码的差值，因为字符只是单字符的字符串，因此使用一下方法获取 ASCII 码值： 'a'.charCodeAt(0) // 97 题解 应用哈希表，遍历两遍字符串，第一遍存并判断是否只出现一次，第二遍输出： var firstUniqChar = function(s) { let hash = new Map(); for (let i = 0; i &lt; s.length; ++i) { if (!hash.has(s.charAt(i))) hash.set(s.charAt(i), true); else hash.set(s.charAt(i), false); } for (let i = 0; i &lt; s.length; ++i) { if (hash.get(s.charAt(i))) return s.charAt(i); } return ' '; }; // 简单写法 var firstUniqChar = function(s) { let hash = new Map(); let charArray = Array.from(s); for (let c of charArray) { hash.set(c, !hash.has(c)); } for (let c of charArray) { if (hash.get(c)) return c; } return ' '; }; 也可以使用长度26的数组，记录每个字母的出现次数。 ","link":"https://AriesSK.github.io/post/jianzhi_50/"},{"title":"11. 旋转数组的最小数字","content":"知识点 这一题的二分法很特别，因为在numbers[m] = numbers[r]的情况下，无法判断旋转点在哪个半区，因此无法通过常规方法缩小区间，而需要使用--r来缩小区间，而--r的终止条件应当是l === r时，因此本题需要使用模板二，二分法具体模板见53 - I. 在排序数组中查找数字 I。 题解 法一：暴力 找到第一个变小的数字： var minArray = function(numbers) { for (let i = 1; i &lt; numbers.length; ++i) { if (numbers[i] &lt; numbers[i - 1]) return numbers[i]; } // 旋转0个数的情况 return numbers[0]; }; 法二：二分法 要保证每次缩小区间后最小值仍在区间内。 二分会有三种情况： 当 nums[m]&gt;nums[r]nums[m] &gt; nums[r]nums[m]&gt;nums[r] 时： mmm 一定在左排序数组中，即旋转点 xxx 一定在 [m+1,r][m + 1, r][m+1,r] 闭区间内，因此执行 r=m+1r = m + 1r=m+1； 当 nums[m]&lt;nums[r]nums[m] &lt; nums[r]nums[m]&lt;nums[r] 时： mmm 一定在右排序数组中，即旋转点 xxx 一定在 [l,m][l, m][l,m] 闭区间内，因此执行 r=mr = mr=m； 当 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 时： 无法判断 mmm 在哪个排序数组中，即无法判断旋转点 xxx 在 [l,m][l, m][l,m] 还是 [m+1,r][m + 1, r][m+1,r] 区间中，但由于 nums[m]=nums[r]nums[m] = nums[r]nums[m]=nums[r] 并且 mmm 一定在区间内，因此即使 num[r]num[r]num[r] 是最小值，也可以执行 r=r−1r = r - 1r=r−1 缩小范围。 为什么本题二分法不用 nums[m]nums[m]nums[m] 和 nums[l]nums[l]nums[l] 作比较？ 避免了旋转 000 个数出现的问题。 二分目的是判断 mmm 在哪个排序数组中，从而缩小区间。而在 nums[m]&gt;nums[l]nums[m] &gt; nums[l]nums[m]&gt;nums[l] 情况下，无法判断 mmm 在哪个排序数组中。本质上是由于 rrr 初始值肯定在右排序数组中；但 lll 初始值无法确定在哪个排序数组中。 var minArray = function(numbers) { let l = 0, r = numbers.length; while (l &lt; r) { const m = l + Math.floor((r - l) / 2); if (numbers[m] &gt; numbers[r]) l = m + 1; else if (numbers[m] &lt; numbers[r]) r = m; else --r; } return numbers[l]; }; ","link":"https://AriesSK.github.io/post/jianzhi_11/"},{"title":"04. 二维数组中的查找","content":"知识点 本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。 题解 法一：暴力 注意题目中提示了输入可能是空数组，这种情况需要特别考虑： var findNumberIn2DArray = function(matrix, target) { // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑 if (!matrix.length) return false; let n = matrix.length, m = matrix[0].length; for (let i = 0; i &lt; n; ++i) { for (let j = 0; j &lt; m; ++j) { if (matrix[i][j] === target) return true; } } return false; }; 法二：标志数 将矩阵逆时针旋转 45°，能够发现其结构类似二叉搜索树，左分支更小，右分支更大； 因此从根节点，也就是右上角开始搜索，比target大就向左，否则向右； 矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。 // 右上角开始 var findNumberIn2DArray = function(matrix, target) { if (!matrix.length) return false; let i = 0, j = matrix[0].length - 1; while (i &lt; matrix.length &amp;&amp; j &gt;= 0) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &lt; target) ++i; else --j; } return false; }; // 左下角开始 var findNumberIn2DArray = function(matrix, target) { let i = matrix.length - 1, j = 0; // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错 while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) { if (matrix[i][j] === target) return true; else if (matrix[i][j] &gt; target) --i; else ++j; } return false; }; ","link":"https://AriesSK.github.io/post/jianzhi_04/"},{"title":"53 - II. 0~n-1中缺失的数字","content":"知识点 JavaScript 的排序函数 sort()函数： sort() // 默认按字母升序，40 在 5 前面，是先调用 toString() 再比较 sort(function(a, b){return a - b}) // 按数字升序 sort((a, b) =&gt; a - b) // 按数字升序的简写 sort(function(a, b){return b - a}) // 按数字降序 sort((a, b) =&gt; b - a) // 按数字降序的简写 JavaScript 的箭头函数 // 下面三个等同 var sum = function(a, b) { return a + b; }; var sum = (a, b) =&gt; { return a + b; }; var sum = (a, b) =&gt; a + b; // 一个参数可不用括号 var sum = x =&gt; { retrun x; }; // 没有或多个参数均需要括号 var sum = () =&gt; { return 1; }; 题解 法一：二分法 数组下标与值不同说明已经发生了数字缺失： var missingNumber = function(nums) { let left = 0, right = nums.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === mid) left = mid + 1; else right = mid - 1; } return left; }; 法二：数学 高斯求和公式−目前的和=缺失的数字高斯求和公式 - 目前的和 = 缺失的数字高斯求和公式−目前的和=缺失的数字： var missingNumber = function(nums) { const n = nums.length + 1; let total = Math.floor(n * (n - 1) / 2); let arrSum = 0; for (let i = 0; i &lt; n - 1; i++) { arrSum += nums[i]; } return total - arrSum; }; 法三：暴力 找第一个下标与值不同的位置： var missingNumber = function(nums) { // 如果乱序则先排序 nums.sort((a, b) =&gt; a - b); const n = nums.length + 1; for (let i = 0; i &lt; n - 1; i++) { if (nums[i] !== i) { return i; } } return n - 1; }; ","link":"https://AriesSK.github.io/post/jianzhi_53_ii/"},{"title":"53 - I. 在排序数组中查找数字 I","content":"知识点 二分法总结 有序的序列查找，优先考虑二分法。 无重复元素 查找target在序列中是否出现： const binarySearch(nums, target) { let left = 0, right = nums.length; while (left &lt;= right) { // 能够防止溢出 const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return -1; }; 有重复元素 查找首个大于target的元素序号； 查找首个大于等于target的元素序号（等同于查找首个大于target - 1的元素序号）。 const binarySearch(nums, target) { let left = 0, right = num.length; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] &lt;= target) left = mid + 1; else right = mid - 1; } return i; } 循环条件写left &lt;= right和left &lt; right的区别 区别在于是否包含最右边的边界值，因为当left==right时，不会再进入循环体，所以right初始化时就取值为len(nums)，这样在for循环中就能保证是在这样一个左闭右开的区间 [left,right)[left,right)[left,right)，且right赋值应该为right = mid而非right = mid-1，因为右半边是开区间，取mid-1就无法验证到mid-1是否是目标值。简单来说区别是right所代表的位置是否参与计算。 两种写法模板 // 模板一 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt;= right 的情况下 right = nums.length - 1 以保证 mid 能够取到 const binarySearch = function(nums, target) { let left = 0, right = nums.length - 1; while (left &lt;= right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid - 1; } return left; } // 模板二 // 若 target === nums[nums.length - 1] // 在循环条件是 left &lt; right 的情况下 right = nums.length 因为 mid 最多取到 right - 1 const binarySearch = function(nums, target) { let left = 0, right = nums.length; while (left &lt; right) { const mid = left + Math.floor((right - left) / 2); if (nums[mid] === target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else right = mid; } return left; } JavaScript 中的数组越界 js 数组允许越界，越界返回的是undefined。 js 在非严格模式的情况下变量允许不声明直接赋值。 题解 法一：暴力 逐个遍历： var search = function(nums, target) { let start = -1, end = -1; for (let i = 0; i &lt; nums.length; ++i) { if (nums[i] === target) { start = i; break; } } if (start === -1) return 0; // 这里只有在 js 中才行 因为允许数组越界 正常 i = nums.length 时 若nums[i] === target 则 end = nums.length for (let i = start;; ++i) { if (nums[i] !== target) { end = i; break; } } return end - start; }; 法二：二分法 这里的binarySearch()方法目的实际上是寻找tar值能够插入的最右的位置，因此答案为target的右边界减去(target - 1)的右边界。 var search = function(nums, target) { return binarySearch(nums, target) - binarySearch(nums, target - 1); } const binarySearch = function(nums, tar) { let i = 0, j = nums.length - 1; // 用 &lt;= 保证 tar 能够插入最右的位置 而不是 最右的前一位 while (i &lt;= j) { // 不像 java 在 js 中需要手动取整 const m = Math.floor((i + j) / 2); // 由于找最右插入位置 因此即使nums[m] = tar 插入位置也在 m + 1 及之后 if (nums[m] &lt;= tar) i = m + 1; else j = m - 1; } // i 永远比 j 大1 只能返回 i return i; }; // while 中 &lt;= 换为 &lt; 后 改变 j 的初始值 和 j 每次的缩小值 const binarySearch = function(nums, target) { let i = 0, j = nums.length; while (i &lt; j) { const m = i + Math.floor((j - i) / 2); if (nums[m] &lt;= target) i = m + 1; else j = m; } return i; } ","link":"https://AriesSK.github.io/post/jianzhi_53_i/"},{"title":"03. 数组中重复的数字","content":"知识点 JavaScript 中的Map对象与Set对象 Map对象存储键值对，键值是唯一的，重复赋值会覆盖，一些常用的方法如下： set(key, value) get(key) has(key) delete(key) Set对象是唯一值的集合，一些常用的方法如下： add(key) clear() // 删除所有 delete(key) entries() keys() values() // 返回值的数组，分别返回键值对、键名、键值，在 Set 中结果相同 has(key) size() Map和Set的 key 可以是任何数据类型。 题解 法一：哈希表 我一开始想到的是使用Map： var findRepeatNumber = function(nums) { let hash = new Map(); for (let i = 0; i &lt; nums.length; ++i) { // 这里需要使用 has()，而不是 get()，防止 get() 取到 0 导致判断出错 if (!hash.has(nums[i])) hash.set(nums[i], i); else return nums[i]; } }; 后来发现Map存储的是键值对，但在这题中只需要存 key，不需要存 value，因此用Set更好： var findRepeatNumber = function(nums) { let set = new Set(); for (let i = 0; i &lt; nums.length; ++i) { if (!set.has(nums[i])) set.add(nums[i]); else return nums[i]; } }; 法二：原地算法 遍历数组nums，设索引初始值为i = 0： 若nums[i] = i：说明此数字已在对应索引位置，无需交换，因此跳过； 若nums[nums[i]] = nums[i]：代表索引nums[i]处和索引i处的元素值都为nums[i]，即找到一组重复值，返回此值nums[i]； 否则：交换索引为i和nums[i]的元素值，将此数字交换至对应索引位置。 若遍历完毕尚未返回，则返回 -1。 var findRepeatNumber = function(nums) { let i = 0; while (i &lt; nums.length) { if (nums[i] === i) { // 直到该位置已放置正确数字再处理下一个位置，以保证数组被完全遍历 ++i; continue; } if (nums[nums[i]] === nums[i]) return nums[i]; let tmp = nums[i]; nums[i] = nums[nums[i]]; // 注意这里 num[i] 已经被修改了值，因此不能用 nums[nums[i]] nums[tmp] = tmp; } return -1; }; ","link":"https://AriesSK.github.io/post/jianzhi_03/"},{"title":"58 - II. 左旋字符串","content":"知识点 JavaScript 的字符串操作函数 charAt(index) // 返回指定索引位置的字符 indexOf() // 返回字符串中检索指定字符第一次出现的位置 replace(searchvalue,newvalue) // 替换第一个子串 replaceAll(searchvalue,newvalue) // 替换所有子串 slice(start, end) // 提取字符串的片段 以新字符串返回 split(separator,limit) // 将字符串分割为子字符串数组 substr(start,length) // 从起始索引号提取字符串中指定数目的字符 substring(start, end) // 提取字符串中两个指定的索引号之间的字符 trim() // 移除字符串首尾空白 题解 substring()： var reverseLeftWords = function(s, n) { return s.substring(n) + s.substring(0, n); }; charAt() + 取余： var reverseLeftWords = function(s, n) { let res = &quot;&quot;; for (let i = 0; i &lt; s.length; ++i) res += s.charAt((i + n) % s.length); return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_58_ii/"},{"title":"05. 替换空格","content":"知识点 JavaScript 中的字符赋值 在 js 中不能直接对字符串中字符赋值： var replaceSpace = function(s) { for (let i = 0; i &lt; s.length; ++i) { if (s[i] === &quot; &quot;) s[i] = &quot;%20&quot;; } return s; }; 正确的做法是使用replace()操作。 题解 不使用字符串方法的解法： var replaceSpace = function(s) { let res = '' for(let i = 0;i &lt; s.length; i++) { if (s[i] === &quot; &quot;) res += &quot;%20&quot;; else res += s[i]; } return res; } 可以使用split()将字符串转化为数组： var replaceSpace = function(s) { arr = s.split(&quot; &quot;); let res = &quot;&quot;; for (let i = 0; i &lt; arr.length; ++i) { if (i === arr.length - 1) res += arr[i]; else res += arr[i] + &quot;%20&quot;; } return res; }; 可以使用字符串的自带函数，注意replace()只替换第一个，而replaceAll()替换全部： var replaceSpace = function(s) { return s.replaceAll(&quot; &quot;, &quot;%20&quot;); }; split()以特定分隔符将字符串拆分为数组，join()则以特定分隔符将数组中元素连接成字符串： var replaceSpace = function(s) { return s.split(&quot; &quot;).join(&quot;%20&quot;); }; ","link":"https://AriesSK.github.io/post/jianzhi_05/"},{"title":"35. 复杂链表的复制","content":"知识点 JavaScript 链表 js 中不提供链表API，是使用对象模拟的，因此解法特殊些。 一个包含三个节点的单链表如下表示（data, next都是对象的属性）： list = { data: 1, next: { data: 2, next: { data: 3, next: null, }, }, }; 题目中的复杂链表实现如下： functuon Node(val, next, random) { this.val = val; this.next = next; this.random = random; } 题解 法一：回溯 + 哈希表 用于将所有b中可枚举属性复制到a中，重名属性则后者覆盖前者： Object.assign(a, b1, b2, ...); 哈希表存值： hashmap.set(key, value); 注意空链表的特殊情况： var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { // 只设置val属性 hash.set(head, {val: head.val}); // 递归复制 next 和 random 属性 Object.assign(hash.get(head), {next: copyRandomList(head.next, hash), random: copyRandomList(head.random, hash)}); } return hash.get(head); }; 也可以在存节点时设置所有的属性，后续递归修改next和random属性的值即可: var copyRandomList = function(head, hash = new Map()) { if (head === null) return null; if (!hash.has(head)) { hash.set(head, {val: head.val, next: head.next, random: head.random}); hash.get(head).next = copyRandomList(head.next, hash); hash.get(head).random = copyRandomList(head.random, hash); } return hash.get(head); }; 法二：迭代 + 节点拆分 先画图后写代码不需要使用哈希表，空间复杂度低： var copyRandomList = function(head) { if (head === null) return null; // 复制节点 for (let node = head; node !== null; node = node.next.next) { const newNode = new Node(node.val, node.next, null); node.next = newNode; } // 复制 random 属性，注意 node.random 指空的情况 for (let node = head; node !== null; node = node.next.next) { const newNode = node.next; newNode.random = (node.random !== null) ? node.random.next : null; } // 创建新的头节点，防止后面断开后找不到新链表的头节点 const newHead = head.next; // 断开新旧链表，注意最后一个节点的 next 指空的情况 for (let node = head; node !== null; node = node.next) { const newNode = node.next; node.next = node.next.next; newNode.next = (newNode.next !== null) ? newNode.next.next : null; } return newHead; }; ","link":"https://AriesSK.github.io/post/jianzhi_35/"},{"title":"24. 反转链表","content":"知识点 递归总结 递归=递归公式+终止条件递归 = 递归公式 + 终止条件递归=递归公式+终止条件 先写出公式，再转换代码。 题解 涉及链表操作的题，建议先把过程画出来，再写成代码。 法一：迭代（双指针） 每次推进一个节点，需要注意提前存next节点，防止断链后找不到后续节点： var reverseList = function(head) { // 从 null 开始 考虑单节点情况 let prev = null; let curr = head; while (curr) { let next = curr.next; curr.next = prev; prev = curr; curr = next; } return prev; }; 法二：递归 递归方法需要注意的是递归函数和终止条件： var reverseList = function(head) { // 终止条件： 空链表 或 最后一个节点 if (head == null || head.next == null) return head; // 递归函数：反转 head.next + 处理 head // 反转 head.next let res = reverseList(head.next); // 处理 head，下一个节点指向自己，自己指空 head.next.next = head; head.next = null; return res; }; ","link":"https://AriesSK.github.io/post/jianzhi_24/"},{"title":"06. 从头到尾打印链表","content":"知识点 JavaScript 中的栈 js 中并不存在Stack这个数据结构的API，是使用数组中的两种操作模拟形成的： push() // 向数组末添加元素 pop() // 弹出并返回数组末元素，会改变数组的长度 题解 使用栈倒着打印链表： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.push(ptr.val); ptr = ptr.next; } let number = []; // 下面这行是错误的写法，因为 pop() 改变了 stack.length，导致出错 // for (let i = 0; i &lt; stack.length; ++i) number[i] = stack.pop(); let length = stack.length; for (let i = 0; i &lt; length; ++i) number[i] = stack.pop(); return number; }; 使用unshift()能够直接向数组开头添加元素并返回新长度： var reversePrint = function(head) { let ptr = head; let stack = []; while (ptr != null) { stack.unshift(ptr.val) ptr = ptr.next; } return stack }; ","link":"https://AriesSK.github.io/post/jianzhi_06/"},{"title":"30. 包含min函数的栈","content":"知识点 JavaScript 的栈 js 中没有栈的API，是使用数组模拟的，因此可以直接通过下标访问栈中任意元素。 题解 利用辅助栈，在主栈与辅助栈同时压入元素。主栈正常，辅助栈比较栈顶与将与将压入元素，选取较小的入栈，保证辅助栈的栈顶元素是就是主栈的 minminmin： var MinStack = function() { this.stack = []; this.min_stack = []; }; /** * @param {number} x * @return {void} */ MinStack.prototype.push = function(x) { this.stack.push(x); // 避免 min_stack 为空时 push 时出错 if (!this.min_stack.length) this.min_stack.push(x); else this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x)); }; /** * @return {void} */ MinStack.prototype.pop = function() { this.stack.pop(); this.min_stack.pop(); }; /** * @return {number} */ MinStack.prototype.top = function() { // java 中 peek() 返回栈顶元素 ，pop()取出并返回栈顶元素 // js 中只有pop() 没有 peek()，访问栈顶元素使用下标 return this.stack[this.stack.length - 1]; }; /** * @return {number} */ MinStack.prototype.min = function() { return this.min_stack[this.min_stack.length - 1]; }; ","link":"https://AriesSK.github.io/post/jianzhi_30/"},{"title":"09. 用两个栈实现队列","content":"知识点 JavaScript 中的prototype js 中通过构造函数的 prototype 原型属性给对象添加新的方法。 判空 js 中通过长度判空 if(!stack.length) // 如果栈为空 java 中使用isEmpty()判空 题解 使用两个栈实现队列，一个入栈一个出栈，在入栈与出栈中的元素转移时，入栈弹出的是后入元素，应当先压入出栈，从而保证先入先出： // 构造函数 var CQueue = function() { this.inStack = []; this.outStack = []; }; /** * @param {number} value * @return {void} */ // 使用 prototype 给构造函数添加新的属性 // 入队 压入进栈 CQueue.prototype.appendTail = function(value) { this.inStack.push(value); }; /** * @return {number} */ // 出队 CQueue.prototype.deleteHead = function() { if (!this.outStack.length) { // 入栈出栈均为空 队列中没有元素 if (!this.inStack.length) return -1; // 出栈为空 进栈有元素 将进栈元素全部压入出栈 先入先出 while (this.inStack.length) { this.outStack.push(this.inStack.pop()) } } // 出栈有元素 直接弹出 return this.outStack.pop(); }; ","link":"https://AriesSK.github.io/post/jianzhi_09/"}]}