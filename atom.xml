<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-06-29T04:09:13.669Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[65. 不用加减乘除做加法]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_65/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_65/">
        </link>
        <updated>2022-06-29T02:56:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="位运算替代加法">位运算替代加法</h3>
<p>假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>的<strong>无进位和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></strong>，<strong>进位为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></strong>，则普通的加法 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">s = a + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 可以<strong>转化为</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>=</mo><mi>n</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">s = n + c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="位运算">位运算</h3>
<p>观察 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的无进位和与进位：</p>
<table>
<thead>
<tr>
<th>a(i)</th>
<th>b(i)</th>
<th>n(i)</th>
<th>c(i + 1)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>根据上表可以发现<strong>无进位和</strong>和<strong>异或运算</strong>规律相同，<strong>进位</strong>和<strong>与运算</strong>规律相同（需左移一位），由于加上进位后可能出现新的进位，因此需要一直循环直到进位为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。<br>
递归：</p>
<pre><code class="language-js">var add = function(a, b) {
    if (!b) return a;
    return add(a ^ b, (a &amp; b) &lt;&lt; 1);
};
</code></pre>
<p>循环：</p>
<pre><code class="language-js">var add = function(a, b) {
    while (b) {
        let c = (a &amp; b) &lt;&lt; 1;
        a ^= b; // a 始终保存当前和
        b = c; // b 始终保存进位
    }
    return a;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[15. 二进制中1的个数]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_15/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_15/">
        </link>
        <updated>2022-06-29T01:44:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的位运算">JavaScript 的位运算</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>均为 1 返回 1</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>有一个为 1 返回1</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>值不同返回 1</td>
</tr>
<tr>
<td>~</td>
<td>按位非</td>
<td>反转</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>左移一位，右边填充 0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>有符号右移</td>
<td>右移一位，左边填充符号位的值</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右移</td>
<td>右移一位，左边填充 0</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="题解">题解</h2>
<h3 id="亦或">亦或</h3>
<p>亦或 0，常用于判断奇偶，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 为整数的位数：</p>
<pre><code class="language-js">var hammingWeight = function(n) {
    let count = 0;
    for (let i = 0; i &lt; 32; ++i) { // while (n) {
        if (n &amp; 1) ++count;
        n &gt;&gt;&gt;= 1;
    }
    return count;
};
</code></pre>
<p>巧用 <code>n &amp; (n - 1)</code>，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的二进制位数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">logn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span></span></span></span>：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 相对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，最右边的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 右侧均变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；<br>
因此<code>n &amp; (n - 1)</code>起到的作用就是每次消去最右边的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<pre><code class="language-js">var hammingWeight = function(n) {
    let count = 0;
    while (n) {
        n &amp;= (n - 1);
        ++count;
    }
    return count;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[33. 二叉搜索树的后序遍历序列]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_33/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_33/">
        </link>
        <updated>2022-06-28T08:22:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="树的先序-中序-后序遍历">树的先序、中序、后序遍历</h3>
<p>对于此类题目：</p>
<ol>
<li>首先要了解其根、左子树、右子树的在数组中的区间划分；</li>
<li>其次根据题意找出对单个区间的操作；</li>
<li>对每个区间递归处理。</li>
</ol>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一递归分治">法一：递归分治</h3>
<p>每判断一个都需要遍历数组区间，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。<br>
判断是否是二叉搜索树的后序遍历：</p>
<ol>
<li>首先在数组区间中的最后一个节点是该树（子树）的根节点；</li>
<li>随后根据根节点判断数组剩余是否分成了小于根节点和大于根节点两部分，并且小于部分位于大于部分左侧；</li>
<li>递归判断每一子树的正确性。</li>
</ol>
<pre><code class="language-js">var verifyPostorder = function(postorder) {
    return dfs(postorder, 0, postorder.length - 1);

    function dfs(postorder, l, r) {
        // 超过叶子节点，返回 true
        if (l &gt; r) return true; 
        // 从区间左侧开始遍历
        let i = l; 
        // 找到第一个大于等于根节点的数，可以保证其左侧是小于部分
        while (postorder[i] &lt; postorder[r]) ++i;
        let m = i;
        // 判断其及其右侧是否是大于部分
        while (postorder[i] &gt; postorder[r]) ++i;
        return i === r &amp;&amp; dfs(postorder, l, m - 1) &amp;&amp; dfs(postorder, m, r - 1);
    };
};
</code></pre>
<h3 id="法二栈">法二：栈</h3>
<p><img src="https://AriesSK.github.io/post-images/1656419512359.png" alt="" loading="lazy"><br>
使用栈将遍历过的节点储存起来，当遇到递减的节点时，栈中最底下也是值最小的那个是它的父节点（递增才入栈，递减就出栈至空栈，栈底元素值最接近）。</p>
<pre><code class="language-js">var verifyPostorder = function(postorder) {
    const stack = [];
    // 设置初始根节点，值为无限大，原根节点视作其左节点
    let root = Number.MAX_VALUE;
    // 将`preorder`倒序，入栈遍历的元素
    for (let i = postorder.length - 1; i &gt;= 0; --i) {
        // 遍历发现左子树有元素比根节点大，返回 false
        if (postorder[i] &gt; root) return false;
        // 发现递减元素，出栈至空，更新 root
        while (stack.length &amp;&amp; stack[stack.length - 1] &gt; postorder[i])
            root = stack.pop();
        stack.push(postorder[i]);
    }
    // 遍历完毕，均满足规则，返回 true
    return true;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[16. 数组的整数次方]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_16/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_16/">
        </link>
        <updated>2022-06-28T06:21:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的位移运算">JavaScript 的位移运算</h3>
<pre><code class="language-js">&gt;&gt; // 有符号位移，右移一位，左边补符号位的值，0 正 1 负
&gt;&gt;&gt; // 无符号位移，右移一位，左边补 0
</code></pre>
<p>js 中的向下取整往往可以使用<code>&gt;&gt;</code>来实现：</p>
<pre><code class="language-js">2 &gt;&gt; 1; // 1
3 &gt;&gt; 1; // 1
-3 &gt;&gt; 1; // -2
</code></pre>
<p>本题中需要判断奇偶的操作：</p>
<pre><code class="language-js">if (n % 2) (n - 1) / 2;
else n / 2;
</code></pre>
<p>可以直接简化成：</p>
<pre><code class="language-js">n &gt;&gt; 1;
</code></pre>
<h3 id="javascript-的整数范围">JavaScript 的整数范围</h3>
<p>js 符号整数范围 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[-2^{31}, 2^{31}-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，即 [-2147483648, 2147483647]，当值为 2147483648 时超出了有符号整数的范围，js 会自动转换为无符号整数。<br>
无符号整数因为多一位数用来保存值，因此范围更大。<br>
对于正数来说，使用``&gt;&gt;<code>和</code>&gt;&gt;&gt;<code>效果是一致的，由于本题法三中有测试用例会溢出并转为无符号整数，因此需要使用</code>&gt;&gt;&gt;`。</p>
<h3 id="javascript-的取余运算">JavaScript 的取余运算</h3>
<p>常见的判断奇偶是使用取余运算<code>n % 2</code>，然而用位运算<code>n &amp; 1</code>也可以实现，并且位运算是底层运算，速度较快。<br>
<code>&amp;</code>位运算是在两个数相同位上均为 1 才返回 1，否则返回 0，因此<code>n &amp; 1</code>就能够判断最右一位是否为 1，<code>n &amp; 1</code>返回 1 表示奇数，返回 0 表示偶数。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>一秒能想到的思路，明显会超时，舍弃：</p>
<pre><code class="language-js">var myPow = function(x, n) {
    let res = 1;
    if (n &gt;= 0) {
        while (n--) res *= x; 
    } else {
        while (n++) res /= x;
    }
    return res;
};
</code></pre>
<h3 id="法二快速幂-递归">法二：快速幂 + 递归</h3>
<p>分治思路，每次减半，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，由于递归函数会调用栈空间，因此空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var myPow = function(x, n) {
    let tmp = 0; // 存放计算结果，避免重复计算
    if (n === 0) return 1;
    if (n === 1) return x;
    if (n === -1) return 1 / x;
    // 不论奇偶均向下取整 奇数多乘一次本身
    if (n % 2) {
        tmp = myPow(x, (n - 1) / 2); // n &gt;&gt; 1
        return tmp * tmp * x;
    } 
    else {
        tmp = myPow(x, n / 2); // n &gt;&gt; 1
        return tmp * tmp;
    } 
};
</code></pre>
<h3 id="法三快速幂-迭代">法三：快速幂 + 迭代</h3>
<p>把递归转化为迭代能够降低空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var myPow = function(x, n) {
    if (x === 0) return 0;
    let res = 1;
    if (n &lt; 0) { // 把负次幂转化为正次幂计算
        x = 1 / x;
        n = -n;
    }
    while (n) {
        if (n &amp; 1) res *= x;
        x *= x;
        // 这里需要使用无符号位移，因为是超过了有符号范围的正数
        n &gt;&gt;&gt;= 1;
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[07. 重建二叉树]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_07/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_07/">
        </link>
        <updated>2022-06-28T03:55:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的for-in的坑">JavaScript 的<code>for in</code>的坑</h3>
<p>看下面的例子，可以发现<code>for in</code>遍历的属性值是<strong>字符串</strong>而不是<strong>数字</strong>：</p>
<pre><code class="language-js">const inorder = [1,2,3];
for (let i = 0; i &lt; inorder.length; ++i) console.log(i, typeof i); // 0 'number', 1 'number', 2 'number'
for (const i in inorder) console.log(i, typeof i); // 0 string, 1 string, 2 string
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<p>###分治<br>
前序遍历数组： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序；<br>
中序遍历数组： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序；<br>
因此本题思路为：在<strong>前序遍历</strong>中顺序遍历<code>node</code>作为根节点，在<strong>中序遍历</strong>中根据<code>node</code>将数组划分为 [ 左子树 | 根节点 | 右子树 ]。<br>
<strong>分治算法：</strong></p>
<ul>
<li>
<p><strong>递推参数：</strong> 根节点在前序遍历的索引 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>、子树在中序遍历的左右边界 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>；</p>
</li>
<li>
<p><strong>终止条件：</strong> 当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>&gt;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left &gt; right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span>，代表已经越过叶节点，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">null</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>；</p>
</li>
<li>
<p><strong>递推工作：</strong></p>
<ol>
<li>建立根节点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span>：节点值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mo>[</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">preorder[root]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span></span></span>；</li>
<li>划分左右子树：查找根节点在中序遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">inorder</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 中的索引 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>；</li>
<li>构建左右子树：左右子树递归处理；</li>
</ol>
</li>
<li>
<p><strong>返回值：</strong> 回溯返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">node</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span>，作为上一层递归中根节点的左 / 右子节点。</p>
</li>
</ul>
<pre><code class="language-js">var buildTree = function(preorder, inorder) {
    const map = new Map();
    for (let i = 0; i &lt; inorder.length; ++i) map.set(inorder[i], i);
    return dfs(0, 0, inorder.length - 1);

    // root 是 preorder 中的下标，left 和 right 是 inorder 中的下标
    function dfs(root, left, right) {
        if (left &gt; right) return null;
        const node = new TreeNode(preorder[root]);
        // index 表示 preorder 中的根节点在 inorder 中的下标
        const index = map.get(preorder[root]);
        node.left = dfs(root + 1, left, index - 1);
        // index - left 表示当前节点左子树的长度
        node.right = dfs(root + 1 + index - left, index + 1, right);
        return node;
    };
};
</code></pre>
<p>一开始想要使用<code>slice()</code>方法把左右数组切出来，发现处理下标会非常麻烦，还是这种只根据下标操作的方法有可行性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[68 - II. 二叉树的最近公共祖先]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_68_ii/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_68_ii/">
        </link>
        <updated>2022-06-27T05:50:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="最近公共祖先">最近公共祖先</h3>
<p>最近公共祖先的定义为：对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一两次遍历">法一：两次遍历</h3>
<p>沿用了<a href="https://ariessk.github.io/post/jianzhi_68_ii/">68 - I. 二叉搜索树的最近公共祖先</a>中的法三思路，存下两个目标节点的访问路径，输出路径中<code>index</code>最大的相同节点：</p>
<pre><code class="language-js">var lowestCommonAncestor = function(root, p, q) {
    const paths = [], path = [];
    let res;
    dfs(root);
    for (let i = 0;;++i) {
        if (paths[0][i] !== paths[1][i]) break;
        res = paths[0][i];
    }
    return res;

    function dfs(root) {
        if (!root) return;
        path.push(root);
        dfs(root.left);
        dfs(root.right);
        if (root === p || root === q) paths.push([...path]);
        path.pop();
    };
};
</code></pre>
<h3 id="法二递归">法二：递归</h3>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 的最近公共祖先 ，则只可能为以下情况之一：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 的子树中，且分列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 的左、右子树中（异侧）；</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">p = root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 的左或右子树中；</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>=</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">q = root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 的左或右子树中；</li>
</ul>
<pre><code class="language-js">var lowestCommonAncestor = function(root, p, q) {
    // 越过叶子节点返回 null，找到目标节点返回该节点
    if (!root || p === root || q === root) return root;
    let left = lowestCommonAncestor(root.left, p, q);
    let right = lowestCommonAncestor(root.right, p, q);
    // 为空说明 p 和 q 不在这个子树中，返回另一个子树，即使也为空
    if (!left) return right;
    if (!right) return left;
    // left 和 right 同时非空，说明在异侧，当前节点就是最近公共祖先
    return root;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[68 - I. 二叉搜索树的最近公共祖先]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_68_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_68_i/">
        </link>
        <updated>2022-06-27T03:22:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="迭代与递归的空间复杂度">迭代与递归的空间复杂度</h3>
<p>目前来看，迭代的空间复杂度往往优于递归的空间复杂度。<br>
<strong>递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度</strong>：<br>
每次递归所需的空间都被压到<strong>调用栈</strong>里（这是内存管理里面的数据结构，和算法里的栈原理相同），<br>
看递归算法的空间消耗，就是要看调用栈所占用的大小。一次递归结束，调用栈就把本次递归的数据弹出去。所以这个栈最大的长度就是<strong>递归的深度</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一迭代">法一：迭代</h3>
<p><strong>注意审题！<strong>本题的树是</strong>二叉搜索树</strong>，因此判断是否是公共祖先的方法比较简单，只有在一左一右或者其中一个本身是公共祖先的时候成立：</p>
<ul>
<li>若<code>p.val &gt; root.val &amp;&amp; q.val &gt; root.val</code>，说明公共祖先在<code>root</code>的右子树；</li>
<li>若<code>p.val &lt; root.val &amp;&amp; q.val &lt; root.val</code>，说明公共祖先在<code>root</code>的左子树；</li>
<li>其他情况下<code>root</code>就是所求的公共祖先。</li>
</ul>
<p>迭代的方法时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var lowestCommonAncestor = function(root, p, q) {
    while (root) {
        if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) root = root.right;
        else if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) root = root.left;
        else break;
    }
    return root;
};
</code></pre>
<h3 id="法二递归">法二：递归</h3>
<p>递归的方法时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var lowestCommonAncestor = function(root, p, q) {
    if (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) return lowestCommonAncestor(root.right, p, q);
    if (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) return lowestCommonAncestor(root.left, p, q);
    return root;
};
</code></pre>
<h3 id="法三两次遍历">法三：两次遍历</h3>
<p>还可以两次遍历树找两个目标节点并记录其路径，然后输出两条路径<code>index</code>最大的相同节点（二叉搜索树的遍历）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[64. 求1+2+...+n]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_64/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_64/">
        </link>
        <updated>2022-06-27T01:45:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="逻辑运算符的短路特性">逻辑运算符的短路特性</h3>
<p><code>&amp;&amp;</code>：对于表达式<code>A &amp;&amp; B</code>，如果<code>A</code>为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>，则整个表达式已经可以被确定为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>，就不会执行<code>B</code>；<br>
<code>||</code>：对于表达式<code>A || B</code>，如果<code>A</code>为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，则整个表达式已经可以被确定为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，就不会执行<code>B</code>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="逻辑符短路">逻辑符短路</h3>
<p>该题的常规解法有三种：平均计算、迭代和递归。第一种需要乘除法，第二种需要循环，第三种需要判断语句。前两种无法替代，因此需要一种能够替代判断语句用来终止递归的方法，可以使用<strong>逻辑运算符的短路特性</strong>，将递归出口作为<code>A &amp;&amp; B</code>中的<code>A</code>，函数主体作为<code>B</code>：</p>
<pre><code class="language-js">ar sumNums = function(n) {
    n &amp;&amp; (n += sumNums(n - 1));
    return n;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[55 - II. 平衡二叉树]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_55_ii/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_55_ii/">
        </link>
        <updated>2022-06-26T05:51:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="自顶向下与自底向上">自顶向下与自底向上</h3>
<p>目前来看，我感觉在深度优先搜索中，<strong>自顶向下</strong>的思路比<strong>自底向上</strong>的思路容易想到，而<strong>自底向上</strong>的思路往往比<strong>自顶向下</strong>的思路时间复杂度低，<strong>自底向上</strong>使用<strong>后序遍历</strong>，<strong>自顶向下</strong>使用<strong>先序遍历</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一先序遍历-计算深度自顶向下">法一：先序遍历 + 计算深度（自顶向下）</h3>
<p>我的想法是沿用<a href="https://ariessk.github.io/post/jianzhi_55_i/">55 - I. 二叉树的深度</a>里的方法，<code>depth()</code>用以计算节点的左右子树的深度，<code>isBalanced()</code>用以遍历所有节点并判断是否平衡，但这种方法在遍历节点时进行了许多的重复计算，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var isBalanced = function(root) {
    if (!root) return true;
    // 先处理根节点 再处理左右节点
    return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
};

var depth = function(root) {
    if (!root) return 0;
    return Math.max(depth(root.left), depth(root.right)) + 1;
}
</code></pre>
<h3 id="法二后序遍历-剪枝自底向上">法二：后序遍历 + 剪枝（自底向上）</h3>
<p>这道题的最优解法应当延续<a href="https://ariessk.github.io/post/jianzhi_55_i/">55 - I. 二叉树的深度</a>的法二，使用后续遍历，自底向上，若判断子树不是平衡树则可以直接<strong>剪枝</strong>，思路是从叶子节点开始，计算其左右子树的深度，判断其差值的绝对值：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi><mi>s</mi><mo>(</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>)</mo><mo>−</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>)</mo><mo>)</mo><mo>&lt;</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">abs(depth(root.left) - depth(root.right)) &lt;= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，返回该树深度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>)</mo><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>)</mo><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">max(depth(root.left), depth(root.right)) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>否则返回 -1，并且一直返回至结束递归。</li>
</ul>
<p>算法复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var isBalanced = function(root) {
    return dfs(root) !== -1;
};

var dfs = function(root) {
    if (!root) return 0;
    let left = dfs(root.left);
    if (left === -1) return -1;
    let right = dfs(root.right);
    if (right === -1) return -1;
    return Math.abs(left - right) &lt;= 1 ? Math.max(left, right) + 1 : -1;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[55 - I. 二叉树的深度]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_55_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_55_i/">
        </link>
        <updated>2022-06-26T05:27:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>要掌握 BFS 和 DFS 两种搜索算法的核心思想，结合题目要求，优化自己的代码！</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>我一开始的想法是<strong>自顶向下</strong>的，核心思想是遍历每一个叶子节点并记录其深度，取最大值：</p>
<ul>
<li>使用<code>depth</code>记录当前层的深度，从<code>root</code>开始每向下一层<code>++depth</code>，到达叶子节点后使用<code>max</code>记录深度中更大的那一个；</li>
<li>每返回上一层<code>--depth</code>；</li>
<li>遍历完所有叶子节点，输出最大值。</li>
</ul>
<pre><code class="language-js">var maxDepth = function(root) {
    let max = 0, depth = 0;
    dfs(root);
    return max;

    function dfs(root){
        if (!root) return;
        ++depth;
        if (!root.left &amp;&amp; !root.right) max = Math.max(max, depth);
        dfs(root.left);
        dfs(root.right);
        --depth;
    }
};
</code></pre>
<p>后来想到一种<strong>自底向上</strong>的思路来优化代码：</p>
<ul>
<li>空节点，返回深度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；</li>
<li>非空节点，返回左右树深度中较大的那个。</li>
</ul>
<p>自底向上逐步计算，最终返回树的深度：</p>
<pre><code class="language-js">var maxDepth = function(root) {
    if (!root) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
</code></pre>
]]></content>
    </entry>
</feed>