<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-07-13T09:55:37.397Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[Vue]]></title>
        <id>https://AriesSK.github.io/post/vue/</id>
        <link href="https://AriesSK.github.io/post/vue/">
        </link>
        <updated>2022-12-31T07:01:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vue-知识">Vue 知识</h2>
<p><strong>单向绑定 与 双向绑定</strong></p>
<ul>
<li>单向绑定：数据改变，页面元素会跟着改变；而页面元素改变，数据不会改变（v-text, v-html, 插值表达式{{}}, v-bind）</li>
<li>双向绑定：页面元素与数据的双向绑定，一方改变另一方也改变（v-model）</li>
</ul>
<p><strong>Vue 的响应式原理</strong><br>
把一个 JS 对象传给 Vue 实例的 data 属性时，Vue 将遍历此对象的所有属性，并且使用 <strong>Object.defineProperty</strong> 将这些属性转换为 getter/setter</p>
<p><strong>Vue 的异步渲染</strong><br>
Vue 实现响应式<strong>不是在数据变化后 DOM 立即变化</strong>，是按异步策略更新的：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li>
<li>主线程之外，还存在一个&quot;任务队列&quot;（task queue），只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件</li>
<li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
<p><strong>$的作用</strong><br>
用于区分 Vue 中自带的实例和用户自定义的属性</p>
<h2 id="vue-指令">Vue 指令</h2>
<p>** v-text 与 v-html**<br>
相同点：均能够展示数据，单向绑定<br>
不同点：</p>
<ul>
<li>v-text 渲染纯文本，浏览器不对其进行 html 解析</li>
<li>v-html 输出 html，浏览器对其进行 html 解析</li>
</ul>
<p><strong>v-if 与 v-show</strong><br>
相同点：通过变量控制标签内容的显示或隐藏<br>
不同点：</p>
<ul>
<li>v-if 是动态地往 DOM 树中添加或删除元素，在初始条件为假则直接不渲染 DOM（惰性的），在条件切换时会对标签进行适当的创建和销毁</li>
<li>v-show 的本质是给 DOM 节点设置 display: none; 来控制隐藏，不论初始条件真假均会渲染DOM，只在初始化时加载一次</li>
</ul>
<p>可以看出 v-if 的开销要大于 v-show，因此前者适用于不频繁切换状态的情况，后者则适用于频繁切换的场景</p>
<p><strong>v-for</strong><br>
用于解决模板循环渲染的问题，还可以渲染 Object 对象</p>
<pre><code class="language-html">&lt;div v-for=&quot;(item, index) in list&quot;&gt;{{index}}{{item}}&lt;/div&gt;
&lt;div v-for=&quot;(val, key, index) in listObj&quot;&gt;{{index}}{{item}}&lt;/div&gt;
</code></pre>
<p>*注意：*v-for 和 v-if 不推荐一起使用，因为处于同一节点时 v-for 的优先级高于 v-if，就会在每一个 v-for 循环中重复运行 v-if，也就意味着即使渲染小部分也要遍历整个数组，造成不必要的计算，影响性能；在 vue3 中 v-if 的优先级高于 v-for 但会导致 v-if 无法访问 v-for 刚定义的变量，因此仍不推荐一起使用<br>
解决方法：使用 computed 属性将需要渲染的列表提前过滤后再给 v-for 渲染</p>
<pre><code class="language-js">computed: {
	activeUsers: function () {
		return this.users.filter( (user)=&gt; {
			return user.isShow;//返回isShow=true的项，添加到activeUsers数组
		})
	}
}
</code></pre>
<p><strong>v-on</strong><br>
监听事件，用来监听 DOM 事件来触发一些方法函数，简写 @</p>
<pre><code class="language-html">&lt;div id='app'&gt;
    &lt;!-- 鼠标点击事件 --&gt;
    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;
    &lt;!-- 键盘输入enter --&gt;
    &lt;input v-model=&quot;username&quot; v-on:keyup.enter=&quot;login&quot; /&gt;
  &lt;/div&gt;
</code></pre>
<p><strong>v-model</strong><br>
语法糖：计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用<br>
双向绑定，可以结合输入框、复选框、单选框等实现动态地修改数据<br>
v-model 是一个语法糖，本质上包含两个操作：</p>
<ul>
<li>v-bind 绑定一个 value 属性</li>
<li>v-on 给当前元素绑定 input 事件</li>
</ul>
<p>v-model 的修饰符：</p>
<ul>
<li>v-model.lazy 接管 input 的事件监听事件，在用户输入时不会马上响应在展示层，只有确认改变时才显示</li>
<li>v-model.trim 去除首尾空格</li>
<li>v-model.trim 输入的字符串转化为数字</li>
</ul>
<p><strong>v-bind</strong><br>
用于属性与变量的绑定</p>
<pre><code class="language-html">&lt;img v-bind:src=&quot;imageSrc&quot;&gt;
&lt;!-- 简写 --&gt;
&lt;img :src=&quot;imageSrc&quot;&gt;
</code></pre>
<p><strong>v-cloak</strong><br>
使用 v-cloak 设置的样式会在 vvue 实例编译完成后从绑定的 html 标签上移除<br>
可以有效防止页面加载的时候出现 vue 的变量名</p>
<pre><code class="language-css">[v-cloak] {
    display: none;
}
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;app&quot; v-cloak&gt;
    {{msg}}
&lt;/div&gt;
</code></pre>
<p><strong>v-pre</strong><br>
跳过 vue 的编译，直接输出原始值</p>
<pre><code class="language-html">&lt;!-- 输出 {{msg}} --&gt;
&lt;div v-pre&gt;{{msg}}&lt;/div&gt;
</code></pre>
<h2 id="vue-全局-api">Vue 全局 API</h2>
<p><strong>Vue.extend</strong><br>
扩展实例构造器，往往和 $mount 配合使用，创建实例并挂载到元素上</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.extend-扩展实例构造器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 实现了自定义纯标签的效果 --&gt;
    &lt;official&gt;&lt;/official&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // 定义构造器
        var official = Vue.extend({
            template:&quot;&lt;p&gt;&lt;a target='_blank' :href='url'&gt;{{name}}&lt;/a&gt;&lt;/p&gt;&quot;,
            data:function(){
                return{
                    name:'AriesSK的博客',
                    url:'https://ariessk.github.io/'
                }
            }
        });
        // 生成实例并挂载到 official DOM 上
        new official().$mount('official');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.directive</strong><br>
自定义指令，回调函数有三个参数：</p>
<ul>
<li>el 被绑定的 node 节点</li>
<li>binding 一个对象包含指令的信息</li>
<li>vnode Vue 编译生成的虚拟节点</li>
</ul>
<p>自定义指令的生命周期函数（钩子函数）：</p>
<ul>
<li>bind 只调用一次，第一次绑定元素被调用，初始化操作</li>
<li>inserted 被绑定元素插入了父节点</li>
<li>update 被绑定的元素模板更新时调用</li>
<li>componentUpdated 被绑定的元素模板完成一次生命周期</li>
<li>unbind 指令和被绑定元素解绑时调用</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.directive 自定义标签&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p v-color=&quot;setRed&quot;&gt;我要红&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
window.onload = function () {
    Vue.directive('color', function(el, binding, vnode){ // 这里的 color 指的是 v-color 的 color，表示指令名
      console.log('el', el) // &lt;p style=&quot;color: red;&quot;&gt;我要红&lt;/p&gt;
      el.style = &quot;color:&quot; + binding.value // binding.value 表示指令绑定的值，这里指 setRed
    });

    new Vue({
      el: '#app', // 根据属性绑定
      data:{
        setRed: 'red'
      }
    })
  }
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.set</strong><br>
全局操作，Vue 不允许在已创建的实例上动态添加新的根级响应式属性，但可以用 Vue.set 方法将响应式属性添加到嵌套的对象上<br>
下面的例子可以发现，data 的数据是数组或对象时，调用 change 虽然修改了 fruit 的值，但视图并不会更新（失去了getter/setter），而调用 Vue.set(target, key, value) 则会更新视图，说明它能够向响应式对象中添加属性，并确保这个新属性同样是响应式的，且触发视图更新</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.set 全局操作&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p v-for=&quot;item in fruit&quot;&gt;{{ item }}&lt;/p&gt;
    &lt;!-- v-on 的事件处理方法在 Vue 实例内的 methods 声明，也可以在实例外声明函数，前者不用加括号，后者需要 --&gt;
    &lt;button v-on:click=&quot;change&quot;&gt;变&lt;/button&gt;
    {{ fruit }}
  &lt;/div&gt;
  &lt;!-- onclick 事件不能调用 Vue 实例内的 methods --&gt;
  &lt;button onclick=&quot;add()&quot;&gt;外部添加&lt;/button&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  function add(){
    Vue.set(app.fruit, 1, 'melon');
  }
  var app = new Vue({
    el: '#app',
    data: {
      fruit: ['apple', 'banana', 'pear', 'grape']
    },
    methods: {
      change: function () {
        this.fruit[1] = 'melon'
        console.log(this.fruit) // ['apple', 'melon', 'pear', 'grape']
      }
    }
  })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.filter</strong><br>
全局过滤器，注意声明过滤器必须放在<strong>声明实例 app 之前</strong>，否则不被注入实例中<br>
过滤器可用在插值表达式 {{ message | filter}} 和 v-bind 中 v-bind:msg=&quot;message | filter&quot;</p>
<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.filter 过滤器&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p&gt;{{ count | sum }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  Vue.filter(&quot;sum&quot;, function(value) { //声明 sum 过滤器
    return value + 4;
  });

  var app = new Vue({
    el: '#app',
    data: {
      count: 20
    },
  })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.nextTick</strong><br>
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM<br>
应用场景：需要在视图更新之后，基于新的视图进行操作</p>
<h2 id="vue-生命周期函数">Vue 生命周期函数</h2>
<p>对于单页面开发模式，每个页面都可以理解为一个 Vue 组件，在它们的生命周期中，都有对应的钩子函数：</p>
<ul>
<li>beforeCreate 在组件创建之前</li>
<li>created 在组件创建之后，一般用于初始化一些固定数据</li>
<li>beforeMount 在 DOM 节点渲染之前</li>
<li>mounted 在 DOM 节点渲染完后除法，常通过 ajax 获取服务端的数据</li>
<li>beforeUpdate 数据更新时调用，适用于在更新之前访问现有的 DOM</li>
<li>updated DOM 已经更新，执行依赖于 DOM 的操作</li>
<li>activated 被 keep-alive 缓存的组件激活时调用</li>
<li>deactivated 被 keep-alive 缓存的组件停用时调用</li>
<li>beforeDestroy 实例销毁之前调用，这一步实例仍完全可用</li>
<li>destroyed 实例销毁后调用，一般用于销毁页面内创建的 setTimeout 等变量，防止内存泄漏</li>
</ul>
<h2 id="vue-router">Vue-Router</h2>
<p>Vue 官方提供的路由插件</p>
<p><strong>传统页面与单页面跳转的区别</strong></p>
<ul>
<li>传统页面：传统的开发模式，路由一般是由超链接（a 标签）来控制页面的跳转与切换，每次跳转需要刷新整个页面，体验上不如单页模式</li>
<li>单页面：Vue 的单页面是基于组件和路由的配合，所有的页面都可以视为组件，路由控制访问路径，每一个路径映射一个组件。单页模式中无法使用 a 标签进行路由跳转，因为单页模式本质上就只有一个 index.html 页面。所有的页面组件都放在打包好的 js 文件中，所以要使用 Vue-Router 的路由组件实现跳转</li>
</ul>
<p><strong>路由模式</strong><br>
Vue-Router 提供了三种路由模式：</p>
<ul>
<li>Hash 模式</li>
<li>History 模式</li>
<li>abstract 模式</li>
</ul>
<p><strong>Hash 模式</strong><br>
Vue-Router 的默认模式，特点是 URL 始终带着 #。浏览器的原生方法提供了一个监听事件 hashchange，它能监听到下面的改变：</p>
<ul>
<li>点击 a 标签改变 URL 地址</li>
<li>浏览器的前进后退行为</li>
<li>通过 window.location 方法改变地址栏</li>
</ul>
<p>当初始的 html 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架完成加载。由于 hashchange 不会被默认触发，因此需要在 DOMContentLoaded 被触发时执行一次 hashchange 监听方法要执行的函数 HashChange。之后在点击 a 标签改变 URL 地址时会触发 hashchange 事件，获取到 location.hash，执行的 HashChange 函数通过判断 location.hash 的值来匹配相应的组件，简易的实现如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Hash 模式&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    // 这两个事件名是确定的，函数名可以改
    window.addEventListener('DOMContentLoaded', Load);
    window.addEventListener('hashchange', HashChange);
    var routeView = null;
    function Load() {
        routeView = document.getElementById('route-view');
        HashChange();
    }
    function HashChange() {
        switch(location.hash) {
            case '#/page1':
                routeView.innerHTML = 'page1';
                return;
            case '#/page2':
                routeView.innerHTML = 'page2';
                return;
            default:
                routeView.innerHTML = 'page1';
                return;
        }
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>History 模式</strong><br>
使用 History 模式是使用 html5 的 history API实现路由的模式，表现是去除了 Hash 模式中 URL 的 #。控制路由会有一些麻烦，根本原因是使用 History 模式，popstate 监听事件无法监听到 pushState、replaceState、a 标签三种形式的变化，可以监听到浏览器的前进和后退。<br>
为了实现路由，可以如下做：</p>
<ol>
<li>遍历页面上的所有 a 标签，阻止其默认事件，同时加上点击事件的回调函数，在回调函数中获取 a 标签的 href 属性值</li>
<li>通过 pushState 改变浏览器的 location.pathname 属性值为 a 标签的 href 属性值</li>
<li>手动执行 popstate 事件的回调函数，匹配相应的路由</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;History 模式&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="vuex">Vuex</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Less]]></title>
        <id>https://AriesSK.github.io/post/less/</id>
        <link href="https://AriesSK.github.io/post/less/">
        </link>
        <updated>2022-12-31T05:02:58.000Z</updated>
        <content type="html"><![CDATA[<p>Less 是一门 CSS 预处理语言，扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展，简单来说就是能够提取大量的重复代码，使 CSS 更加规范。</p>
<p><strong>注释</strong><br>
单行 //<br>
多行 /**/</p>
<p><strong>变量</strong><br>
使用 @ 声明变量，同名变量后面的会覆盖前面的</p>
<pre><code class="language-less">@primary: red;

.box {
    color: @primary;
}
</code></pre>
<p><strong>嵌套</strong><br>
CSS 的预编译器嵌套规则大同小异：</p>
<pre><code class="language-less">.a {
    color: #fff;
    .b {
        width: 20px;
    }
}
</code></pre>
<p>编译后如下：</p>
<pre><code class="language-css">.a {
    color: #fff;
}
.a .b {
    width: 20px;
}
</code></pre>
<p>同级场景使用 &amp; 的情况，&amp; 表示当前节点的 CSS 样式，一般用于处理 CSS 样式的状态 hover、focus、active、link、visited等：</p>
<pre><code class="language-less">.a {
    color: blue;
    &amp;:hover {
        color: red;
    }
}
</code></pre>
<p><strong>混合（Mixin）</strong><br>
Less 的混合有三种情况：</p>
<ul>
<li>不带参数，调用时可以不加括号，直接使用</li>
</ul>
<pre><code class="language-less">.center {
    text-align: center;
}
.red {
    color: red;
}

.box {
    .one {
        .center;
        .red;
    }
}
</code></pre>
<ul>
<li>带参数，没有默认值，调用需要加括号，并且括号中必须要传值</li>
</ul>
<pre><code class="language-less">.center {
    text-align: center;
}
.color(@c) {
    color: @c;
}

.box {
    .one {
        .center;
        .color(green);
    }
}
</code></pre>
<ul>
<li>带参数，有设置默认值，调用时要加括号，可以不传参数</li>
</ul>
<pre><code class="language-less">.center {
    text-align: center;
}
.color(@c: red) {
    color: @c;
}

.box {
    .one {
        .center;
        .color;
    }
}
</code></pre>
<p><strong>运算</strong><br>
+ - * / 可以对任何数字、颜色或变量运算，运算前会进行单位的换算，计算结果以最左侧的单位为准，如果单位无效或失去意义则忽略单位</p>
<p><strong>转义字符</strong><br>
Less 的转义字符为 ~&quot;&quot; 比如<code>~&quot;\&quot;</code></p>
<p><strong>作用域</strong><br>
现在当前作用域内查询，找不到则继续向上一级查询，类似 js</p>
<p><strong>导入</strong><br>
Less 文件可以使用 @import 引入另一个 Less 文件，并且还可以使用里面的变量，比如<code>@import './style.less'</code></p>
<p><strong>应用实例</strong><br>
实例一：画四种方向的三角形<br>
可以使用通用匹配模式 @_ 无论同名的哪一个混合被匹配到，都要先执行通用匹配模式的代码</p>
<pre><code class="language-less">// 通用匹配模式 下面四种方向的三角形都会先执行该代码
.triangle(@_, @width, @color) {
    width: 0;
    height: 0;
    border-style: solid;
}
.triangle(Bottom, @width, @color) {
    border-width: @width;
    border-color: @color transparent transparent transparent;
}
.triangle(Left, @width, @color) {
    border-width: @width;
    border-color: transparent @color transparent transparent;
}
.triangle(Top, @width, @color) {
    border-width: @width;
    border-color: transparent transparent @color transparent;
}
.triangle(Right, @width, @color) {
    border-width: @width;
    border-color: transparent transparent transparent @color;
}
// 使用左箭头
.box {
    .triangle(Left, 100px, red);
}
</code></pre>
<p>这种方式画三角形是利用了 border 可以分别设置四边的属性，当 width 和 height 为 0，整个可见区就由 broder 填满，调整 border-width 可以改变三角形的大小，设置一边的颜色并将另外三边设为透明则可以出现三角形的效果（四分之一的矩形）<br>
<strong>@arguments</strong> 能够替代 mixin 的所有参数</p>
<pre><code class="language-less">.border(@width, @mode, @color) {
    border: @arguments;
}
.one{
    .border(1px, solid, red)
}
</code></pre>
<p>实例二：文字垂直居中<br>
由于将行高 line-height 和 height 设置成相同就能够让标签内的文字垂直居中，因此比较常用，就可以把它封装起来</p>
<pre><code class="language-less">.line-text-h (@h: 0) {
    height: @h;
    line-height: @h;
}

.box {
    .text {
        .line-height-h(100px);
        background: grey;
        width: 200px;
    }
}
</code></pre>
<p>实例三：定位上下左右居中<br>
绝对定位相对于已定位的父元素，相对定位相对于元素在文档中的初始位置</p>
<pre><code class="language-less">.center {
    // 设置绝对定位
    position: absolute;
    // 设置使元素左上顶点位于中心位置
    top: 50%;
    left: 50%;
    // 向上和向左平移自身一半的高和宽，使元素中心点位于中心位置
    transform: translate(-50%, -50%);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML + CSS]]></title>
        <id>https://AriesSK.github.io/post/html-css/</id>
        <link href="https://AriesSK.github.io/post/html-css/">
        </link>
        <updated>2022-12-24T07:00:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>操作快捷键</strong><br>
Ctrl + Enter 换行，不改变光标后面代码<br>
Alt + Shift + up/down 在上一行/下一行复制该行<br>
选中词后 Ctrl + D，向下一次选择相同的词</p>
<h2 id="网页">网页</h2>
<p><strong>C/S和B/S</strong><br>
C/S：Client/Sever<br>
B/S：Browser/Sever</p>
<p><strong>网页三要素：结构、表现、行为</strong><br>
结构：HTML用于描述页面的结构<br>
表现：CSS用于控制页面中元素的样式<br>
行为：JavaScript用于响应用户操作</p>
<hr>
<h2 id="html">HTML</h2>
<p><strong>超文本标记语言（Hypertext Markup Language, HTML)</strong><br>
超文本指的是使用超链接的方法，将不同空间的文字信息组织在一起的网状文本</p>
<pre><code class="language-html">&lt;!--HTML的注释--&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>标签一般成对出现，单个出现的称为<strong>自结束标签</strong></p>
<p><strong>标签的属性</strong><br>
在开始标签或字节数标签中可以设置标签的属性，属性是一个名值对，属性应当根据文档中的规定编写，有些属性没有属性值</p>
<pre><code class="language-html">&lt;font color=&quot;red&quot;&gt;红色&lt;/font&gt;
</code></pre>
<p><strong>文档声明（DOCTYPE）</strong><br>
html5的文档声明：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
</code></pre>
<p><strong>二进制与十六进制</strong><br>
二进制作为计算机底层的进制使用，而一般显示二进制数使，会转换为十六进制</p>
<p><strong>字符编码</strong><br>
字符集（charset）是编码和解码所从用的规则<br>
若编码和解码使用的字符集不同，则会出现乱码问题<br>
UTF-8 万国码 开发时使用</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>实体</strong><br>
在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格<br>
使用实体（转义字符） <code>&amp;实体的名字;</code><br>
空格<code>&amp;nbsp;</code> 大于<code>&amp;gt;</code> 小于<code>&amp;lt;</code> 版权符<code>&amp;copy;</code></p>
<p><strong>meta标签</strong><br>
charset 指定网页的字符集<br>
name 指定的数据的名称<br>
content 指定的数据的内容</p>
<pre><code class="language-html">&lt;!-- title 标签的内容会作为搜索引擎超链接上的文字显示 --&gt;
&lt;!-- keywords 表示网站的关键字 搜索时的关键词 --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;HTML5,CSS3&quot;&gt;
&lt;!-- description 表示网站的描述 会显示在搜索引擎的搜索结果中 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;这是一个网站&quot;&gt;
&lt;!-- refresh 将网页重定向到另一个网站 --&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://ariessk.github.io&quot;&gt;
</code></pre>
<p>###语义化标签<br>
<strong>HTML负责网页的结构</strong><br>
在使用html标签时，应该关注的是标签的语义，而不是样式</p>
<p><strong>块元素</strong><br>
在页面中独占一行的元素称为块元素（block element） 网页布局主要用块元素 块元素内能放块元素和行内元素 但<code>&lt;p&gt;</code>元素内能放块元素<br>
<code>&lt;h1&gt;</code> h1~h6 h1最重要 仅次于title 一般一个页面只有一个h1 一般只会用h1~h3<br>
相关的标题可以放标题组里</p>
<pre><code class="language-html">&lt;hgroup&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;h2&gt;&lt;/h2&gt;
&lt;/hgroup&gt;
</code></pre>
<p><code>&lt;p&gt;&lt;/p&gt;</code>段落<br>
<code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>表长引用<br>
<code>&lt;br&gt;</code>换行</p>
<p><strong>行内元素</strong><br>
在页面中不会独占一行的元素称为行内元素（inline element） 主要用于包裹元素<br>
<code>&lt;em&gt;&lt;/em&gt;</code>表示语音语调的加重<br>
<code>&lt;strong&gt;&lt;/strong&gt;</code>表强调<br>
<code>&lt;q&gt;&lt;/q&gt;</code>短引用<br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code> 超链接</p>
<p><strong>浏览器修正</strong><br>
浏览器在解析网页时，会对网页中不符合规范的内容进行修正 标签卸载了根元素<code>&lt;html&gt;</code>外面</p>
<p><strong>网页主体</strong></p>
<pre><code class="language-html">&lt;body&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;main&gt;&lt;/main&gt;
    &lt;footer&gt;&lt;/footer&gt;
    &lt;!-- 导航 --&gt;
    &lt;nav&gt;&lt;/nav&gt;
    &lt;!-- 与主体相关的内容（侧边栏） --&gt;
    &lt;aside&gt;&lt;/aside&gt;
    &lt;!-- 文章--&gt;
    &lt;article&gt;&lt;/article&gt;

&lt;/body&gt;
</code></pre>
<p><strong>列表</strong><br>
列表之间可以互相嵌套<br>
无序列表</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>有序列表</p>
<pre><code class="language-html">&lt;ol&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p>定义列表，dt表示定义的内容，dd对内容进行解释说明</p>
<pre><code class="language-html">&lt;dl&gt;
    &lt;dt&gt;&lt;/dt&gt;
    &lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<p><strong>超链接</strong><br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>能够嵌套除它自身的任何元素<br>
目标路径可以是<strong>外部网站</strong>或<strong>内部页面</strong><br>
内部页面通常使用<strong>相对路径</strong>：<code>./</code>表示当前文件所在的目录（可省略），<code>../</code>表示上一级目录</p>
<pre><code class="language-html">&lt;!-- 当前页面打开与新的页面打开 --&gt;
&lt;a href=&quot;&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
</code></pre>
<p><strong>id 属性</strong><br>
通过超链接到页面中的特定位置，要使用 id 属性<br>
id 属性是唯一不重复的，每个标签可以添加一个 id 属性</p>
<pre><code class="language-html">&lt;!-- 回到顶部 --&gt;
&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;
&lt;!-- 回到 id 为bottom的标签处 --&gt;
&lt;a href=&quot;#bottom&quot;&gt;&lt;/a&gt;
&lt;!--未设置是可以用 javascript:; 占位 点击无反应 --&gt;
&lt;a href=&quot;javascript:;&quot;&gt;1&lt;/a&gt;
</code></pre>
<p><strong>图片标签</strong><br>
用于引入外部图片<br>
<code>&lt;img width=&quot;&quot; height=&quot;&quot; src=&quot;&quot; alt=&quot;&quot;&gt;</code> 自结束标签 替换元素<br>
alt 是图片的描述，有些浏览器会在图片无法加载时显示，搜索引擎会根据 alt 中的内容来识别图片<br>
width height 只修改其中一个会等比例缩小<br>
一般在 pc 端不建议修改图片的大小，而在移动端经常需要缩放图片（主要是大图缩小确保清晰度）<br>
<strong>图片格式</strong><br>
jpeg(jpg) 支持颜色比较丰富，不支持透明效果，不支持动图，一般显示照片<br>
gif 支持颜色比较少，支持简单透明，支持动图，一般显示动图<br>
png 支持颜色丰富，支持复杂透明，不支持动图，专为网页而生<br>
webp 谷歌推出的专门用来表示网页中的图片的一种格式，具备其他图片的所有优点，并且文件特别小，但<strong>兼容性不好</strong><br>
base64 将图片使用base64编码，将土拍你转换为字符，通过字符的形式来引入图片，一般用于需要和网页一起加载的图片</p>
<p><strong>内联框架</strong><br>
用于向当前页面中引入一个其他页面<br>
<code>&lt;iframe src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code><br>
frameborder 指定内联框架的边框，0无1有</p>
<p><strong>音视频</strong><br>
<code>&lt;audio src=&quot;&quot; controls autoplay loop&gt;&lt;/audio&gt;</code>controls 是否允许用户控制播放，autoplay 自动播放，但大部分浏览器不会自动播放，loop循环播放，都是无值的属性<br>
下面这种写法能够解决<strong>浏览器不兼容</strong>的问题，不支持<code>&lt;audio&gt;</code>则显示文字，第一个音频无法播放则播放第二个<code>&lt;emobed&gt;</code>支持比较低的浏览器版本，需要设置文件类型以及宽和高，且比较丑。</p>
<pre><code class="language-html">&lt;audio controls&gt;
        &lt;!-- 文字和 embed 二选一即可 --&gt;
        对不起，您的浏览器不支持播放音频，请升级浏览器！
        &lt;source src=&quot;audio.mp3&quot;&gt;
        &lt;source src=&quot;audio.ogg&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;audio/mp3&quot; width=&quot;&quot; height=&quot;&quot;&gt;
    &lt;/audio&gt;
</code></pre>
<p>video 与 audio 使用方法基本相同</p>
<pre><code class="language-html">&lt;video controls&gt;
        &lt;source src=&quot;video.webm&quot;&gt;
        &lt;source src=&quot;video.mp4&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;video/mp4&quot; width=&quot;&quot; height=&quot;&quot;&gt;
&lt;/video&gt;
</code></pre>
<h2 id="css">CSS</h2>
<p>层叠样式表<br>
网页实际上是一个多层的结构，通过css可以分别为网页的每一层来设置样式，而最终我们能看到的是最上边的一层</p>
<p><strong>使用 css 修改元素样式</strong><br>
法一：内联样式、行内样式<br>
在标签内部通过 style 属性来设置元素的样式，只能对一个标签生效，修改很麻烦（不推荐使用）<br>
<code>&lt;p style=&quot;color: red; font-size: 60px;&quot;&gt;</code><br>
法二：内部样式表<br>
将样式编写到 head 中的 style 标签里，同时设置多个标签，方便修改和复用，但只能对一个网页使用</p>
<pre><code class="language-html">&lt;style&gt;
    p{
        color: red;
        font-size: 60px
    }
&lt;/style&gt;
</code></pre>
<p>法三：外部样式表<br>
将样式编写到外部的 css 文件中，然后在页面中通过 link 标签引入外部的 css 文件，方便多网页复用（最佳），多个网页引用同一个 css 时能够使用到浏览器的缓存机制，加块网站加载速度，提高用户体验</p>
<pre><code class="language-css">p{
    color: red;
    font-size: 60px;
}
</code></pre>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>css 语法</strong><br>
选择器，选择页面中的指定元素<br>
声明块，为指定元素设置样式，声明是名值对结构，名和值以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 连接，以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mpunct">;</span></span></span></span> 结尾</p>
<h3 id="选择器">选择器</h3>
<p>常用选择器：</p>
<ul>
<li>元素选择器，根据标签名选定元素，<code>标签名{}</code></li>
<li>id 选择器，根据元素 id 选中元素，<code>#id属性值{}</code></li>
<li>类选择器，根据元素 class 选中元素，<code>.class值{}</code>，class 和 id 类似，但 class 可重复使用，可以为一个元素指定多个 class，多个 class 之间使用<strong>空格</strong>分隔</li>
<li>通配选择器，选中页面中的所有元素，<code>*{}</code></li>
</ul>
<p>复合选择器：</p>
<ul>
<li>交集选择器，选中同时复合多个条件的元素，<code>选择器1选择2选择器3{}</code>，有元素选择器则必须以<strong>元素选择器开头</strong></li>
<li>选择器分组（并集选择器），同时选择多个选择器对于的元素，<code>选择器1,选择2,选择器3{}</code></li>
</ul>
<p>关系选择器：<br>
父元素：直接包含子元素的元素<br>
祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素<br>
兄弟元素：拥有相同父元素的元素</p>
<ul>
<li>子元素选择器，选中父元素的指定子元素，<code>父元素 &gt; 子元素{}</code></li>
<li>后代元素选择器，选中祖先元素内的指定后代元素，<code>祖先元素 后代元素{}</code></li>
<li>兄弟选择器，选择下一个兄弟，<code>前一个 + 后一个{}</code>，需要<strong>直接相邻</strong>；选择下边所有兄弟，<code>兄 ~ 弟{}</code></li>
</ul>
<p>属性选择器：</p>
<ul>
<li>选择含有指定属性的元素，<code>[属性名]{}</code></li>
<li>选择含有指定属性和属性值的元素，<code>[属性名=属性值]{}</code></li>
<li>选择属性值以指定值开头的元素，<code>[属性名^=属性值]{}</code></li>
<li>选择属性值以指定值结尾的元素，<code>[属性名$=属性值]{}</code></li>
<li>选择属性值中含有指定值的元素，<code>[属性名*=属性值]{}</code></li>
</ul>
<p>伪类选择器：<br>
伪类，特殊的类，用来描述一个元素的特殊状态，比如：第一个元素、被点击的元素、鼠标移入的元素<br>
伪类一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>:first-child</code>，第一个子元素</li>
<li><code>:last-child</code>，最后一个子元素</li>
<li><code>:nth-child()</code>，第 n 个子元素，括号内可填值表示第几个，其中有特殊值：n 表示选中所有（0~正无穷）；2n 或 even 表示选中偶数位的元素；2n+1 或 odd 表示奇数位的元素</li>
</ul>
<p>上述的伪类均根据<strong>所有的子元素</strong>进行排序</p>
<ul>
<li><code>:first-of-type</code></li>
<li><code>:last-of-type</code></li>
<li><code>:nth-of-type()</code></li>
</ul>
<p>上述这三个与前面的功能类似，但是是在<strong>相同元素</strong>中进行排序</p>
<ul>
<li><code>:not()</code>，否定选择器，将复合条件的元素从选择器中去除，比如``ul &gt; li:not(:nth-of-type(1)){}`是排除第一个</li>
</ul>
<p>超链接的伪类：<br>
其执行顺序是 <strong>LoVeHAte</strong>，原因如下：</p>
<ul>
<li>未访问的链接（正常的链接），<code>a:link</code>，专属于超链接标签，无操作便具有<code>:link</code>状态</li>
<li>访问过的链接，<code>a:visited</code>，由于隐私的原因，这个伪类只能修改颜色，专属于超链接标签，访问后具备<code>:link</code>和<code>:visited</code>两种状态</li>
<li>鼠标移入的状态，<code>:hover</code>，鼠标移入访问过的链接，同时具备<code>:link</code>、<code>:visited</code>和<code>:hover</code>三种状态</li>
<li>鼠标点击的状态，<code>:active</code>，点击已访问链接未松开，同时具备<code>:link</code>、<code>:visited</code>、<code>:hover</code>和<code>:active</code>四种状态</li>
</ul>
<p>伪元素选择器：<br>
伪元素，表示页面中一些特殊的不真实存在的元素（特殊的位置），一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>::first-letter</code>，第一个字母</li>
<li><code>::first-line</code>，第一行</li>
<li><code>::selection</code>，选中的内容</li>
<li><code>::before</code>，表示元素的开始，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
<li><code>::after</code>，表示元素的结束，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
</ul>
<pre><code class="language-css">/* before 和 after 需要结合 content 属性使用才能看出效果 */
/* 下面的例子是在元素的开头插入红色字符串 'abc' */
div::before{
    content: 'abc';
    color: red;
}
</code></pre>
<p><strong>选择器的权重</strong><br>
样式的冲突，通过不同的选择器选中了相同的元素，并且为相同的样式设置了不同的值时，就发生了冲突<br>
此时应用哪个样式有选择器的权重（优先级）决定，选择器越具体优先级越高<br>
选择器的权重（数字仅是为了说明数量级）：</p>
<ul>
<li>内联样式 1,0,0,0</li>
<li>id 选择器 0,1,0,0</li>
<li>类和伪类选择器 0,0,1,0</li>
<li>元素选择器 0,0,0,1</li>
<li>通配选择器 0,0,0,0</li>
<li>继承的样式 没有优先级，即优先级低于通配</li>
</ul>
<p>比较优先级是，需要将所有选择器的优先级相加后再比较优先级（除了<strong>分组选择器</strong>是单独计算的），而选择器的累加不会超过其最大的<strong>数量级</strong>，类选择器再多也不会超过 id 选择器<br>
相同优先级，后面的会覆盖前面的<br>
可以在某一个样式后边添加<code>!important</code>则会获取到最高的优先级（超过内联样式），需要<strong>慎用</strong></p>
<pre><code class="language-css">.class{
    background-color: red !important;
}
</code></pre>
<p><strong>样式的继承</strong><br>
继承发生在<strong>祖先与后代</strong>之间，为一个元素设置样式同时也会应用到它的<strong>后代元素</strong><br>
继承的设计是为了方便开发，利用继承可以将一些通用的样式设置到共同的祖先元素上，这样只需设置一次<br>
并不是<strong>所有</strong>的样式都会被继承，比如背景相关的，布局相关的样式等</p>
<p><strong>长度单位</strong><br>
像素（px）：不同屏幕的像素大小是不同的<br>
百分比：能够将属性值设置为相对于其父元素属性的百分比，能够使子元素跟随父元素的改变而改变<br>
em：相对于元素的字体大小来计算的，1em = 1font-size，会随着字体的大小改变<br>
rem：相对于根元素的字体大小来计算</p>
<p><strong>颜色单位</strong><br>
颜色名：在 css 中可以直接使用颜色名来设置颜色，但不常用<br>
RGB：通过三种颜色的不同浓度来调配出不同的颜色，每一种范围在 0 - 255(0% - 100%) 之间，是光的三原色，均为 0 则黑，均为 255 则黑</p>
<pre><code class="language-css">.box{
    background-color: rgb(0, 0, 0);
    background-color: rgb(255, 255, 255);
}
</code></pre>
<p>RGBA：在 RGB 的基础上多了一个透明度 A，1 表示不透明，0 表示全透明，.5 半透明<br>
十六进制的 RGB 值：语法 #RGB，每种颜色用两位十六进制数表示，00 - ff<br>
HSL：H 色相(0 - 360)，S 饱和度(0% - 100%)，L 亮度(0% - 100%)<br>
HSLA：多一个透明度</p>
<h3 id="布局">布局</h3>
<p><strong>文档流</strong><br>
网页是多层结构，最底下的一层称为文档流，是网页的基础，创建的元素默认都在文档流中进行排列<br>
元素主要有两个状态：<strong>在文档流中</strong>和<strong>不在文档流中（脱离文档流）</strong><br>
元素在文档流中的特点：</p>
<ul>
<li>块元素：在页面中独占一行（自上向下垂直排列）；默认宽度是父元素的全部（把父元素撑满）；默认高度是被内容（子元素）撑开</li>
<li>行内元素：不会独占页面的一行，只占自身的大小；在页面中从左向右排列，如果在一行中不能容纳，则换到第二行；默认宽度和高度都被内容撑开</li>
</ul>
<p><strong>盒模型</strong><br>
css 将页面中的所有元素都设置为了一个矩形的盒子，盒子的可见框大小由内容区、内边距和边框共同决定<br>
每一个盒子都由以下击鼓部分组成：</p>
<ul>
<li>内容区(content)： 元素中的所有子元素和文本内容都在内容区中排列，内容区的大小由 width 和 height 两个属性来设置</li>
<li>内边距(padding)，内容区和边框之间的距离，可以用 padding 简写，也可以用 padding-xxx (xxx 可以是 top right bottom left)，内边距的大小会影响到盒子的大小，背景颜色会延伸到内边距上</li>
<li>边框(border)：属于盒子的边缘，需要设置三个样式
<ol>
<li>边框的宽度(border-width)，可以用来指定四个方向边框的宽度，四个值（上 右 下 左、顺时针），三个值（上 左右 下），两个值（上下 左右），一个值（上下左右）；或者使用 boder-xxx-width 单独指定某一个边框，默认 3px，边框的大小会直接影响盒子的大小</li>
<li>边框的颜色(border-color)，同样可分别以指定四个边的颜色，规则同上，默认黑</li>
<li>边框的样式(border-style)，实线(solid)，点状虚线(dotted)，虚线(dashed)，双线(double)，默认 none 表示没有边框<br>
boder 还有简写属性，同时设置边框的所有相关样式，并且<strong>没有</strong>顺序要求<code>border: 10px red solid</code>，也可以使用<code>border-xxx</code>分别设置四个边</li>
</ol>
</li>
<li>外边距(margin)，不影响可见框大小，但影响盒子的位置，有四个方向的外边距，可以用 margin 简写，也可以用 margin-xxx 设置（默认情况下设置 margin-right 不会产生效果，一般由浏览器调整），由于元素默认自左向右排列，因此设置左、上外边距会移动元素自身，而设置右、下外边距会移动其他元素。margin 设置负值则反向移动。margin 会影响盒子实际占用空间</li>
</ul>
<p><strong>盒模型的水平布局</strong><br>
元素在其父元素中水平方向的位置由以下几个属性共同决定：margin-left，border-left，padding-left，width，padding-right，border-right，margin-right<br>
它们的总和<strong>必须等于</strong>父元素内容区的宽度<br>
如果等式不成立，称为过度约束，等式自动调整：</p>
<ul>
<li>若七个值没有 auto 的情况，则自动调整 margin-right 使等式成立；</li>
<li>而 width，margin-left，margin-right能够设置 auto，设置后会自动调整该属性，其中 width 的默认值就是 auto；</li>
<li>宽度和一个外边距设置为 auto，宽度会调整到最大值，外边距为 0</li>
<li>三个都设置为 auto，则外边距都是 0，宽度最大</li>
<li>外边距为 auto，宽度固定，则将外边距设计为相同值（常用于在父元素中水平居中）</li>
</ul>
<p><strong>盒模型的垂直布局</strong><br>
子元素在父元素的内容区中排列，若子元素的大小超过了父元素，则子元素会从父元素中溢出<br>
使用 overflow 属性来设置父元素如何处理溢出的子元素（在父元素中设置），可选值：</p>
<ul>
<li>visible，默认值，使子元素溢出，在父元素外显示</li>
<li>hidden，溢出内容将被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整的内容</li>
<li>auto，根据需要生成滚动条<br>
overflow-x 和 overflow-y 可以分别设置横向和纵向的溢出</li>
</ul>
<p><strong>垂直外边距的重叠(折叠)</strong><br>
相邻的垂直方向的外边距会发生重叠现象：</p>
<ul>
<li>兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大的（都是正或负值），如果一正一副取两者和，对开发有利，不需要处理</li>
<li>父子元素间的相邻垂直外边距，子元素的会传递给父元素（上外边距），会影响到页面的布局，需要进行处理</li>
</ul>
<p><strong>行内元素的盒模型</strong><br>
行内元素不支持设置宽度和高度<br>
行内元素可以设置 padding，但不会影响页面的布局<br>
行内元素可以设置 border，垂直方向的 border 不会影响页面的布局<br>
行内元素可以设置 margin，垂直方向的 margin 不会影响页面的布局</p>
<p>display 用来设置元素的显示类型，可选值：</p>
<ul>
<li>inline 将元素设置为行元素</li>
<li>block 将元素设置为块元素</li>
<li>inline-block 将元素设置为行内块元素，可以设置宽高又不会独占一行</li>
<li>table 将元素设置为一个表格</li>
<li>none 元素不在页面中显示</li>
</ul>
<p>visibility 用来设置元素的显示状态，可选值：</p>
<ul>
<li>visible 默认值，元素在页面中正常显示</li>
<li>hidden 元素在也页面中隐藏不显示，但依然占据页面的位置</li>
</ul>
<p><strong>默认样式</strong><br>
通常情况浏览器都会为元素设置一些默认样式，会影响到页面的布局，因此需要去除浏览器的默认样式（PC端），可以使用别人的<strong>重置样式表</strong>，引入 css 文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试]]></title>
        <id>https://AriesSK.github.io/post/qian-duan-mian-shi/</id>
        <link href="https://AriesSK.github.io/post/qian-duan-mian-shi/">
        </link>
        <updated>2022-07-31T09:29:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端基础">前端基础</h2>
<h3 id="html">HTML</h3>
<p><strong>h5 新特性</strong></p>
<ul>
<li>拖拽释放 Drag and drop API</li>
<li>媒体播放 video 和 audio</li>
<li>本地存储 localStorge 和 sessionStorage</li>
<li>语义化标签 header、nav、article、section、footer</li>
<li>历史管理 history API</li>
</ul>
<h3 id="javascript">JavaScript</h3>
<p><strong>字面量</strong><br>
字面量，和常量差不多，其表达的信息如字面所示</p>
<p><strong>Object.assign(ttarget, ...sources)</strong><br>
将 source 中的可枚举属性复制给 target，重名属性后面的覆盖前面的<br>
复制的是属性值，如果属性值是引用类型则复制引用地址，会出现引用共享的问题（修改其中的一个会影响到别的）</p>
<p><strong>constructor</strong><br>
constructor 属性是专门为 function 设计的，存在于每一个 function 函数的 prototype 原型属性中，是指向 prototype 所在函数的指针<br>
当我们调用该函数作为构造函数创建一个新实例后，该实例中将包含一个指向构造函数中的 prototype 的指针 proto<br>
如果以等于一个以<strong>对象字面量</strong>形式创建的新对象，constructor 不再指向该构造函数，比如</p>
<pre><code class="language-js">var person={ 
    name:&quot;Jack&quot;, 
    age:10
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. 字符串转换整数]]></title>
        <id>https://AriesSK.github.io/post/top_8/</id>
        <link href="https://AriesSK.github.io/post/top_8/">
        </link>
        <updated>2022-07-13T02:25:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="有限状态自动机">有限状态自动机</h3>
<p>对于字符串处理的问题，往往有着复杂的流程和条件，这时候可以使用<strong>有限状态自动机</strong>来解决覆盖所有情况。<br>
有限状态机使程序在每个时刻有一个状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>，每次从序列中输入一个字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，并根据字符 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 转移到下一个状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>s</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>。这样，我们只需要建立一个覆盖所有情况的从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 映射到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>s</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 的表格即可解决题目中的问题。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一模拟">法一：模拟</h3>
<p>逐个字符处理，分情况讨论即可：</p>
<pre><code class="language-js">var myAtoi = function(s) {
    let i = 0;
    // 跳过空格
    while (s.charAt(i) === &quot; &quot;) ++i;
    // 记录数字起始位置
    const j = i;
    // 跳过符号
    if (s.charAt(i) === &quot;+&quot; || s.charAt(i) === &quot;-&quot;) ++i;
    // 符号后非数字
    if (s.charAt(i) &lt; &quot;0&quot; || s.charAt(i) &gt; &quot;9&quot;) return 0;
    // 找到数字结束位置
    while (s.charAt(i) &gt;= &quot;0&quot; &amp;&amp; s.charAt(i) &lt;= &quot;9&quot;) ++i;
    const res = +s.slice(j, i);
    return res &gt;= 0 ? Math.min(res, 2**31 - 1) : Math.max(res, -(2**31));
};
</code></pre>
<h3 id="法二有限状态自动机">法二：有限状态自动机</h3>
<p>定义状态，使用哈希表存储状态转移表，然后遍历字符串，进行状态转移和处理：</p>
<table>
<thead>
<tr>
<th></th>
<th>空格</th>
<th>符号(+/-)</th>
<th>数字</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>起始空格的（状态 0）</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>数字前的符号（状态 1）</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>数字（状态 2）</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>数字结束后的其他字符（状态 3）</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>对于本题来说一旦转移到状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 即可停止遍历字符串。</p>
<pre><code class="language-js">var myAtoi = function(s) {
    let res = 0, sym = 1;
    const state = [
        new Map([[&quot; &quot;, 0], [&quot;s&quot;, 1], [&quot;n&quot;, 2], [&quot;?&quot;, 3]]),
        new Map([[&quot; &quot;, 3], [&quot;s&quot;, 3], [&quot;n&quot;, 2], [&quot;?&quot;, 3]]),
        new Map([[&quot; &quot;, 3], [&quot;s&quot;, 3], [&quot;n&quot;, 2], [&quot;?&quot;, 3]])
    ];
    let p = 0, t = &quot; &quot;;
    for (let c of s.split(&quot;&quot;)) {
        if (c === &quot; &quot;) t = &quot; &quot;;
        else if (c === &quot;+&quot; || c === &quot;-&quot;) {
            t = &quot;s&quot;;
            // 注意这里只有空格后面的 +/- 才代表数字的符号，比如 &quot;-1+2&quot; 中 + 不应当修改数组的符号
            if (p === 0) sym = c === &quot;+&quot; ? 1 : -1;
        }
        else if (c &gt;= &quot;0&quot; &amp;&amp; c &lt;= &quot;9&quot;) {
            t = &quot;n&quot;;
            res = res * 10 + Number(c);
        }
        else t = &quot;?&quot;;
        p = state[p].get(t);
        if (p === 3) break;
    }
    res *= sym;
    return res &gt;= 0 ? Math.min(res, 2**31 - 1) : Math.max(res, -(2**31));
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. 整数反转]]></title>
        <id>https://AriesSK.github.io/post/top_7/</id>
        <link href="https://AriesSK.github.io/post/top_7/">
        </link>
        <updated>2022-07-12T04:40:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>对于大数的问题往往可以通过转化为字符串来解决。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="字符串">字符串</h3>
<p>由于题目要求不能存储超过上限的数字，所以不能直接反转后判断是否超过上限，只能转成字符串后逐位判断：</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">数</mi><mo>&lt;</mo><mi mathvariant="normal">上</mi><mi mathvariant="normal">限</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">数</mi></mrow><annotation encoding="application/x-tex">数字位数 &lt; 上限位数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">限</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">数</span></span></span></span>，不会越界，直接反转；</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">字</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">数</mi><mo>=</mo><mi mathvariant="normal">上</mi><mi mathvariant="normal">限</mi><mi mathvariant="normal">位</mi><mi mathvariant="normal">数</mi></mrow><annotation encoding="application/x-tex">数字位数 = 上限位数</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">数</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">限</span><span class="mord cjk_fallback">位</span><span class="mord cjk_fallback">数</span></span></span></span>，从数字的最后一位和上限的第一位开始逐个比较：数字大则越界，返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；否则不越界，反转数字。</li>
</ul>
<pre><code class="language-js">var reverse = function(x) {
    let sym = 1, num = &quot;&quot;;
    if (x &lt; 0) {
        sym = -1;
        x = -x;
        num += 2**31;
    }
    else num += 2**31 - 1;
    const n = num.length; 
    x += &quot;&quot;; 
    if (x.length === n) {
        for (let i = 0; i &lt; n; ++i) {
            if (x.charAt(n - 1 - i) === num.charAt(i)) continue;
            else if (x.charAt(n - 1 - i) &gt; num.charAt(i)) return 0;
            else break;
        }
    }
    return x.split(&quot;&quot;).reverse().join(&quot;&quot;) * sym;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[5. 最长回文子串]]></title>
        <id>https://AriesSK.github.io/post/top_5/</id>
        <link href="https://AriesSK.github.io/post/top_5/">
        </link>
        <updated>2022-07-12T02:30:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="回文串的判断">回文串的判断</h3>
<p><strong>重要性质：<strong>对于一个回文串，如果其长度大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，那么删去其首尾两个字符，它仍是回文串。<br>
<strong>回文中心：<strong>回文串的中心字符，可以是</strong>一个字符</strong>或者</strong>两个相同的字符</strong>。<br>
可以设定回文中心，然后对其进行扩展，在两端个新增一个字符，若两个字符相同则扩展成功，到无法扩展后就得到了该回文中心的最长回文串。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一动态规划">法一：动态规划</h3>
<p>根据<strong>重要性质</strong>，不难推出状态转移方程：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i, j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 是否是回文串，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mi mathvariant="normal">且</mi><mo>(</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i, j] = dp[i + 1, j - 1] 且 (s[i] = s[j])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord cjk_fallback">且</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></p>
<h3 id="法二中心扩散法">法二：中心扩散法</h3>
<p>遍历字符串，把每个字符作为回文串的<strong>回文中心</strong>尝试扩散，记录最长的回文串：</p>
<pre><code class="language-js">var longestPalindrome = function(s) {
    let res = &quot;&quot;;
    for (let i = 0; i &lt; s.length; ++i) {
        // 回文中心有两种：单字符 和 相同双字符，每次遍历两种均考虑，取长的
        const s1 = helper(i, i), s2 = helper(i, i + 1);
        const s = s1.length &gt; s2.length ? s1 : s2;
        res = s.length &gt; res.length ? s: res;
    }
    return res;

    function helper(l, r) {
        while (l &gt;= 0 &amp;&amp; r &lt; s.length &amp;&amp; s.charAt(l) === s.charAt(r)) {
            --l;
            ++r;
        }
        return s.slice(l + 1, r);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4. 寻找两个正序数组的中位数]]></title>
        <id>https://AriesSK.github.io/post/top_4/</id>
        <link href="https://AriesSK.github.io/post/top_4/">
        </link>
        <updated>2022-07-11T03:46:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="中位数的小技巧">中位数的小技巧</h3>
<p>求中位数一般需要分奇偶两种情况，对于长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为奇数，则中位数为第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个；</li>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为偶数，则中位数为第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个和第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 2) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个数的平均值；<br>
事实上可以<strong>不分奇偶</strong>计算第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(n + 2) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个数（均向下取整）的平均值，对于奇数这两个是同一个数，对于偶数则是对应的两个数，与上面的等价。<br>
这样写的好处是转换为代码后比较精简。</li>
</ul>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一合并有序数组">法一：合并有序数组</h3>
<p>简单，时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，不满足题目要求。</p>
<h3 id="法二二分法">法二：二分法</h3>
<p>这题的二分法很难理解，量力而行吧。<br>
题目要求时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log(m + n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，这个时间复杂度就容易想到要用二分法。<br>
根据<strong>小技巧</strong>，需要在两个数组中找到第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(m+n+1) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>+</mo><mn>2</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">(m+n+2) / 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span></span></span></span> 个数并求平均值，因此转换为了求第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 小个数的问题。<br>
本题二分法的条件是（所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/</span></span></span></span> 均表示整数除法）：</p>
<ul>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo><mo>&lt;</mo><mo>=</mo><mi>B</mi><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">A[k / 2 − 1] &lt;= B[k / 2 − 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，则比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">A[k / 2−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 小的数<strong>最多</strong>只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">k / 2 − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 个数和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 的前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">k / 2 − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 个数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">−</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">k−2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">−</span><span class="mord">2</span></span></span></span> 个，因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">A[k / 2 − 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 不可能是第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数，它之前的也都可以全部排除；</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo><mo>&gt;</mo><mi>B</mi><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">A[k / 2 − 1] &gt; B[k / 2 − 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，则排除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">B[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">B[k / 2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。</li>
</ul>
<p>三种特殊情况，后两种是递归出口：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mi mathvariant="normal">−</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">k / 2 − 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mord">−</span><span class="mord">1</span></span></span></span> 超过了某一个数组的长度，则另一个数组的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>k</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[k / 2 - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 和前面的数均可以排除，因为比其小的数不可能达到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个；</li>
<li>一个数组为空，则返回另一个数组的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 小元素；</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 为一，即找最小的数，返回两个数组首元素的最小值即可。</li>
</ul>
<pre><code class="language-js">var findMedianSortedArrays = function(nums1, nums2) {
    const m = nums1.length, n = nums2.length, l = m + n + 1 &gt;&gt; 1, r = m + n + 2 &gt;&gt; 1;
    return (findKth(nums1, 0, nums2, 0, l) + findKth(nums1, 0, nums2, 0, r)) / 2;

    function findKth(nums1, i, nums2, j, k) {
        // 其一为空，返回另一个的第 k 小
        if (i &gt;= nums1.length) return nums2[j + k - 1];
        if (j &gt;= nums2.length) return nums1[i + k - 1];
        // 为 1，返回最小首元素
        if (k === 1) return Math.min(nums1[i], nums2[j]);
        // 超过数组长度，则赋最大值一保证排除另一个数组的前 k / 2 个元素
        const mid1 = (i + k / 2 - 1 &lt; nums1.length) ? nums1[i + (k &gt;&gt; 1) - 1] : Number.MAX_SAFE_INTEGER;
        const mid2 = (j + k / 2 - 1 &lt; nums2.length) ? nums2[j + (k &gt;&gt; 1) - 1] : Number.MAX_SAFE_INTEGER;
        // 小的数组的前 k / 2 个元素均可以排除，递归排除剩余的
        if (mid1 &lt; mid2) return findKth(nums1, i + (k &gt;&gt; 1), nums2, j, k - (k &gt;&gt; 1));
        else return findKth(nums1, i, nums2, j + (k &gt;&gt; 1), k - (k &gt;&gt; 1));
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3. 无重复字符的最长字串]]></title>
        <id>https://AriesSK.github.io/post/top_3/</id>
        <link href="https://AriesSK.github.io/post/top_3/">
        </link>
        <updated>2022-07-11T02:03:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题与剑指offer的48题相同，只记录一下之前方法的思路，具体请移步<a href="https://ariessk.github.io/post/jianzhi_48/">48. 最长不含重复字串的子字符串</a>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一动态规划">法一：动态规划</h3>
<p>思路：</p>
<ol>
<li>状态定义：使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 记录以下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> <strong>结尾</strong>的最长不重复字串长度；</li>
<li>转移方程：对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>，未出现则记入哈希表，出现则更新，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 和在它前面的相同字符的距离与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 比较，若大于则说明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">s[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 使不重复长度加一，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[i] = dp[i - 1] + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，否则不变；</li>
<li>初始状态：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">dp[0] = 0, dp[1] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li>
<li>返回结果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 数组中的最大值。</li>
</ol>
<h3 id="法二滑动窗口">法二：滑动窗口</h3>
<ol>
<li>使用左指针代表子串的起始位置，而右指针代表字串的结束位置；</li>
<li>左指针每轮右移一格，将下一个字符作为起始位置，在保证窗口中没有重复字符的前提（哈希表）下不断右移右指针。在移动结束后，窗口对应以左指针开始的最长不重复子串，记录其长度；</li>
<li><strong>容易忘记</strong>：左指针移动到最后一个字符，返回记录长度的最大值。</li>
</ol>
<h3 id="新增">新增</h3>
<p>重新做了一遍想出了另一种<strong>滑动窗口</strong>的方法：<br>
右指针右移并将字符和下标记入哈希表：</p>
<ul>
<li>遇重复元素，记录区间长度，更新左指针位置为哈希表中记录的重复元素的下标（<strong>注意不能左移</strong>），重复操作至右指针遍历完字符串；</li>
<li>当右指针遍历完，更新一次区间的长度（<strong>最后一段不重复长度最长的情况</strong>）；</li>
<li>返回最大区间长度。</li>
</ul>
<pre><code class="language-js">var lengthOfLongestSubstring = function(s) {
    const map = new Map();
    let l = 0, r = 0, res = 0;
    while (r &lt; s.length) {
        if (map.has(s.charAt(r))) {
            res = Math.max(res, r - l);
            // 取最大值保证左指针不会左移
            l = Math.max(l, map.get(s.charAt(r)) + 1); 
        }
        map.set(s.charAt(r), r);
        ++r;
    }
    // 遍历完后更新区间长度
    res = Math.max(res, r - l);
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2. 两数相加]]></title>
        <id>https://AriesSK.github.io/post/top_2/</id>
        <link href="https://AriesSK.github.io/post/top_2/">
        </link>
        <updated>2022-07-10T07:55:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>仔细考虑题目，想到每种情况！<br>
修改冗余部分，不断精简代码！</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="模拟">模拟</h3>
<p>遍历链表，模拟加法，注意<strong>进位</strong>，在两链表均遍历完后仍有进位的情况很容易遗漏：</p>
<pre><code class="language-js">var addTwoNumbers = function(l1, l2) {
    let lptr = l1, rptr =  l2, flag = false, node = new ListNode();
    const res = node;
    // 两链表均非空，值相加
    while(lptr &amp;&amp; rptr) {
        let tmp = lptr.val + rptr.val;
        // 进位
        if (flag) {
            tmp += 1;
            flag = false;
        }
        if (tmp &gt;= 10) {
            tmp %= 10;
            flag = true;
        }
        node.next = new ListNode(tmp);
        node = node.next;
        lptr = lptr.next;
        rptr = rptr.next;
    }
    // 一链表为空，考虑另一链表
    if (!lptr) {
        while (rptr) {
            let tmp = rptr.val;
            if (flag) {
                tmp += 1;
                flag = false;
            }
            if (tmp &gt;= 10) {
                tmp %= 10;
                flag = true;
            }
            node.next = new ListNode(tmp);
            node = node.next;
            rptr = rptr.next;
        }
    } else {
        while (lptr) {
            let tmp = lptr.val;
            if (flag) {
                tmp += 1;
                flag = false;
            }
            if (tmp &gt;= 10) {
                tmp %= 10;
                flag = true;
            }
            node.next = new ListNode(tmp);
            node = node.next;
            lptr = lptr.next;
        }
    }
    // 两链表均空，考虑进位
    if (flag) node.next = new ListNode(1);
    return res.next;
};
</code></pre>
<p>上面的解法思路正确但代码过于冗杂，看了题解后作出了如下的优化：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>p</mi><mi>t</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">lptr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>p</mi><mi>t</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">rptr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 并无必要，直接使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">l1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">1</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">l2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">2</span></span></span></span> 即可；</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">flag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 表示进位也并无必要，使用两链表值之和除 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span> 向下取整即可获取进位值，进位加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 不进加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；</li>
<li>循环可以直到两链表均遍历完再停止，一个链表先遍历完后直接用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 替代其 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 即可。</li>
</ul>
<pre><code class="language-js">var addTwoNumbers = function(l1, l2) {
    let carry = 0, node = new ListNode();
    const res = node;
    while(l1 || l2) {
        const n1 = l1 ? l1.val : 0;
        const n2 = l2 ? l2.val : 0;
        let sum = n1 + n2 + carry;
        node.next = new ListNode(sum % 10);
        node = node.next;
        carry = sum &gt;= 10 ? 1 : 0;
        if (l1) l1 = l1.next;
        if (l2) l2 = l2.next;
    }
    if (carry) node.next = new ListNode(1);
    return res.next;
};
</code></pre>
]]></content>
    </entry>
</feed>