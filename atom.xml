<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-06-20T14:01:24.338Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[04. 二维数组中的查找]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_04/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_04/">
        </link>
        <updated>2022-06-13T13:31:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>注意题目中提示了输入可能是空数组，这种情况需要特别考虑：</p>
<pre><code class="language-js">var findNumberIn2DArray = function(matrix, target) {
    // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑
    if (!matrix.length) return false;
    let n = matrix.length, m = matrix[0].length;
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; m; ++j) {
            if (matrix[i][j] === target) return true;
        }
    }
    return false;
};
</code></pre>
<h3 id="法二标志数">法二：标志数</h3>
<p>将矩阵逆时针旋转 45°，能够发现其结构类似<strong>二叉搜索树</strong>，左分支更小，右分支更大；<br>
因此从根节点，也就是右上角开始搜索，比<code>target</code>大就向左，否则向右；<br>
矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。<br>
<img src="https://AriesSK.github.io/post-images/1655732925766.png" alt="" loading="lazy"></p>
<pre><code class="language-js">// 右上角开始
var findNumberIn2DArray = function(matrix, target) {
    if (!matrix.length) return false;
    let i = 0, j = matrix[0].length - 1;
    while (i &lt; matrix.length &amp;&amp; j &gt;= 0) {
        if (matrix[i][j] === target) return true;
        else if (matrix[i][j] &lt; target) ++i;
        else --j;
    }    
    return false;
};

// 左下角开始
var findNumberIn2DArray = function(matrix, target) {
    let i = matrix.length - 1, j = 0;
    // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错
    while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) {
        if (matrix[i][j] === target) return true;
        else if (matrix[i][j] &gt; target) --i;
        else ++j;
    }    
    return false;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[03. 数组中重复的数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_03/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_03/">
        </link>
        <updated>2022-06-12T12:59:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的map对象与set对象">JavaScript 中的<code>Map</code>对象与<code>Set</code>对象</h3>
<p><code>Map</code>对象存储键值对，一些常用的方法如下：</p>
<pre><code class="language-js">set(key, value)
get(key)
has(key)
delete(key)
</code></pre>
<p><code>Set</code>对象是唯一值的集合，一些常用的方法如下：</p>
<pre><code class="language-js">add(key)
clear() // 删除所有
delete(key)
entries() keys() values() // 返回值的数组，分别返回键值对、键名、键值，在 Set 中结果相同
has(key)
size()
</code></pre>
<p><code>Map</code>和<code>Set</code>的 key 可以是任何数据类型。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一哈希表">法一：哈希表</h3>
<p>我一开始想到的是使用<code>Map</code>：</p>
<pre><code class="language-js">var findRepeatNumber = function(nums) {
    let hash = new Map();
    for (let i = 0; i &lt; nums.length; ++i) {
        // 这里需要使用 has()，而不是 get()，防止 get() 取到 0 导致判断出错
        if (!hash.has(nums[i])) hash.set(nums[i], i);
        else return nums[i];
    }
};
</code></pre>
<p>后来发现<code>Map</code>存储的是键值对，但在这题中只需要存 key，不需要存 value，因此用<code>Set</code>更好：</p>
<pre><code class="language-js">var findRepeatNumber = function(nums) {
    let set = new Set();
    for (let i = 0; i &lt; nums.length; ++i) {
        if (!set.has(nums[i])) set.add(nums[i]);
        else return nums[i];
    }
};
</code></pre>
<h3 id="法二原地算法">法二：原地算法</h3>
<p>遍历数组<code>nums</code>，设索引初始值为<code>i = 0</code>：</p>
<ul>
<li>若<code>nums[i] = i</code>：说明此数字已在对应索引位置，无需交换，因此跳过；</li>
<li>若<code>nums[nums[i]] = nums[i]</code>：代表索引<code>nums[i]</code>处和索引<code>i</code>处的元素值都为<code>nums[i]</code>，即找到一组重复值，返回此值<code>nums[i]</code>；</li>
<li>否则：交换索引为<code>i</code>和<code>nums[i]</code>的元素值，将此数字交换至对应索引位置。<br>
若遍历完毕尚未返回，则返回 -1。</li>
</ul>
<pre><code class="language-js">var findRepeatNumber = function(nums) {
    let i = 0;
    while (i &lt; nums.length) {
        if (nums[i] === i) {
            // 直到该位置已放置正确数字再处理下一个位置，以保证数组被完全遍历
            ++i;
            continue;
        }
        if (nums[nums[i]] === nums[i]) return nums[i];
        let tmp = nums[i];
        nums[i] = nums[nums[i]];
        // 注意这里 num[i] 已经被修改了值，因此不能用 nums[nums[i]]
        nums[tmp] = tmp;
    }
    return -1;
};
</code></pre>
]]></content>
    </entry>
</feed>