<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-08-04T07:43:23.351Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[#每日更新# 知识点导航]]></title>
        <id>https://AriesSK.github.io/post/zhishidian/</id>
        <link href="https://AriesSK.github.io/post/zhishidian/">
        </link>
        <updated>2022-08-04T15:59:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="javascript-知识点">JavaScript 知识点</h3>
<p><strong>变量</strong></p>
<ul>
<li>const 声明变量 —— <a href="https://ariessk.github.io/post/jianzhi_57/">57. 和为s的两个数字</a></li>
<li>全局变量的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
</ul>
<p><strong>函数与方法</strong></p>
<ul>
<li>函数与方法 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>赋值与传值</strong></p>
<ul>
<li>原始值与引用值 —— <a href="https://ariessk.github.io/post/jianzhi_25/">25. 合并两个排序的链表</a></li>
<li>函数传值 —— <a href="https://ariessk.github.io/post/jianzhi_13/">13. 机器人的运动范围</a></li>
<li>引用对象的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>赋值运算顺序 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
</ul>
<p><strong>prototype</strong></p>
<ul>
<li>通过构造函数的 prototype 原型属性给对象添加新的方法 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>this 关键字</strong></p>
<ul>
<li>this 的指向 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>数值</strong></p>
<ul>
<li>Number 最值 —— <a href="https://ariessk.github.io/post/jianzhi_59_i/">59 - I.滑动窗口的最大值</a></li>
<li>安全整数 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>判空</strong></p>
<ul>
<li>通过数组长度判空 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>运算符</strong></p>
<ul>
<li>运算符优先级 —— <a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a></li>
<li>展开运算符 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>逻辑运算符的短路 —— <a href="https://ariessk.github.io/post/jianzhi_64/">64. 求1+2+...+n</a></li>
<li>右移运算符向下取整 按位与取余运算 —— <a href="https://ariessk.github.io/post/jianzhi_16/">16. 数值的整数次方</a></li>
<li>位运算 按位与消去最右的 0 —— <a href="https://ariessk.github.io/post/jianzhi_15/">15. 二进制中1的个数</a></li>
<li>位运算替代加法 —— <a href="https://ariessk.github.io/post/jianzhi_65/">65. 不用加减乘除做加法</a></li>
<li>按位异或找只出现一次的数字 —— <a href="https://ariessk.github.io/post/jianzhi_56_i/">56 - I. 数组中数字出现的次数 I</a></li>
<li>位运算获取每一位 为每一位赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>幂运算 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>正则表达式 —— <a href="https://ariessk.github.io/post/jianzhi_19/">19. 正则表达式匹配</a></li>
<li>位运算替代加减乘除运算 —— <a href="https://ariessk.github.io/post/top_33/">29. 两数相除</a></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>二维数组创建 赋值 —— <a href="https://ariessk.github.io/post/jianzhi_32_ii/">32 - II. 从上到下打印二叉树 II</a></li>
<li>创建指定大小的二维数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>数字数组赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>创建二维数组的问题 —— <a href="https://ariessk.github.io/post/jianzhi_29/">29. 顺时针打印矩阵</a></li>
<li>字符数组的 join —— <a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a></li>
<li>判断数组是否包含某元素 —— <a href="https://ariessk.github.io/post/top_2/">2. 两数相加</a></li>
<li>使用 map 创建二维数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>二维数组翻转替代旋转 —— <a href="https://ariessk.github.io/post/top_48/">48. 旋转图像</a></li>
<li>数组的原地算法 —— <a href="https://ariessk.github.io/post/top_73/">73. 矩阵置零</a></li>
</ul>
<p><strong>栈</strong></p>
<ul>
<li>数组模拟栈 —— <a href="https://ariessk.github.io/post/jianzhi_30/">30. 包含min函数的栈</a></li>
<li>栈相关的数组操作 —— <a href="https://ariessk.github.io/post/jianzhi_06/">06. 从头到尾打印链表</a></li>
<li>快速判断出栈序列合法 —— <a href="https://ariessk.github.io/post/jianzhi_31/">31. 栈的压入、弹出序列</a></li>
<li>括号匹配 —— <a href="https://ariessk.github.io/post/top_20/">20. 有效的括号</a></li>
</ul>
<p><strong>队列</strong></p>
<ul>
<li>数组模拟队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>双端队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_iii/">32 - III. 从上到下打印二叉树 III</a></li>
</ul>
<p><strong>堆</strong></p>
<ul>
<li>封装堆的数据结构 —— <a href="https://ariessk.github.io/post/jianzhi_41/">41. 数据流中的中位数</a></li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>对象模拟链表 —— <a href="https://ariessk.github.io/post/jianzhi_35/">35. 复杂链表的复制</a></li>
<li>链表删除 —— <a href="https://ariessk.github.io/post/top_19/">19. 删除链表的倒数第 N 个节点</a></li>
</ul>
<p><strong>树</strong></p>
<ul>
<li>对象模拟树 树的比较 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>二叉搜索树 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>最近公共祖先 —— <a href="https://ariessk.github.io/post/jianzhi_68_ii/">68 - II. 二叉树的最近公共祖先</a></li>
</ul>
<p><strong>字符串</strong></p>
<ul>
<li>字符串中的字符赋值 —— <a href="https://ariessk.github.io/post/jianzhi_05/">05. 替换空格</a></li>
<li>字符串操作函数 —— <a href="https://ariessk.github.io/post/jianzhi_58_ii/">58 - II. 左旋字符串</a></li>
<li>转化为字符数组 获取 ASCII 值 —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>substr slice 与 substring —— <a href="https://ariessk.github.io/post/jianzhi_46/">46. 把数字翻译成字符串</a></li>
<li>slice substr 补充说明 字符 ASCII 范围 —— <a href="https://ariessk.github.io/post/jianzhi_48/">48. 最长不含重复字符的子字符串</a></li>
<li>操作函数的时间复杂度 split 说明 —— <a href="https://ariessk.github.io/post/jianzhi_58_i/">58 - I. 翻转字符单词顺序</a></li>
<li>判断数字字符 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>charAt 越界 —— <a href="https://ariessk.github.io/post/top_14/">14. 最长公共前缀</a></li>
<li>字符和 ASCII 码转化 —— <a href="https://ariessk.github.io/post/top_49/">49. 字母异位词分组</a></li>
</ul>
<p><strong>哈希表</strong></p>
<ul>
<li>Map 和 Set —— <a href="https://ariessk.github.io/post/jianzhi_03/">03. 数组中重复的数字</a></li>
<li>Map 的 key 和 value —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
<li>哈希表与数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>原地哈希表 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>排序函数</strong></p>
<ul>
<li>sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
<li>自定义 sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_61/">61. 扑克牌中的顺子</a></li>
</ul>
<p><strong>箭头函数</strong></p>
<ul>
<li>箭头函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
</ul>
<p><strong>循环遍历</strong></p>
<ul>
<li>for in 与 for of —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>for in 与 for of 遍历未赋值数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>for in 遍历的属性是字符串 —— <a href="https://ariessk.github.io/post/jianzhi_07/">07. 重建二叉树</a></li>
<li>for in 和 for of 遍历的坑 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>判断语句</strong></p>
<ul>
<li>if 判空 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
</ul>
<hr>
<h3 id="算法知识点">算法知识点</h3>
<p><strong>思路</strong></p>
<ul>
<li>算法的优化思路 —— <a href="https://ariessk.github.io/post/top_42/">42. 接雨水</a></li>
</ul>
<p><strong>递归与迭代</strong></p>
<ul>
<li>递归总结 —— <a href="https://ariessk.github.io/post/jianzhi_24/">24. 反转链表</a></li>
<li>迭代与递归的空间复杂度 —— <a href="https://ariessk.github.io/post/jianzhi_68_i/">68 - I. 二叉搜索树的最近公共祖先</a></li>
<li>归并的递归与迭代 —— <a href="https://ariessk.github.io/post/top_23/">23. 合并K个升序链表</a></li>
</ul>
<p><strong>双指针</strong></p>
<ul>
<li>双指针 剪枝 —— <a href="https://ariessk.github.io/post/top_11/">11. 盛水最多的容器</a></li>
<li>双指针 去重 —— <a href="https://ariessk.github.io/post/top_15/">15. 三数之和</a></li>
</ul>
<p><strong>二分法</strong></p>
<ul>
<li>二分法总结 —— <a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a></li>
<li>二分法核心思想 —— <a href="https://ariessk.github.io/post/top_33/">33. 搜索旋转排序数组</a></li>
<li>二分法的问题转化 —— <a href="https://ariessk.github.io/post/top_34/">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
</ul>
<p><strong>广度优先搜索</strong></p>
<ul>
<li>BFS —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>层序遍历 保存完整信息 —— <a href="https://ariessk.github.io/post/jianzhi_37/">37. 序列化二叉树</a></li>
</ul>
<p><strong>深度优先搜索</strong></p>
<ul>
<li>DFS —— <a href="https://ariessk.github.io/post/jianzhi_26/">26. 树的子结构</a></li>
<li>递归转迭代 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>剪枝 —— <a href="https://ariessk.github.io/post/jianzhi_12/">12. 矩阵中的路径</a></li>
<li>前序 中序 后序遍历 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>自顶向下与自底向上 —— <a href="https://ariessk.github.io/post/jianzhi_55_ii/">55 - II. 平衡二叉树</a></li>
<li>前序 中序 后序遍历序列 —— <a href="https://ariessk.github.io/post/jianzhi_33/">33. 二叉搜索树的后序遍历序列</a></li>
<li>字符串排列 —— <a href="https://ariessk.github.io/post/top_17/">17. 电话号码的字母组合</a></li>
<li>深度优先搜索代码优化 —— <a href="https://ariessk.github.io/post/top_22/">22. 括号生成</a></li>
</ul>
<p><strong>动态规划</strong></p>
<ul>
<li>动态规划总结 —— <a href="https://ariessk.github.io/post/jianzhi_10_i/">10 - I. 斐波那契数列</a></li>
<li>二维数组的动态规划 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>动态规划优化 —— <a href="https://ariessk.github.io/post/top_62/">62. 不同路径</a></li>
</ul>
<p><strong>排序</strong></p>
<ul>
<li>快速排序 —— <a href="https://ariessk.github.io/post/jianzhi_45/">45. 把数组排成最小的数</a></li>
<li>快速选择 计数排序 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
<li>归并排序 —— <a href="https://ariessk.github.io/post/jianzhi_51/">51. 数组中的逆序对</a></li>
</ul>
<p><strong>TopK 问题</strong></p>
<ul>
<li>TopK 问题两种解法及比较 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
</ul>
<p><strong>贪心算法</strong></p>
<ul>
<li>贪心算法 —— <a href="https://ariessk.github.io/post/top_55/">55. 跳跃游戏</a></li>
</ul>
<p><strong>超过一半的数</strong></p>
<ul>
<li>摩尔投票法 —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
</ul>
<p><strong>剪绳子</strong></p>
<ul>
<li>两个推论 —— <a href="https://ariessk.github.io/post/jianzhi_14_i/">14 - I.剪绳子 I</a></li>
</ul>
<p><strong>滑动窗口</strong></p>
<ul>
<li>重要性质 —— <a href="https://ariessk.github.io/post/jianzhi_57_ii/">57 - II. 和为s的连续正数序列</a></li>
</ul>
<p><strong>约瑟夫环</strong></p>
<ul>
<li>推导 —— <a href="https://ariessk.github.io/post/jianzhi_62/">62. 圆圈中最后剩下的数字</a></li>
</ul>
<p><strong>有限状态自动机</strong></p>
<ul>
<li>步骤 —— <a href="https://ariessk.github.io/post/jianzhi_20/">20. 表示数值的字符串</a></li>
<li>思路 —— <a href="https://ariessk.github.io/post/top_8/">8. 字符串转换整数</a></li>
</ul>
<p><strong>质数</strong></p>
<ul>
<li>找质数 丑数 —— <a href="https://ariessk.github.io/post/jianzhi_49/">49. 丑数</a></li>
</ul>
<p><strong>正推与逆推</strong></p>
<ul>
<li>两种思路 —— <a href="https://ariessk.github.io/post/jianzhi_60/">60. n个骰子的点数</a></li>
</ul>
<p><strong>大数</strong></p>
<ul>
<li>大数处理 —— <a href="https://ariessk.github.io/post/jianzhi_17/">17. 打印从1到最大的n位数</a></li>
<li>大数越界的求余 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
<li>大数的溢出问题 —— <a href="https://ariessk.github.io/post/top_66/">66. 加一</a></li>
</ul>
<p><strong>中位数</strong></p>
<ul>
<li>中位数小技巧 —— <a href="https://ariessk.github.io/post/top_4/">4. 寻找两个正序数组的中位数</a></li>
</ul>
<p><strong>回文串</strong></p>
<ul>
<li>中心扩散法 —— <a href="https://ariessk.github.io/post/top_5/">5. 最长回文子串</a></li>
</ul>
<p><strong>模拟</strong></p>
<ul>
<li>模拟概念 —— <a href="https://ariessk.github.io/post/top_13/">13. 罗马数字转整数</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[75. 颜色分类]]></title>
        <id>https://AriesSK.github.io/post/top_75/</id>
        <link href="https://AriesSK.github.io/post/top_75/">
        </link>
        <updated>2022-08-04T02:59:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中">JavaScript 中</h3>
<p>方法如下：</p>
<pre><code class="language-js">
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一计数排序">法一：计数排序</h3>
<p>很简单的思路，需要遍历两次数组：</p>
<pre><code class="language-js">var sortColors = function(nums) {
    let a = 0, b = 0, c = 0;
    for (const num of nums) {
        if (num === 0) ++a;
        if (num === 1) ++b;
        if (num === 2) ++c;
    }
    let i = 0;
    while(a--) nums[i++] = 0;
    while(b--) nums[i++] = 1;
    while(c--) nums[i++] = 2;
}; 
</code></pre>
<h3 id="法二单指针">法二：单指针</h3>
<p>同样两次遍历，第一次将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 换到数组头部，第二次遍历将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 之后：</p>
<pre><code class="language-js">var sortColors = function(nums) {
    let ptr = 0;
    for (let i = 0; i &lt; nums.length; ++i) {
        if (nums[i] === 0) swap(i, ptr++);
    }
    for (let i = ptr; i &lt; nums.length; ++i) {
        if (nums[i] === 1) swap(i, ptr++);
    }

    function swap(a, b) {
        const tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}; 
</code></pre>
<h3 id="法三双指针">法三：双指针</h3>
<p>使用两个指针分别交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，只需要遍历<strong>一次</strong>。<br>
需要注意的是，要保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针始终指向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 区间的下一位，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针始终指向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 区间的下一位，所以当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 区间变长一位，两个指针都需要右移一位，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 区间变长一位，只需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针右移一位即可。<br>
而当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针之前时，说明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针指的位置是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这时候若要将后面的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针位置，则需要将换出去的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 再换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针的位置：</p>
<pre><code class="language-js">var sortColors = function(nums) {
    let p0 = 0, p1 = 0;
    for (let i = 0; i &lt; nums.length; ++i) {
        if (nums[i] === 0) {
            swap(i, p0);
            if (p0 &lt; p1) swap(i, p1);
            ++p0;
            ++p1;
        }
        else if (nums[i] === 1) {
            swap(i, p1);
            ++p1;
        }
    }

    function swap(a, b) {
        const tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[73. 矩阵置零]]></title>
        <id>https://AriesSK.github.io/post/top_73/</id>
        <link href="https://AriesSK.github.io/post/top_73/">
        </link>
        <updated>2022-08-04T01:27:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="数组的原地算法">数组的原地算法</h3>
<p>要实现数组的原地算法，则只能尝试通过原数组中的空间来替代额外的标记空间，然而这样会导致原数组的这部分空间被修改，在本题中，因为只需要记录该部分被修改的空间中是否有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，因此额外的标记就与数组大小无关，就可以实现原地算法。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一额外数组">法一：额外数组</h3>
<p>最简单的方法就是使用一个同样的小的二维数组记录原数组中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 出现的位置，然后实现置零，空间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m * n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>
然后又想了想，发现用来记录的二维数组可以使用两个一维数组替代，空间复杂度降至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var setZeroes = function(matrix) {
    const m = matrix.length, n = matrix[0].length;
    const x = new Array(m).fill(0), y = new Array(n).fill(0);
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (!matrix[i][j]) {
                x[i] = 1;
                y[j] = 1;
            }
        }
    }
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (x[i] || y[j]) matrix[i][j] = 0;
        }
    }
};
</code></pre>
<h3 id="法二原地算法">法二：原地算法</h3>
<p>使用矩阵的第一行和第一列替代法一的两个额外数组，先使用两个标记记录第一行和第一列是否有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，然后使用第一行和第一列进行标记，若矩阵剩余部分出现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则将其对于的行列标记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，其余则保持原值以保证第一行和第一列的正确性，最后再通过两个标记置零第一行和第一列：</p>
<pre><code class="language-js">var setZeroes = function(matrix) {
    const m = matrix.length, n = matrix[0].length;
    let x = false, y = false;
    for (let i = 0; i &lt; m; ++i) {
        if (!matrix[i][0]) {
            x = true;
            break;
        }
    }
    for (let j = 0; j &lt; n; ++j) {
        if (!matrix[0][j]) {
            y = true;
            break;
        }
    }
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][j]) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;
        }
    }
    if (x) {
        for (let i = 0; i &lt; m; i++) matrix[i][0] = 0;
    }
    if (y) {
        for (let j = 0; j &lt; n; j++) matrix[0][j] = 0;
    }
};
</code></pre>
<p>还可以优化至只用一个变量标记第一列原本是否存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，再使用第一列的第一个元素元素记录第一行是否存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，要注意这种情况下要从最后一行向上处理矩阵，因为第一行作为标记数组需要最后被处理：</p>
<pre><code class="language-js">var setZeroes = function(matrix) {
    const m = matrix.length, n = matrix[0].length;
    let x = false;
    for (let i = 0; i &lt; m; ++i) {
        if (!matrix[i][0]) x = true;
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][j]) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    for (let i = m - 1; i &gt;= 0; --i) {
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;
        }
        if (x) matrix[i][0] = 0;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试]]></title>
        <id>https://AriesSK.github.io/post/qian-duan-mian-shi/</id>
        <link href="https://AriesSK.github.io/post/qian-duan-mian-shi/">
        </link>
        <updated>2022-08-03T06:15:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端基础">前端基础</h2>
<h3 id="html">HTML</h3>
<p><strong>h5 新特性</strong></p>
<ul>
<li>媒体播放 video 和 audio</li>
<li>本地存储 localStorge 和 sessionStorage</li>
<li>语义化标签 header、nav、article、section、footer</li>
<li>历史管理 history API</li>
<li>新增选择器 document.querySelector()、document.querySelectorAll()，可以方便地获取 DOM 元素，前者返回第一个，后者返回所有，参数为字符串类型的 &quot;选择器语法&quot;</li>
<li>拖拽释放 Drag and drop API</li>
</ul>
<p><strong>h5 新增加的表单元素</strong><br>
datalist：初始化是一个输入框，点击后出现下拉选项列表，下拉选项通过 option 标签创建<br>
keygen：密钥对生成器，提供验证用户的可靠方法，提交表单生成私钥存在客户端，公钥发到服务器<br>
output：用于不同类型的输出</p>
<p><strong>iframe</strong><br>
内联框架，往网页中引入另一个网页<br>
优点：</p>
<ul>
<li>把嵌入的网页原封不动展现</li>
<li>可以将网页公用的部分写成一个页面使用 iframe 来嵌套，有利于网页统一风格，增加代码可重用</li>
<li>多网页引用时只需修改 iframe 内容就可以更改调用它的每一个页面</li>
<li>可以解决加载缓慢的第三方内容</li>
</ul>
<p>缺点：</p>
<ul>
<li>阻塞主页面的 onload 事件</li>
<li>与主页面共享连接池，会影响页面的并行加载，并且产生的多个页面不容易管理</li>
<li>可能出现上下左右滚动条，用户体验差</li>
<li>不利于 SEO 搜索引擎优化，爬虫难处理 iframe 中的内容</li>
<li>许多移动端设备不兼容</li>
<li>增加服务器的 http 请求，大型网站不可取</li>
</ul>
<p><strong>Web Components</strong><br>
提供一套完善的封装机制使 Web 组件化能够标准化，每种框架的组件都统一标准，推动组件的复用<br>
包含四部分：</p>
<ul>
<li>Custom Elements：让开发者自定义 HTML 元素，包括组成、样式和行为</li>
<li>HTML Imports：在 HTML 中引用和复用其他 HTML 文档的方式</li>
<li>HTML Templates：模板</li>
<li>Shadow DOM：提供更好的组织页面元素的方式，类似 DOM 中的 DOM，其元素和样式独立于原始 DOM</li>
</ul>
<p><strong>浏览器渲染</strong><br>
总体流程：</p>
<ol>
<li>解析文档生成 DOM 树；解析 CSS 生成 CSS 规则树；解析 JavaScript 操作前面两种树</li>
<li>完成解析后通过 DOM 树和 CSS 规则树构造 Rendering Tree (渲染树)；然后计算树中每个渲染对象的位置，叫做回流(布局)</li>
<li>调用 UI 组件绘制(重绘)，将渲染树中的渲染对象内容显示在屏幕上</li>
</ol>
<p>构建 DOM 树：</p>
<ol>
<li>浏览器从磁盘或网络读取原始字节数据，通过指定编码转换为字符串</li>
<li>将字符串转换为 Token，其中会表示出当前 Token 是开始标签、结束标签或文本</li>
<li>根据 Token 生成节点对象，构建 DOM 树</li>
</ol>
<p>构建 CSSOM 树：与构建 DOM 树流程类似。<br>
构建渲染树：将两树组合为渲染树，只包含需要显示的节点及其样式信息(display: none; 的节点不会出现在渲染树中)<br>
布局(回流)：生成渲染树后根据渲染树进行布局，计算个节点在页面中的确切位置和大小，也被称为自动重排，布局输出盒模型，所以的相对测量值都会转化为屏幕上的<strong>绝对像素</strong><br>
绘制：布局完成后触发 Paint 事件，将渲染树转换为屏幕上的像素</p>
<p>渲染遇到 JS 文件：JS 的加载、解析和执行都会阻塞 DOM 的执行，遇到 JS 会暂停构建 DOM，等 JS 引擎运行完后再从中断的地方恢复 DOM 构建。所以想让首批渲染快就不应该在首屏加载 JS 文件，建议将 script 标签放在 body 标签底部。JS 不只是阻塞 DOM 构建，会导致 CSSOM 阻塞 DOM 构建，本来样式不改变 DOM，两者互不影响，但因为 JS 不仅能够更改 DOM，还能更改 CSSOM，而 JS 访问需要完整的 CSSOM，所以这种情况下，浏览器<strong>先下载构建 CSSOM，再执行 JS，再构建 DOM</strong></p>
<p>回流：渲染树中出现元素尺寸、布局、隐藏等改变，需要重新构建<br>
重绘：渲染树中元素更改外观，不影响布局<br>
回流必定重绘，重绘不一定回流<br>
减少回流、重绘：使用 transform 替代 top 做动画；使用 visibility 替换 display，opacity替代 visibility；不使用 table 布局；将频繁重绘或回流的节点设置为图层，避免影响别的节点</p>
<p><strong>首次渲染</strong><br>
为了尽快完成首次渲染，需要最大限度减少以下三种可变因素：</p>
<ol>
<li>关键资源数量：可能阻止网页首次渲染的资源</li>
<li>关键路径长度：受关键资源和字节大小一级依赖关系影响</li>
<li>关键字节数量</li>
</ol>
<p>优化关键渲染路径步骤：</p>
<ol>
<li>分析关键路径的资源数、字节数、长度</li>
<li>最大限度减少关键资源的数量：延迟下载，标记为异步等</li>
<li>优化关键字节数，缩短下载时间</li>
<li>优化关键资源加载顺序：尽早下载所有关键资源</li>
</ol>
<p><strong>web 标准的理解</strong><br>
web 标准是多个标准的集合，主要有结构标准、表现标准、行为标准<br>
结构标准：文档的结构与组织，对应 HTML 和 XML<br>
表现标准：文档的表现效果，对应 CSS<br>
行为标准：对网页的逻辑操作，网页的交互，对应 ECMA Script</p>
<p><strong>前端优化</strong><br>
目的：提高页面的加载速度，优化用户的访问体验<br>
可以从三方面优化：<br>
页面内容方面：</p>
<ol>
<li>通过文件合并、css sprite（雪碧图，将页面中涉及到的图都包含到一张大图中）、将图片打包成 base64 格式等方式减少 HTTP 请求数，避免过多的请求造成等待</li>
<li>通过 DNS 缓存机制减少 DNS 的查询次数</li>
<li>通过设置缓存策略，对常用的不变资源进行缓存</li>
<li>使用延迟加载方式减少首屏加载需要请求的资源，延迟加载的资源等需要访问时在请求加载</li>
<li>通过用户行为，对某些资源使用预加载的方式，提高用户需要访问资源时的响应速度</li>
</ol>
<p>服务器方面：</p>
<ol>
<li>使用 CDN(Content Delivery Network，内容分发网络，利用最靠近用户的服务器将用户请求的资源更快更稳定地传输过去) 服务，提高用户对于资源请求时的响应速度</li>
<li>服务器启用 Gzip 对传输资源进行压缩，减小文件体积</li>
<li>尽可能减小 cookie 的大小，并且将静态资源分配到其他域名下，避免请求静态资源时携带不必要的 cookie</li>
</ol>
<p>CSS 和 JS 方面：</p>
<ol>
<li>样式表（外部，内联）放在 head 标签中而不是 body 底部</li>
<li>避免使用 @import 标签</li>
<li>尽量把 js 脚本放在 body 结束标签前或使用 defer、async，避免脚本加载和执行阻塞页面渲染</li>
<li>压缩 js 和 css 文件大小，减小文件体积，比如使用 webpack</li>
</ol>
<h3 id="css">CSS</h3>
<p><strong>水平居中</strong></p>
<ol>
<li>给 div 设置宽度，然后 margin: 0 auto; （margin 上下为 0，左右根据宽度自适应相同值，就实现了居中，注意 div 一定要设置宽度</li>
<li>父容器设置 text-align: center;</li>
</ol>
<p><strong>水平垂直居中</strong></p>
<ol>
<li>绝对定位，top、left、bottom、right 均设为 0，margin 设为 auto</li>
<li>绝对定位，top、left 设置为 50%，margin-left、margin-top 设置为负的宽高的一半（也可以将长宽的一半直接在 top 、left 中减掉；或者使用 transform: translate(-50%, -50%); 向左上角移动一半的宽和高）</li>
<li>父容器设置 flex 布局，并设置 align-item: center; 垂直居中和 justify-content: center; 水平居中</li>
</ol>
<p><strong>浮动高度坍塌</strong><br>
在文档流中，父元素的高度默认被子元素撑开，但当子元素设置为浮动后，就会脱离文档流，导致无法撑起父元素的高度，使父元素高度塌陷，会导致父元素下面的所有元素向上移动，使页面布局混乱。</p>
<p><strong>清除浮动</strong></p>
<ol>
<li>固定父元素的高度，但会导致父元素无法自适应子元素高度（不推荐使用）</li>
<li>触发父元素 BFC，副作用最小的方式是将父元素的 overflow 设置为 hidden，缺点是内容增多时容易造成超出尺寸的内容隐藏</li>
<li>zoom 属性，设置对象缩放比例，触发 hasLayout，清除浮动，是 ie 的专有属性</li>
<li>使用 clear 属性，可以清除浮动元素对该元素的影响，而不是清除浮动，可以在要清除浮动的元素后面加一个空白 div 设置 clear: both;，缺点是会产生很多无意义的标签</li>
<li>根据 3 的思路使用伪元素 after 替代空白标签，注意要设置内容为空，设置为块级元素，设置 clear 属性，因为 clear 属性只有块级元素才有效，而伪元素默认是内联元素（最推荐）</li>
</ol>
<pre><code class="language-css">.clear::after {
    content: '';
    display: block;
    clear: both;
}
</code></pre>
<p><strong>transition 和 animation 的区别</strong><br>
transition 只有开始和结束状态，需要借助别的方式触发<br>
animation 可以有多个状态，有帧的概念，并且可以自动触发</p>
<p>**height: 100%; 失效 **<br>
百分比高度要生效需要父级有一个生效的高度值<br>
所以给父元素设置高度，或者给该元素设置绝对定位（绝对定位的元素会有计算值）</p>
<h3 id="javascript">JavaScript</h3>
<p><strong>字面量</strong><br>
字面量，和常量差不多，其表达的信息如字面所示</p>
<p><strong>Object.assign(target, ...sources)</strong><br>
将 source 中的可枚举属性复制给 target，重名属性后面的覆盖前面的<br>
复制的是属性值，如果属性值是引用类型则复制引用地址，会出现引用共享的问题（修改其中的一个会影响到别的）</p>
<p><strong>constructor</strong><br>
constructor 属性是专门为 function 设计的，存在于每一个 function 函数的 prototype 原型属性中，是指向 prototype 所在函数的指针<br>
当我们调用该函数作为构造函数创建一个新实例后，该实例中将包含一个指向构造函数中的 prototype 的指针 proto<br>
如果以等于一个以<strong>对象字面量</strong>形式创建的新对象，constructor 不再指向该构造函数，比如</p>
<pre><code class="language-js">var person={ 
    name:&quot;Jack&quot;, 
    age:10
};
</code></pre>
<p><strong>map 和 forEach</strong></p>
<pre><code class="language-js">const arr = [1,2,3];
// map 遍历数组并给每个数翻倍
const arr1 = arr.map(x=&gt;x*2); //[2,4,6]
// forEach 遍历数组，有三个参数，分别是：当前遍历的数组元素 item、当前的元素下标 index、数组本身 arr
let sum = 0;
arr.forEach(function(item, index, arr) {
    if (arr[index] &gt; 0) sum += item;
})
</code></pre>
<p>相同点：</p>
<ol>
<li>均循环遍历数组每一项</li>
<li>只能遍历数组</li>
<li>匿名函数都支持三个参数 item、index、arr</li>
<li>匿名函数中的 this 指向 window</li>
</ol>
<p>不同点：</p>
<ol>
<li>map 创建新数组并返回，forEach 无返回</li>
<li>forEach 可以修改原数组，map 不会</li>
</ol>
<p><strong>for of</strong><br>
es6 的新增方法，只限于迭代器(iterator)，也就是<strong>可迭代</strong>对象，比如 Array、Map、Set、String、arguments、TyoedArray 等</p>
<p><strong>js 静态类型检查</strong><br>
静态类型语言：变量在定义的时候有类型声明，类型的检查发生在编译时，在运行的时候无法修改变量类型，编译器可以确定运行时需要的内存总量<br>
动态类型语言：变量在定义的时候无类型声明，类型的检查发生在运行时，在运行的时候可以修改变量类型<br>
对比：静态类型可以尽早发现错误，减少了复杂的错误处理，将数据和行为分离，也有利于代码重构；动态类型的代码比较精简，并且不需要花时间掌握类型<br>
js 的静态类型检查方法：<strong>Flow</strong>是 Facebook 的 js 静态类型检查工具，能够找出类型错误；<strong>TypeScript</strong> 在 js 的基础上添加静态类型定义，并且会被编译成 js</p>
<p><strong>indexOf</strong><br>
<code>str.indexOf(searchValue[, fromIndex])</code> 找到返回第一个匹配字串的起始下标，未找到返回 0<br>
searchValue 不设置会查找字符串 'undefined'<br>
fromIndex 是可选的，不填默认 0，负数等同 0，大于字符串长度等同于字符串长度<br>
<strong>严格区分大小写</strong></p>
<p><strong>变量提升</strong><br>
js 是单线程语言，是按顺序执行，但是一段一段地分析执行，代码执行前的编译阶段会检测到所有的变量和函数声明，添加到叫做 Lexical Environment 的 js 数据结构的内存中，所以能够在真正被声明前使用</p>
<p><strong>HashMap 和 Array</strong><br>
HashMap 散列表 是 数组 + 链表</p>
<ul>
<li>查找效率：HashMap 根据 hashcode 直接算出 index，在数组每个下标的链表只有一个元素的时候，能达到 O(1)；Array 二分查找，受数组长度影响较大</li>
<li>扩容数量：HashMap 初始长度 16，每次扩容申请双倍，扩容次数少；Array 小于 4 申请 4，小于 8 申请 8，大于 8 申请 size * 1.5，申请空间少</li>
<li>扩容效率：HashMap 扩容重新计算每个元素的位置，然后放到新的位置；Array 直接赋值数组，效率更高</li>
<li>内存消耗：Array 使用了独特的方式重复利用因为数组扩容遗留的数组空间，HashMap 没有</li>
</ul>
<p>总的来说，数据量小且使用频繁使用 Array，数据量大使用 HashMap</p>
<p><strong>HashMap 和 Object</strong><br>
两者累次允许按键存取值，删除键，检测键是否有值，不过 Map 有些优势：</p>
<ul>
<li>意外的键：Map 默认不包含任何键；Object 有原型，可能与插入的键名冲突</li>
<li>键的类型：Map 键可以是任意值；Object 只能是 String 或 Symbol</li>
<li>键的顺序：Map 键是有序的，迭代时以<strong>插入顺序</strong>返回；Object 无序</li>
<li>Size：Map 通过 size 容易获取键值对个数；Object 手动计算</li>
<li>迭代：Map 可直接迭代；获取 Object 的键值后才能迭代</li>
<li>性能：Map 在频繁增删时性能更优；Object 无优化</li>
</ul>
<p><strong>原型与原型链</strong><br>
js 每个构造函数都有 prototype 属性指向它的原型对象（实例原型），原型对象派生的子对象叫构造函数<br>
每个构造函数的实例都包含一个指向原型对象的内部指针 __proto__，该属性可以访问原型，但不存在于 Person.prototype 中，而是来自 Object.prototype，使用了 getter 方法<br>
每个原型对象有一个 constructor 指针指向其关联的构造函数<br>
如果原型对象是另一个类型的实例，则该原型对象包含着指向另一个原型的指针，层层递进就会形成实例与原型的链条，称为原型链，是图中蓝色的箭头<br>
<img src="https://AriesSK.github.io/post-images/1658986531078.png" alt="" loading="lazy"><br>
根据原型链，就可以实现 instanceOf，其原理就是判断右边变量的 prototype 是否在左边变量的原型链上即可：</p>
<pre><code class="language-js">funcion instance_of(left, right) {
    let rightProto = right.prototype;
    left = left._proto_;
    while (true) {
        if (left === null) return false;
        if (left === rightProto) return true;
        left = left._proto_;
    }
}
</code></pre>
<p><strong>强弱引用</strong><br>
对象的引用就是强引用，WeakMaps 和 WeakSets 是 js 弱引用的唯一途径，弱引用不能防止对象被垃圾回收</p>
<p><strong>垃圾回收</strong><br>
内存是临时存储变量等数据的位置，内存也有生命周期，从内存创建分配到内存读写再到内存销毁，当内存不再使用，则会被垃圾回收，防止内存泄露（在执行垃圾回收时，遗漏一些内存没有回收）<br>
所以垃圾回收机制的<strong>核心</strong>就是判断内存是否不再使用，有两种方法：</p>
<ul>
<li>引用计数：早期浏览器方法，计算内存被引用的次数，被引用一次计数 +1，不被引用一次计数 -1，计数为 0 就将内存释放回收，该方法简单有效，但循环引用会导致内存泄漏</li>
<li>标记清除：目前浏览器方法，标记所有从根节点开始能够访问到的对象，未被标记的对象就是未被强据引用的垃圾对象，被清除</li>
</ul>
<p><strong>内存泄漏</strong></p>
<ul>
<li>意外的全局变量：全局变量内存不会回收，若全局变量使用不当又没有手动回收（赋值 null），就发生内存泄漏</li>
<li>未被清空的定时器：定时器的生命周期有专门的线程维护，不挂靠在页面上，所以在某个页面使用定时器，页面销毁而没有手动清空定时器，就发生内存泄漏</li>
<li>使用不当的闭包：在一个函数内部定义一个子函数，并且子函数调用了在父函数内定义的变量，并且在父函数外部被调用，这就形成了闭包；通常函数使用完后申请的内存会被回收，但闭包会导致父函数执行完内存仍无法被回收，造成内存泄漏</li>
<li>遗漏的 DOM 引用：DOM 元素的生命周期正常取决与是否挂载在 DOM 树上，但被 js 引用时，还由 js 决定，若未清理则发生内存泄露</li>
<li>未被销毁的事件监听：垃圾回收机制不能判断事件是否需要被解除，需要手动解除，否则出现内存泄漏</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[70. 爬楼梯]]></title>
        <id>https://AriesSK.github.io/post/top_70/</id>
        <link href="https://AriesSK.github.io/post/top_70/">
        </link>
        <updated>2022-08-03T03:27:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>与剑指offer的<a href="https://ariessk.github.io/post/jianzhi_10_ii/">10 - II. 青蛙跳台阶问题</a>相同。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="动态规划">动态规划</h3>
<p>类似斐波那契数列，当前状态只与前两个状态相关，使用滚动数组替代 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 数组：</p>
<pre><code class="language-js">var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    while (n--) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[69. x的平方根]]></title>
        <id>https://AriesSK.github.io/post/top_69/</id>
        <link href="https://AriesSK.github.io/post/top_69/">
        </link>
        <updated>2022-08-03T03:08:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>经典的二分查找题，关键点是找到题目要求的结果的满足条件。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="二分法">二分法</h3>
<p>二分查找，找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mn>2</mn></msup><mo>≤</mo><mi>x</mi><mo>&lt;</mo><mo>(</mo><mi>m</mi><mo>+</mo><mn>1</mn><msup><mo>)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">m^2 \leq x &lt; (m + 1)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.950078em;vertical-align:-0.13597em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，输出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>：</p>
<pre><code class="language-js">var mySqrt = function(x) {
    let l = 0, r = x;
    while (l &lt;= r) {
        const m = l + r &gt;&gt; 1;
        if ((m + 1) * (m + 1) &lt;= x) l = m + 1;
        else if (m * m &gt; x) r = m - 1;
        else return m;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[66. 加一]]></title>
        <id>https://AriesSK.github.io/post/top_66/</id>
        <link href="https://AriesSK.github.io/post/top_66/">
        </link>
        <updated>2022-08-03T02:20:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="大数溢出问题">大数溢出问题</h3>
<p>这道题本来还想了一种方法，是将数组转为数字加一后再转回数组，事实上这是错位的做法，因为数字存储是有上限的，会出现溢出的问题，所以对于大数问题我们常常转化为字符串处理，而这道题里我却想把数组转为数字，就会造成溢出的问题。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="数组">数组</h3>
<p>主要就是进位的问题，在数组中找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span></span></span></span> 即可：</p>
<pre><code class="language-js">var plusOne = function(digits) {
    const n = digits.length - 1;
    for (let i = n; i &gt;= 0; --i) {
        if (digits[i] === 9)  digits[i] = 0;
        else {
            digits[i] += 1;
            break;
        }
        if (!i) digits.unshift(1);
    }
    return digits;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML + CSS]]></title>
        <id>https://AriesSK.github.io/post/html-css/</id>
        <link href="https://AriesSK.github.io/post/html-css/">
        </link>
        <updated>2022-08-02T07:00:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>操作快捷键</strong><br>
Ctrl + Enter 换行，不改变光标后面代码<br>
Alt + Shift + up/down 在上一行/下一行复制该行<br>
选中词后 Ctrl + D，向下一次选择相同的词</p>
<h2 id="网页">网页</h2>
<p><strong>C/S和B/S</strong><br>
C/S：Client/Sever<br>
B/S：Browser/Sever</p>
<p><strong>网页三要素：结构、表现、行为</strong><br>
结构：HTML用于描述页面的结构<br>
表现：CSS用于控制页面中元素的样式<br>
行为：JavaScript用于响应用户操作</p>
<hr>
<h2 id="html">HTML</h2>
<p><strong>超文本标记语言（Hypertext Markup Language, HTML)</strong><br>
超文本指的是使用超链接的方法，将不同空间的文字信息组织在一起的网状文本</p>
<pre><code class="language-html">&lt;!--HTML的注释--&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>标签一般成对出现，单个出现的称为<strong>自结束标签</strong></p>
<p><strong>标签的属性</strong><br>
在开始标签或字节数标签中可以设置标签的属性，属性是一个名值对，属性应当根据文档中的规定编写，有些属性没有属性值</p>
<pre><code class="language-html">&lt;font color=&quot;red&quot;&gt;红色&lt;/font&gt;
</code></pre>
<p><strong>文档声明（DOCTYPE）</strong><br>
html5的文档声明：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
</code></pre>
<p><strong>二进制与十六进制</strong><br>
二进制作为计算机底层的进制使用，而一般显示二进制数使，会转换为十六进制</p>
<p><strong>字符编码</strong><br>
字符集（charset）是编码和解码所从用的规则<br>
若编码和解码使用的字符集不同，则会出现乱码问题<br>
UTF-8 万国码 开发时使用</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>实体</strong><br>
在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格<br>
使用实体（转义字符） <code>&amp;实体的名字;</code><br>
空格<code>&amp;nbsp;</code> 大于<code>&amp;gt;</code> 小于<code>&amp;lt;</code> 版权符<code>&amp;copy;</code></p>
<p><strong>meta标签</strong><br>
charset 指定网页的字符集<br>
name 指定的数据的名称<br>
content 指定的数据的内容</p>
<pre><code class="language-html">&lt;!-- title 标签的内容会作为搜索引擎超链接上的文字显示 --&gt;
&lt;!-- keywords 表示网站的关键字 搜索时的关键词 --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;HTML5,CSS3&quot;&gt;
&lt;!-- description 表示网站的描述 会显示在搜索引擎的搜索结果中 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;这是一个网站&quot;&gt;
&lt;!-- refresh 将网页重定向到另一个网站 --&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://ariessk.github.io&quot;&gt;
</code></pre>
<p>###语义化标签<br>
<strong>HTML负责网页的结构</strong><br>
在使用html标签时，应该关注的是标签的语义，而不是样式</p>
<p><strong>块元素</strong><br>
在页面中独占一行的元素称为块元素（block element） 网页布局主要用块元素 块元素内能放块元素和行内元素 但<code>&lt;p&gt;</code>元素内不能放块元素<br>
<code>&lt;h1&gt;</code> h1~h6 h1最重要 仅次于title 一般一个页面只有一个h1 一般只会用h1~h3<br>
相关的标题可以放标题组里</p>
<pre><code class="language-html">&lt;hgroup&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;h2&gt;&lt;/h2&gt;
&lt;/hgroup&gt;
</code></pre>
<p><code>&lt;p&gt;&lt;/p&gt;</code>段落<br>
<code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>表长引用<br>
<code>&lt;br&gt;</code>换行<br>
<code>&lt;hr&gt;</code>分割线</p>
<p><strong>行内元素</strong><br>
在页面中不会独占一行的元素称为行内元素（inline element） 主要用于包裹元素<br>
<code>&lt;em&gt;&lt;/em&gt;</code>表示语音语调的加重<br>
<code>&lt;strong&gt;&lt;/strong&gt;</code>表强调<br>
<code>&lt;q&gt;&lt;/q&gt;</code>短引用<br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code> 超链接</p>
<p><strong>浏览器修正</strong><br>
浏览器在解析网页时，会对网页中不符合规范的内容进行修正 标签卸载了根元素<code>&lt;html&gt;</code>外面</p>
<p><strong>网页主体</strong></p>
<pre><code class="language-html">&lt;body&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;main&gt;&lt;/main&gt;
    &lt;footer&gt;&lt;/footer&gt;
    &lt;!-- 导航 --&gt;
    &lt;nav&gt;&lt;/nav&gt;
    &lt;!-- 与主体相关的内容（侧边栏） --&gt;
    &lt;aside&gt;&lt;/aside&gt;
    &lt;!-- 文章--&gt;
    &lt;article&gt;&lt;/article&gt;

&lt;/body&gt;
</code></pre>
<p><strong>列表</strong><br>
列表之间可以互相嵌套<br>
无序列表</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>有序列表</p>
<pre><code class="language-html">&lt;ol&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p>定义列表，dt表示定义的内容，dd对内容进行解释说明</p>
<pre><code class="language-html">&lt;dl&gt;
    &lt;dt&gt;&lt;/dt&gt;
    &lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<p><strong>超链接</strong><br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>能够嵌套除它自身的任何元素<br>
目标路径可以是<strong>外部网站</strong>或<strong>内部页面</strong><br>
内部页面通常使用<strong>相对路径</strong>：<code>./</code>表示当前文件所在的目录（可省略），<code>../</code>表示上一级目录</p>
<pre><code class="language-html">&lt;!-- 当前页面打开与新的页面打开 --&gt;
&lt;a href=&quot;&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
</code></pre>
<p><strong>id 属性</strong><br>
通过超链接到页面中的特定位置，要使用 id 属性<br>
id 属性是唯一不重复的，每个标签可以添加一个 id 属性</p>
<pre><code class="language-html">&lt;!-- 回到顶部 --&gt;
&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;
&lt;!-- 回到 id 为bottom的标签处 --&gt;
&lt;a href=&quot;#bottom&quot;&gt;&lt;/a&gt;
&lt;!--未设置是可以用 javascript:; 占位 点击无反应 --&gt;
&lt;a href=&quot;javascript:;&quot;&gt;1&lt;/a&gt;
</code></pre>
<p><strong>图片标签</strong><br>
用于引入外部图片<br>
<code>&lt;img width=&quot;&quot; height=&quot;&quot; src=&quot;&quot; alt=&quot;&quot;&gt;</code> 自结束标签 替换元素<br>
alt 是图片的描述，有些浏览器会在图片无法加载时显示，搜索引擎会根据 alt 中的内容来识别图片<br>
width height 只修改其中一个会等比例缩小<br>
一般在 pc 端不建议修改图片的大小，而在移动端经常需要缩放图片（主要是大图缩小确保清晰度）<br>
<strong>图片格式</strong><br>
jpeg(jpg) 支持颜色比较丰富，不支持透明效果，不支持动图，一般显示照片<br>
gif 支持颜色比较少，支持简单透明，支持动图，一般显示动图<br>
png 支持颜色丰富，支持复杂透明，不支持动图，专为网页而生<br>
webp 谷歌推出的专门用来表示网页中的图片的一种格式，具备其他图片的所有优点，并且文件特别小，但<strong>兼容性不好</strong><br>
base64 将图片使用base64编码，将土拍你转换为字符，通过字符的形式来引入图片，一般用于需要和网页一起加载的图片</p>
<p><strong>内联框架</strong><br>
用于向当前页面中引入一个其他页面<br>
<code>&lt;iframe src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code><br>
frameborder 指定内联框架的边框，0无1有</p>
<p><strong>音视频</strong><br>
<code>&lt;audio src=&quot;&quot; controls autoplay loop&gt;&lt;/audio&gt;</code>controls 是否允许用户控制播放，autoplay 自动播放，但大部分浏览器不会自动播放，loop循环播放，都是无值的属性<br>
下面这种写法能够解决<strong>浏览器不兼容</strong>的问题，不支持<code>&lt;audio&gt;</code>则显示文字，第一个音频无法播放则播放第二个<code>&lt;emobed&gt;</code>支持比较低的浏览器版本，需要设置文件类型以及宽和高，且比较丑。</p>
<pre><code class="language-html">&lt;audio controls&gt;
        &lt;!-- 文字和 embed 二选一即可 --&gt;
        对不起，您的浏览器不支持播放音频，请升级浏览器！
        &lt;source src=&quot;audio.mp3&quot;&gt;
        &lt;source src=&quot;audio.ogg&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;audio/mp3&quot; width=&quot;&quot; height=&quot;&quot;&gt;
    &lt;/audio&gt;
</code></pre>
<p>video 与 audio 使用方法基本相同</p>
<pre><code class="language-html">&lt;video controls&gt;
        &lt;source src=&quot;video.webm&quot;&gt;
        &lt;source src=&quot;video.mp4&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;video/mp4&quot; width=&quot;&quot; height=&quot;&quot;&gt;
&lt;/video&gt;
</code></pre>
<h2 id="css">CSS</h2>
<p>层叠样式表 (Cascading Style Sheets)<br>
网页实际上是一个多层的结构，通过css可以分别为网页的每一层来设置样式，而最终我们能看到的是最上边的一层</p>
<p><strong>使用 css 修改元素样式</strong><br>
法一：内联样式、行内样式<br>
在标签内部通过 style 属性来设置元素的样式，只能对一个标签生效，修改很麻烦（不推荐使用）<br>
<code>&lt;p style=&quot;color: red; font-size: 60px;&quot;&gt;</code><br>
法二：内部样式表<br>
将样式编写到 head 中的 style 标签里，同时设置多个标签，方便修改和复用，但只能对一个网页使用</p>
<pre><code class="language-html">&lt;style&gt;
    p{
        color: red;
        font-size: 60px
    }
&lt;/style&gt;
</code></pre>
<p>法三：外部样式表<br>
将样式编写到外部的 css 文件中，然后在页面中通过 link 标签引入外部的 css 文件，方便多网页复用（最佳），多个网页引用同一个 css 时能够使用到浏览器的缓存机制，加块网站加载速度，提高用户体验</p>
<pre><code class="language-css">p{
    color: red;
    font-size: 60px;
}
</code></pre>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>css 语法</strong><br>
选择器，选择页面中的指定元素<br>
声明块，为指定元素设置样式，声明是名值对结构，名和值以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 连接，以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mpunct">;</span></span></span></span> 结尾</p>
<h3 id="选择器">选择器</h3>
<p>常用选择器：</p>
<ul>
<li>元素选择器，根据标签名选定元素，<code>标签名{}</code></li>
<li>id 选择器，根据元素 id 选中元素，<code>#id属性值{}</code></li>
<li>类选择器，根据元素 class 选中元素，<code>.class值{}</code>，class 和 id 类似，但 class 可重复使用，可以为一个元素指定多个 class，多个 class 之间使用<strong>空格</strong>分隔</li>
<li>通配选择器，选中页面中的所有元素，<code>*{}</code></li>
</ul>
<p>复合选择器：</p>
<ul>
<li>交集选择器，选中同时复合多个条件的元素，<code>选择器1选择2选择器3{}</code>，有元素选择器则必须以<strong>元素选择器开头</strong></li>
<li>选择器分组（并集选择器），同时选择多个选择器对于的元素，<code>选择器1,选择2,选择器3{}</code></li>
</ul>
<p>关系选择器：<br>
父元素：直接包含子元素的元素<br>
祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素<br>
兄弟元素：拥有相同父元素的元素</p>
<ul>
<li>子元素选择器，选中父元素的指定子元素，<code>父元素 &gt; 子元素{}</code></li>
<li>后代元素选择器，选中祖先元素内的指定后代元素，<code>祖先元素 后代元素{}</code></li>
<li>兄弟选择器，选择下一个兄弟，<code>前一个 + 后一个{}</code>，需要<strong>直接相邻</strong>；选择下边所有兄弟，<code>兄 ~ 弟{}</code></li>
</ul>
<p>属性选择器：</p>
<ul>
<li>选择含有指定属性的元素，<code>[属性名]{}</code>，<code>*[属性名]{}</code>表示所有拥有该属性的标签(* 可省略)，<code>标签名[属性名]{}</code>表示拥有该属性的指定标签，比如<code>a[href]{}</code></li>
<li>选择含有指定属性和属性值的元素，<code>[属性名=属性值]{}</code></li>
<li>选择属性值以指定值开头的元素，<code>[属性名^=属性值]{}</code></li>
<li>选择属性值以指定值结尾的元素，<code>[属性名$=属性值]{}</code></li>
<li>选择属性值中含有指定值的元素，<code>[属性名*=属性值]{}</code></li>
</ul>
<p>伪类选择器：<br>
伪类，特殊的类，用来描述一个元素的特殊状态，比如：第一个元素、被点击的元素、鼠标移入的元素<br>
伪类一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>elem:first-child</code>，选中父元素的第一个子元素，并且其标签名是 elem，若第一个标签不是 elem 则无选中</li>
<li><code>elem:last-child</code>，选中父元素的最后一个子元素，并且其标签名是 elem</li>
<li><code>elem:nth-child()</code>，选中父元素的第 n 个子元素，并且其标签名是 elem，括号内可填值表示第几个，其中有特殊值：n 表示选中所有（1~正无穷）；2n 或 even 表示选中偶数位的元素；2n+1 或 odd 表示奇数位的元素</li>
</ul>
<p>上述的伪类均根据<strong>所有的子元素</strong>进行排序</p>
<ul>
<li><code>elem:first-of-type</code></li>
<li><code>elem:last-of-type</code></li>
<li><code>elem:nth-of-type()</code></li>
</ul>
<p>上述这三个与前面的功能类似，但是是在<strong>相同元素</strong>中进行排序</p>
<ul>
<li><code>:not()</code>，否定选择器，将复合条件的元素从选择器中去除，比如``ul &gt; li:not(:nth-of-type(1)){}`是排除第一个</li>
<li><code>elem:empty</code>，选中不包含子元素和内容的 elem 元素</li>
<li><code>:checked</code>，单选或复选框被选中</li>
</ul>
<p>超链接的伪类：<br>
其执行顺序是 <strong>LoVeHAte</strong>，原因如下：</p>
<ul>
<li>未访问的链接（正常的链接），<code>a:link</code>，专属于超链接标签，无操作便具有<code>:link</code>状态</li>
<li>访问过的链接，<code>a:visited</code>，由于隐私的原因，这个伪类只能修改颜色，专属于超链接标签，访问后具备<code>:link</code>和<code>:visited</code>两种状态</li>
<li>鼠标移入的状态，<code>:hover</code>，鼠标移入访问过的链接，同时具备<code>:link</code>、<code>:visited</code>和<code>:hover</code>三种状态</li>
<li>鼠标点击的状态，<code>:active</code>，点击已访问链接未松开，同时具备<code>:link</code>、<code>:visited</code>、<code>:hover</code>和<code>:active</code>四种状态</li>
</ul>
<p>伪元素选择器：<br>
伪元素，表示页面中一些特殊的不真实存在的元素（特殊的位置），一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>::first-letter</code>，第一个字母</li>
<li><code>::first-line</code>，第一行</li>
<li><code>::selection</code>，选中的内容</li>
<li><code>::before</code>，表示元素的开始，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
<li><code>::after</code>，表示元素的结束，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
</ul>
<pre><code class="language-css">/* before 和 after 需要结合 content 属性使用才能看出效果 */
/* 下面的例子是在元素的开头插入红色字符串 'abc' */
div::before{
    content: 'abc';
    color: red;
}
</code></pre>
<p><strong>选择器的权重</strong><br>
样式的冲突，通过不同的选择器选中了相同的元素，并且为相同的样式设置了不同的值时，就发生了冲突<br>
此时应用哪个样式有选择器的权重（优先级）决定，选择器越具体优先级越高<br>
选择器的权重（数字仅是为了说明数量级）：</p>
<ul>
<li>内联样式 1,0,0,0</li>
<li>id 选择器 0,1,0,0</li>
<li>类和伪类选择器 0,0,1,0</li>
<li>元素选择器 0,0,0,1</li>
<li>通配选择器 0,0,0,0</li>
<li>继承的样式 没有优先级，即优先级低于通配</li>
</ul>
<p>比较优先级是，需要将所有选择器的优先级相加后再比较优先级（除了<strong>分组选择器</strong>是单独计算的），而选择器的累加不会超过其最大的<strong>数量级</strong>，类选择器再多也不会超过 id 选择器<br>
相同优先级，后面的会覆盖前面的<br>
可以在某一个样式后边添加<code>!important</code>则会获取到最高的优先级（超过内联样式），需要<strong>慎用</strong></p>
<pre><code class="language-css">.class{
    background-color: red !important;
}
</code></pre>
<p><strong>样式的继承</strong><br>
继承发生在<strong>祖先与后代</strong>之间，为一个元素设置样式同时也会应用到它的<strong>后代元素</strong><br>
继承的设计是为了方便开发，利用继承可以将一些通用的样式设置到共同的祖先元素上，这样只需设置一次<br>
并不是<strong>所有</strong>的样式都会被继承，比如背景相关的，布局相关的样式等</p>
<p><strong>长度单位</strong><br>
像素（px）：不同屏幕的像素大小是不同的<br>
百分比：能够将属性值设置为相对于其父元素属性的百分比，能够使子元素跟随父元素的改变而改变<br>
em：相对于元素的字体大小来计算的，1em = 1font-size，会随着字体的大小改变<br>
rem：相对于根元素的字体大小来计算</p>
<p><strong>颜色单位</strong><br>
颜色名：在 css 中可以直接使用颜色名来设置颜色，但不常用<br>
RGB：通过三种颜色的不同浓度来调配出不同的颜色，每一种范围在 0 - 255(0% - 100%) 之间，是光的三原色，均为 0 则黑，均为 255 则黑</p>
<pre><code class="language-css">.box{
    background-color: rgb(0, 0, 0);
    background-color: rgb(255, 255, 255);
}
</code></pre>
<p>RGBA：在 RGB 的基础上多了一个透明度 A，1 表示不透明，0 表示全透明，.5 半透明<br>
十六进制的 RGB 值：语法 #RGB，每种颜色用两位十六进制数表示，00 - ff<br>
HSL：H 色相(0 - 360)，S 饱和度(0% - 100%)，L 亮度(0% - 100%)<br>
HSLA：多一个透明度</p>
<h3 id="布局">布局</h3>
<p><strong>文档流</strong><br>
网页是多层结构，最底下的一层称为文档流，是网页的基础，创建的元素默认都在文档流中进行排列<br>
元素主要有两个状态：<strong>在文档流中</strong>和<strong>不在文档流中（脱离文档流）</strong><br>
元素在文档流中的特点：</p>
<ul>
<li>块元素：在页面中独占一行（自上向下垂直排列）；默认宽度是父元素的全部（把父元素撑满）；默认高度是被内容（子元素）撑开</li>
<li>行内元素：不会独占页面的一行，只占自身的大小；在页面中从左向右排列，如果在一行中不能容纳，则换到第二行；默认宽度和高度都被内容撑开</li>
</ul>
<p><strong>盒模型</strong><br>
css 将页面中的所有元素都设置为了一个矩形的盒子，盒子的可见框大小由内容区、内边距和边框共同决定<br>
每一个盒子都由以下击鼓部分组成：</p>
<ul>
<li>内容区(content)： 元素中的所有子元素和文本内容都在内容区中排列，内容区的大小由 width 和 height 两个属性来设置</li>
<li>内边距(padding)，内容区和边框之间的距离，可以用 padding 简写，也可以用 padding-xxx (xxx 可以是 top right bottom left)，内边距的大小会影响到盒子的大小，背景颜色会延伸到内边距上</li>
<li>边框(border)：属于盒子的边缘，需要设置三个样式
<ol>
<li>边框的宽度(border-width)，可以用来指定四个方向边框的宽度，四个值（上 右 下 左、顺时针），三个值（上 左右 下），两个值（上下 左右），一个值（上下左右）；或者使用 boder-xxx-width 单独指定某一个边框，默认 3px，边框的大小会直接影响盒子的大小</li>
<li>边框的颜色(border-color)，同样可分别以指定四个边的颜色，规则同上，默认黑</li>
<li>边框的样式(border-style)，实线(solid)，点状虚线(dotted)，虚线(dashed)，双线(double)，默认 none 表示没有边框<br>
boder 还有简写属性，同时设置边框的所有相关样式，并且<strong>没有</strong>顺序要求<code>border: 10px red solid</code>，也可以使用<code>border-xxx</code>分别设置四个边</li>
</ol>
</li>
<li>外边距(margin)，不影响可见框大小，但影响盒子的位置，有四个方向的外边距，可以用 margin 简写，也可以用 margin-xxx 设置（默认情况下设置 margin-right 不会产生效果，一般由浏览器调整），由于元素默认自左向右排列，因此设置左、上外边距会移动元素自身，而设置右、下外边距会移动其他元素。margin 设置负值则反向移动。margin 会影响盒子实际占用空间</li>
</ul>
<p><strong>盒模型的水平布局</strong><br>
元素在其父元素中水平方向的位置由以下几个属性共同决定：margin-left，border-left，padding-left，width，padding-right，border-right，margin-right<br>
它们的总和<strong>必须等于</strong>父元素内容区的宽度<br>
如果等式不成立，称为过度约束，等式自动调整：</p>
<ul>
<li>若七个值没有 auto 的情况，则自动调整 margin-right 使等式成立；</li>
<li>而 width，margin-left，margin-right能够设置 auto，设置后会自动调整该属性，其中 width 的默认值就是 auto；</li>
<li>宽度和一个外边距设置为 auto，宽度会调整到最大值，外边距为 0</li>
<li>三个都设置为 auto，则外边距都是 0，宽度最大</li>
<li>外边距为 auto，宽度固定，则将外边距设计为相同值（常用于在父元素中水平居中）</li>
</ul>
<p><strong>盒模型的垂直布局</strong><br>
子元素在父元素的内容区中排列，若子元素的大小超过了父元素，则子元素会从父元素中溢出<br>
使用 overflow 属性来设置父元素如何处理溢出的子元素（在父元素中设置），可选值：</p>
<ul>
<li>visible，默认值，使子元素溢出，在父元素外显示</li>
<li>hidden，溢出内容将被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整的内容</li>
<li>auto，根据需要生成滚动条<br>
overflow-x 和 overflow-y 可以分别设置横向和纵向的溢出</li>
</ul>
<p><strong>垂直外边距的重叠(折叠)</strong><br>
相邻的垂直方向的外边距会发生重叠现象：</p>
<ul>
<li>兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大的（都是正或负值），如果一正一副取两者和，对开发有利，不需要处理</li>
<li>父子元素间的相邻垂直外边距，子元素的会传递给父元素（上外边距），会影响到页面的布局，需要进行处理</li>
</ul>
<p><strong>行内元素的盒模型</strong><br>
行内元素不支持设置宽度和高度<br>
行内元素可以设置 padding，但不会影响页面的布局<br>
行内元素可以设置 border，垂直方向的 border 不会影响页面的布局<br>
行内元素可以设置 margin，垂直方向的 margin 不会影响页面的布局</p>
<p>display 用来设置元素的显示类型，可选值：</p>
<ul>
<li>inline 将元素设置为行元素</li>
<li>block 将元素设置为块元素</li>
<li>inline-block 将元素设置为行内块元素，可以设置宽高又不会独占一行</li>
<li>table 将元素设置为一个表格</li>
<li>none 元素不在页面中显示</li>
</ul>
<p>visibility 用来设置元素的显示状态，可选值：</p>
<ul>
<li>visible 默认值，元素在页面中正常显示</li>
<li>hidden 元素在也页面中隐藏不显示，但依然占据页面的位置</li>
</ul>
<p><strong>默认样式</strong><br>
通常情况浏览器都会为元素设置一些默认样式，会影响到页面的布局，因此需要去除浏览器的默认样式（PC端），可以使用别人的<strong>重置样式表</strong>，引入 css 文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[62. 不同路径]]></title>
        <id>https://AriesSK.github.io/post/top_62/</id>
        <link href="https://AriesSK.github.io/post/top_62/">
        </link>
        <updated>2022-08-02T02:29:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="动态规划优化">动态规划优化</h3>
<p>对于当前状态只与前一状态有关的动态规划，往往可以使用<strong>滚动数组</strong>的方式降低空间复杂度。<br>
像这道题就是经典的动态规划题，基础的做法空间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的，使用滚动数组替代二维数组就可以将空间复杂度降至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>
该题的法一的优化方法值得多思考！！！</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一动态规划">法一：动态规划</h3>
<p>简单的动态规划：</p>
<pre><code class="language-js">var uniquePaths = function(m, n) {
    const dp = new Array(m).fill().map(() =&gt; new Array(n).fill(1));
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
};
</code></pre>
<p>该方法还能优化，因为当前状态只和该行和上一行有关，可以用一维数组替代二维数组：</p>
<pre><code class="language-js">var uniquePaths = function(m, n) {
    const dp = new Array(n).fill(1);
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            // dp[j] 在未更新前等于上一行同列的值，dp[j - 1] 已更新是上一列同行的值，更新获得所求值
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
};
</code></pre>
<p>还可以让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 数组长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 中较小的那一个，进一步降低空间复杂度。</p>
<h3 id="法二数学">法二：数学</h3>
<p>数学的方法只要能想到就简单粗暴，时空复杂度均很低。<br>
从左上角到右下角，共移动 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m + n - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次，只需要在其中选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次向下移动的即可，排雷组合问题，总的方案数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_{m + n - 2}^{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre><code class="language-js">var uniquePaths = function(m, n) {
    let res = 1;
    for (let x = n, y = 1; y &lt; m; ++x, ++y) {
        res = res * x / y;
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[56. 合并区间]]></title>
        <id>https://AriesSK.github.io/post/top_56/</id>
        <link href="https://AriesSK.github.io/post/top_56/">
        </link>
        <updated>2022-08-02T02:06:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题主要用到的知识点是自定义<code>sort()</code>函数，总体来说比较简单，有一点小坑。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="排序">排序</h3>
<p>先根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span> 排序数组，将第一个元素作为初始元素，从第二个元素开始尝试合并：</p>
<ul>
<li>若能合并则将合并区间作为初始元素，并则尝试合并下一个元素；</li>
<li>若不能合并，则将初始元素存入结果数组，并将当前元素更新为初始元素；</li>
<li>遍历完毕后需要将最终的初始元素存入结果数组。</li>
</ul>
<p><strong>特别</strong>需要注意的是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span> 较小的元素的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 不一定较小，因此在合并区间的时候，合并后的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 要取两个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 的较大值。</p>
<pre><code class="language-js">var merge = function(intervals) {
    const res = [];
    intervals.sort((a, b) =&gt; a[0] - b[0]);
    let tmp = intervals[0];
    for (let i = 1; i &lt; intervals.length; ++i) {
        if (tmp[1] &gt;= intervals[i][0]) tmp = [tmp[0], Math.max(tmp[1], intervals[i][1])];
        else {
            res.push(tmp)
            tmp = intervals[i];
        }
    }
    res.push(tmp);
    return res;
};
</code></pre>
]]></content>
    </entry>
</feed>