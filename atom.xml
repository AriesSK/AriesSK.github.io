<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-08-01T04:00:44.129Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[#每日更新# 知识点导航]]></title>
        <id>https://AriesSK.github.io/post/zhishidian/</id>
        <link href="https://AriesSK.github.io/post/zhishidian/">
        </link>
        <updated>2022-08-01T15:59:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="javascript-知识点">JavaScript 知识点</h3>
<p><strong>变量</strong></p>
<ul>
<li>const 声明变量 —— <a href="https://ariessk.github.io/post/jianzhi_57/">57. 和为s的两个数字</a></li>
<li>全局变量的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
</ul>
<p><strong>函数与方法</strong></p>
<ul>
<li>函数与方法 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>赋值与传值</strong></p>
<ul>
<li>原始值与引用值 —— <a href="https://ariessk.github.io/post/jianzhi_25/">25. 合并两个排序的链表</a></li>
<li>函数传值 —— <a href="https://ariessk.github.io/post/jianzhi_13/">13. 机器人的运动范围</a></li>
<li>引用对象的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>赋值运算顺序 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
</ul>
<p><strong>prototype</strong></p>
<ul>
<li>通过构造函数的 prototype 原型属性给对象添加新的方法 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>this 关键字</strong></p>
<ul>
<li>this 的指向 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>数值</strong></p>
<ul>
<li>Number 最值 —— <a href="https://ariessk.github.io/post/jianzhi_59_i/">59 - I.滑动窗口的最大值</a></li>
<li>安全整数 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>判空</strong></p>
<ul>
<li>通过数组长度判空 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>运算符</strong></p>
<ul>
<li>运算符优先级 —— <a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a></li>
<li>展开运算符 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>逻辑运算符的短路 —— <a href="https://ariessk.github.io/post/jianzhi_64/">64. 求1+2+...+n</a></li>
<li>右移运算符向下取整 按位与取余运算 —— <a href="https://ariessk.github.io/post/jianzhi_16/">16. 数值的整数次方</a></li>
<li>位运算 按位与消去最右的 0 —— <a href="https://ariessk.github.io/post/jianzhi_15/">15. 二进制中1的个数</a></li>
<li>位运算替代加法 —— <a href="https://ariessk.github.io/post/jianzhi_65/">65. 不用加减乘除做加法</a></li>
<li>按位异或找只出现一次的数字 —— <a href="https://ariessk.github.io/post/jianzhi_56_i/">56 - I. 数组中数字出现的次数 I</a></li>
<li>位运算获取每一位 为每一位赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>幂运算 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>正则表达式 —— <a href="https://ariessk.github.io/post/jianzhi_19/">19. 正则表达式匹配</a></li>
<li>位运算替代加减乘除运算 —— <a href="https://ariessk.github.io/post/top_33/">29. 两数相除</a></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>二维数组创建 赋值 —— <a href="https://ariessk.github.io/post/jianzhi_32_ii/">32 - II. 从上到下打印二叉树 II</a></li>
<li>创建指定大小的二维数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>数字数组赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>创建二维数组的问题 —— <a href="https://ariessk.github.io/post/jianzhi_29/">29. 顺时针打印矩阵</a></li>
<li>字符数组的 join —— <a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a></li>
<li>判断数组是否包含某元素 —— <a href="https://ariessk.github.io/post/top_2/">2. 两数相加</a></li>
<li>使用 map 创建二维数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>二维数组翻转替代旋转 —— <a href="https://ariessk.github.io/post/top_48/">48. 旋转图像</a></li>
</ul>
<p><strong>栈</strong></p>
<ul>
<li>数组模拟栈 —— <a href="https://ariessk.github.io/post/jianzhi_30/">30. 包含min函数的栈</a></li>
<li>栈相关的数组操作 —— <a href="https://ariessk.github.io/post/jianzhi_06/">06. 从头到尾打印链表</a></li>
<li>快速判断出栈序列合法 —— <a href="https://ariessk.github.io/post/jianzhi_31/">31. 栈的压入、弹出序列</a></li>
<li>括号匹配 —— <a href="https://ariessk.github.io/post/top_20/">20. 有效的括号</a></li>
</ul>
<p><strong>队列</strong></p>
<ul>
<li>数组模拟队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>双端队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_iii/">32 - III. 从上到下打印二叉树 III</a></li>
</ul>
<p><strong>堆</strong></p>
<ul>
<li>封装堆的数据结构 —— <a href="https://ariessk.github.io/post/jianzhi_41/">41. 数据流中的中位数</a></li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>对象模拟链表 —— <a href="https://ariessk.github.io/post/jianzhi_35/">35. 复杂链表的复制</a></li>
<li>链表删除 —— <a href="https://ariessk.github.io/post/top_19/">19. 删除链表的倒数第 N 个节点</a></li>
</ul>
<p><strong>树</strong></p>
<ul>
<li>对象模拟树 树的比较 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>二叉搜索树 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>最近公共祖先 —— <a href="https://ariessk.github.io/post/jianzhi_68_ii/">68 - II. 二叉树的最近公共祖先</a></li>
</ul>
<p><strong>字符串</strong></p>
<ul>
<li>字符串中的字符赋值 —— <a href="https://ariessk.github.io/post/jianzhi_05/">05. 替换空格</a></li>
<li>字符串操作函数 —— <a href="https://ariessk.github.io/post/jianzhi_58_ii/">58 - II. 左旋字符串</a></li>
<li>转化为字符数组 获取 ASCII 值 —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>substr slice 与 substring —— <a href="https://ariessk.github.io/post/jianzhi_46/">46. 把数字翻译成字符串</a></li>
<li>slice substr 补充说明 字符 ASCII 范围 —— <a href="https://ariessk.github.io/post/jianzhi_48/">48. 最长不含重复字符的子字符串</a></li>
<li>操作函数的时间复杂度 split 说明 —— <a href="https://ariessk.github.io/post/jianzhi_58_i/">58 - I. 翻转字符单词顺序</a></li>
<li>判断数字字符 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>charAt 越界 —— <a href="https://ariessk.github.io/post/top_14/">14. 最长公共前缀</a></li>
<li>字符和 ASCII 码转化 —— <a href="https://ariessk.github.io/post/top_49/">49. 字母异位词分组</a></li>
</ul>
<p><strong>哈希表</strong></p>
<ul>
<li>Map 和 Set —— <a href="https://ariessk.github.io/post/jianzhi_03/">03. 数组中重复的数字</a></li>
<li>Map 的 key 和 value —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
<li>哈希表与数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>原地哈希表 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>排序函数</strong></p>
<ul>
<li>sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
<li>自定义 sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_61/">61. 扑克牌中的顺子</a></li>
</ul>
<p><strong>箭头函数</strong></p>
<ul>
<li>箭头函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
</ul>
<p><strong>循环遍历</strong></p>
<ul>
<li>for in 与 for of —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>for in 与 for of 遍历未赋值数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>for in 遍历的属性是字符串 —— <a href="https://ariessk.github.io/post/jianzhi_07/">07. 重建二叉树</a></li>
<li>for in 和 for of 遍历的坑 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>判断语句</strong></p>
<ul>
<li>if 判空 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
</ul>
<hr>
<h3 id="算法知识点">算法知识点</h3>
<p><strong>思路</strong></p>
<ul>
<li>算法的优化思路 —— <a href="https://ariessk.github.io/post/top_42/">42. 接雨水</a></li>
</ul>
<p><strong>递归与迭代</strong></p>
<ul>
<li>递归总结 —— <a href="https://ariessk.github.io/post/jianzhi_24/">24. 反转链表</a></li>
<li>迭代与递归的空间复杂度 —— <a href="https://ariessk.github.io/post/jianzhi_68_i/">68 - I. 二叉搜索树的最近公共祖先</a></li>
<li>归并的递归与迭代 —— <a href="https://ariessk.github.io/post/top_23/">23. 合并K个升序链表</a></li>
</ul>
<p><strong>双指针</strong></p>
<ul>
<li>双指针 剪枝 —— <a href="https://ariessk.github.io/post/top_11/">11. 盛水最多的容器</a></li>
<li>双指针 去重 —— <a href="https://ariessk.github.io/post/top_15/">15. 三数之和</a></li>
</ul>
<p><strong>二分法</strong></p>
<ul>
<li>二分法总结 —— <a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a></li>
<li>二分法核心思想 —— <a href="https://ariessk.github.io/post/top_33/">33. 搜索旋转排序数组</a></li>
<li>二分法的问题转化 —— <a href="https://ariessk.github.io/post/top_34/">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
</ul>
<p><strong>广度优先搜索</strong></p>
<ul>
<li>BFS —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>层序遍历 保存完整信息 —— <a href="https://ariessk.github.io/post/jianzhi_37/">37. 序列化二叉树</a></li>
</ul>
<p><strong>深度优先搜索</strong></p>
<ul>
<li>DFS —— <a href="https://ariessk.github.io/post/jianzhi_26/">26. 树的子结构</a></li>
<li>递归转迭代 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>剪枝 —— <a href="https://ariessk.github.io/post/jianzhi_12/">12. 矩阵中的路径</a></li>
<li>前序 中序 后序遍历 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>自顶向下与自底向上 —— <a href="https://ariessk.github.io/post/jianzhi_55_ii/">55 - II. 平衡二叉树</a></li>
<li>前序 中序 后序遍历序列 —— <a href="https://ariessk.github.io/post/jianzhi_33/">33. 二叉搜索树的后序遍历序列</a></li>
<li>字符串排列 —— <a href="https://ariessk.github.io/post/top_17/">17. 电话号码的字母组合</a></li>
<li>深度优先搜索代码优化 —— <a href="https://ariessk.github.io/post/top_22/">22. 括号生成</a></li>
</ul>
<p><strong>动态规划</strong></p>
<ul>
<li>动态规划总结 —— <a href="https://ariessk.github.io/post/jianzhi_10_i/">10 - I. 斐波那契数列</a></li>
<li>二维数组的动态规划 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
</ul>
<p><strong>排序</strong></p>
<ul>
<li>快速排序 —— <a href="https://ariessk.github.io/post/jianzhi_45/">45. 把数组排成最小的数</a></li>
<li>快速选择 计数排序 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
<li>归并排序 —— <a href="https://ariessk.github.io/post/jianzhi_51/">51. 数组中的逆序对</a></li>
</ul>
<p><strong>TopK 问题</strong></p>
<ul>
<li>TopK 问题两种解法及比较 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
</ul>
<p><strong>贪心算法</strong></p>
<ul>
<li>贪心算法 —— <a href="https://ariessk.github.io/post/top_55/">55. 跳跃游戏</a></li>
</ul>
<p><strong>超过一半的数</strong></p>
<ul>
<li>摩尔投票法 —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
</ul>
<p><strong>剪绳子</strong></p>
<ul>
<li>两个推论 —— <a href="https://ariessk.github.io/post/jianzhi_14_i/">14 - I.剪绳子 I</a></li>
</ul>
<p><strong>滑动窗口</strong></p>
<ul>
<li>重要性质 —— <a href="https://ariessk.github.io/post/jianzhi_57_ii/">57 - II. 和为s的连续正数序列</a></li>
</ul>
<p><strong>约瑟夫环</strong></p>
<ul>
<li>推导 —— <a href="https://ariessk.github.io/post/jianzhi_62/">62. 圆圈中最后剩下的数字</a></li>
</ul>
<p><strong>有限状态自动机</strong></p>
<ul>
<li>步骤 —— <a href="https://ariessk.github.io/post/jianzhi_20/">20. 表示数值的字符串</a></li>
<li>思路 —— <a href="https://ariessk.github.io/post/top_8/">8. 字符串转换整数</a></li>
</ul>
<p><strong>质数</strong></p>
<ul>
<li>找质数 丑数 —— <a href="https://ariessk.github.io/post/jianzhi_49/">49. 丑数</a></li>
</ul>
<p><strong>正推与逆推</strong></p>
<ul>
<li>两种思路 —— <a href="https://ariessk.github.io/post/jianzhi_60/">60. n个骰子的点数</a></li>
</ul>
<p><strong>大数</strong></p>
<ul>
<li>大数处理 —— <a href="https://ariessk.github.io/post/jianzhi_17/">17. 打印从1到最大的n位数</a></li>
<li>大数越界的求余 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>中位数</strong></p>
<ul>
<li>中位数小技巧 —— <a href="https://ariessk.github.io/post/top_4/">4. 寻找两个正序数组的中位数</a></li>
</ul>
<p><strong>回文串</strong></p>
<ul>
<li>中心扩散法 —— <a href="https://ariessk.github.io/post/top_5/">5. 最长回文子串</a></li>
</ul>
<p><strong>模拟</strong></p>
<ul>
<li>模拟概念 —— <a href="https://ariessk.github.io/post/top_13/">13. 罗马数字转整数</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[55. 跳跃游戏]]></title>
        <id>https://AriesSK.github.io/post/top_55/</id>
        <link href="https://AriesSK.github.io/post/top_55/">
        </link>
        <updated>2022-08-01T03:12:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="贪心算法">贪心算法</h3>
<p>贪心算法是指在对问题求解时，总是作出当前最好的选择，即不从整体最优上加以考虑，而是考虑局部最优解。<br>
所求问题的<strong>整体最优解</strong>可以通过一系列**局部最优的选择（贪心选择）**来达到。<br>
贪心算法不能保证求得的解是最佳的。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>一个数组中只有跳转到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 才会无法到达最后一个下标，所以对每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 进行前面的数进行判断，看能不能越过这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>：</p>
<pre><code class="language-js">var canJump = function(nums) {
    // 只有一个元素，一定能到达
    if (nums.length === 1) return true;
    // 数组最后一个下标不用判断
    for (let i = 0; i &lt; nums.length - 1; ++i) {
        if (!nums[i]) {
            // 如果第一个元素就是 $0$，不可能到达
            if (!i) return false;
            // 对每个 0 判断能否越过
            for (let j = i - 1, k = 1; j &gt;= 0; --j, ++k) {
                if (nums[j] &gt; k) break;
                if (!j) return false;
            }
        }
    }
    return true;
};
</code></pre>
<h3 id="法二贪心">法二：贪心</h3>
<p>暴力解法明显要对数组进行多次遍历，时间复杂度较高，这道题可以使用贪心的方法解决。<br>
依次遍历数组的每一个位置，实时维护<strong>最远可以到达的位置</strong>，在白能力过程中若该位置大于等于数组的最后一个位置，则可以返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，若遍历结束仍不可达，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>：</p>
<pre><code class="language-js">var canJump = function(nums) {
    let max = 0;
    for (let i = 0; i &lt; nums.length; ++i) {
        // 可达
        if (max &gt;= nums.length - 1) return true;
        // 当前位置不可达
        if (max &lt; i) break;
        max = Math.max(i + nums[i], max);
    }
    return false;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[54. 螺旋矩阵]]></title>
        <id>https://AriesSK.github.io/post/top_54/</id>
        <link href="https://AriesSK.github.io/post/top_54/">
        </link>
        <updated>2022-08-01T01:46:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>这道题与剑指offer的<a href="https://ariessk.github.io/post/jianzhi_29/">29. 顺时针打印矩阵</a>相同，第二次做成功做出来了。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="模拟">模拟</h3>
<p>设置四个边界，每次沿着一条边界遍历后该边界向内收缩，直到全部元素遍历完，模拟整个过程即可：</p>
<pre><code class="language-js">var spiralOrder = function(matrix) {
    const res = [];
    let l = 0, t = 0, r = matrix[0].length - 1, b = matrix.length - 1;
    while (true) {
        for (let i = l; i &lt;= r; ++i) res.push(matrix[t][i]);
        if (++t &gt; b) break;
        for (let i = t; i &lt;= b; ++i) res.push(matrix[i][r]);
        if (--r &lt; l) break;
        for (let i = r; i &gt;= l; --i) res.push(matrix[b][i]);
        if (--b &lt; t) break;
        for (let i = b; i &gt;= t; --i) res.push(matrix[i][l]);
        if (++l &gt; r) break;
    }
    return res;   
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[50. Pow(x, n)]]></title>
        <id>https://AriesSK.github.io/post/top_50/</id>
        <link href="https://AriesSK.github.io/post/top_50/">
        </link>
        <updated>2022-07-31T08:20:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题与剑指offer<a href="https://ariessk.github.io/post/jianzhi_16/">16. 数值的整数次方</a>相同，使用快速幂 + 迭代解决，比递归空间复杂度低。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="快速幂-迭代">快速幂 + 迭代</h3>
<p>每次对幂的值进行二分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 次幂为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>：</p>
<pre><code class="language-js">var myPow = function(x, n) {
    if (!n) return 1;
    if (!x) return 0;
    let res = 1;
    if (n &lt; 0) {
        x = 1 / x;
        n = -n;
    }
    while (n) {
        // 目的将 n 拆分成 2 的整数次幂的和
        // 比如 x^10，res = x^2 * x^8；x^15，res = x^1 * x^2 * x^4 * x^8 
        if (n &amp; 1) res *= x;
        x *= x;
        n &gt;&gt;&gt;= 1;
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[49. 字母异位词分组]]></title>
        <id>https://AriesSK.github.io/post/top_49/</id>
        <link href="https://AriesSK.github.io/post/top_49/">
        </link>
        <updated>2022-07-31T06:27:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中字符和-ascii-码转化">JavaScript 中字符和 ASCII 码转化</h3>
<p>方法如下：</p>
<pre><code class="language-js">// 字符转 ASCII 码
&quot;a&quot;.charCodeAt(); // 97
// ASCII 码转字符
String.fromCharCode(97); // a
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一排序">法一：排序</h3>
<p>将每个字符串拆分成字符数组，然后进行排序，再恢复成字符串。异位词在排序后应当是相同的，因此可以将排序后的字符串作为键，其对应的字符串数组作为值存入哈希表中，实现分组：</p>
<pre><code class="language-js">var groupAnagrams = function(strs) {
    const map = new Map();
    for (const str of strs) {
        const arr = Array.from(str);
        // 这里用 toString() 替代 join() 也可以，前者中间有逗号，后者没有，只要保证唯一即可
        const key = arr.sort().join(&quot;&quot;); 
        // 有则获取字符串数组，无则创建空数组
        const tmp = map.has(key) ? map.get(key) : new Array();
        tmp.push(str);
        map.set(key, tmp);
    }
    return Array.from(map.values());
};
</code></pre>
<h3 id="法二计数">法二：计数</h3>
<p>法二其实也是排序，只不过将法一的排序换为计数排序，由于小写字母只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>26</mn></mrow><annotation encoding="application/x-tex">26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span> 个，所以可以用长度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>26</mn></mrow><annotation encoding="application/x-tex">26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span> 的数组空间来降低排序算法的时间复杂度，关于计数排序详见<a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a>：</p>
<pre><code class="language-js">var groupAnagrams = function(strs) {
    const map = new Map();
    for (const str of strs) {
        const arr = Array.from(str);
        const key = helper(arr);
        const tmp = map.has(key) ? map.get(key) : new Array();
        tmp.push(str);
        map.set(key, tmp);
    }
    return Array.from(map.values());

    function helper(arr) {
        const count = new Array(26).fill(0);
        let str = &quot;&quot;;
        for (const c of arr) count[c.charCodeAt() - &quot;a&quot;.charCodeAt()]++;
        for (let i = 0; i &lt; 26; ++i) {
            if (count[i]) {
                while (count[i]--) str += String.fromCharCode(&quot;a&quot;.charCodeAt() + i);
            }
        }
        return str;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试]]></title>
        <id>https://AriesSK.github.io/post/qian-duan-mian-shi/</id>
        <link href="https://AriesSK.github.io/post/qian-duan-mian-shi/">
        </link>
        <updated>2022-07-30T09:29:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端基础">前端基础</h2>
<h3 id="html">HTML</h3>
<p><strong>h5 新特性</strong></p>
<ul>
<li>媒体播放 video 和 audio</li>
<li>本地存储 localStorge 和 sessionStorage</li>
<li>语义化标签 header、nav、article、section、footer</li>
<li>历史管理 history API</li>
<li>新增选择器 document.querySelector()、document.querySelectorAll()，可以方便地获取 DOM 元素，前者返回第一个，后者返回所有，参数为字符串类型的 &quot;选择器语法&quot;</li>
<li>拖拽释放 Drag and drop API</li>
</ul>
<p><strong>iframe</strong><br>
内联框架，往网页中引入另一个网页<br>
优点：</p>
<ul>
<li>把嵌入的网页原封不动展现</li>
<li>可以将网页公用的部分携程一个页面使用 iframe 来嵌套，有利于网页统一风格，增加代码可重用</li>
<li>多网页引用时只需修改 iframe 内容就可以更改调用它的每一个页面</li>
<li>可以解决加载缓慢的第三方内容</li>
</ul>
<p>缺点：</p>
<ul>
<li>阻塞主页面的 onload 事件</li>
<li>与主页面共享连接池，会影响页面的并行加载，并且产生的多个页面不容易管理</li>
<li>可能出现上下左右滚动条，用户体验差</li>
<li>不利于 SEO 搜索引擎优化，爬虫难处理 iframe 中的内容</li>
<li>许多移动端设备不兼容</li>
<li>增加服务器的 http 请求，大型网站不可取</li>
</ul>
<p><strong>Web Components</strong><br>
提供一套完善的封装机制使 Web 组件化能够标准化，每种框架的组件都统一标准，推动组件的复用<br>
包含四部分：</p>
<ul>
<li>Custom Elements：让开发者自定义 HTML 元素，包括组成、样式和行为</li>
<li>HTML Imports：在 HTML 中引用和复用其他 HTML 文档的方式</li>
<li>HTML Templates：模板</li>
<li>Shadow DOM：提供更好的组织页面元素的方式，类似 DOM 中的 DOM，其元素和样式独立于原始 DOM</li>
</ul>
<h3 id="javascript">JavaScript</h3>
<p><strong>字面量</strong><br>
字面量，和常量差不多，其表达的信息如字面所示</p>
<p><strong>Object.assign(target, ...sources)</strong><br>
将 source 中的可枚举属性复制给 target，重名属性后面的覆盖前面的<br>
复制的是属性值，如果属性值是引用类型则复制引用地址，会出现引用共享的问题（修改其中的一个会影响到别的）</p>
<p><strong>constructor</strong><br>
constructor 属性是专门为 function 设计的，存在于每一个 function 函数的 prototype 原型属性中，是指向 prototype 所在函数的指针<br>
当我们调用该函数作为构造函数创建一个新实例后，该实例中将包含一个指向构造函数中的 prototype 的指针 proto<br>
如果以等于一个以<strong>对象字面量</strong>形式创建的新对象，constructor 不再指向该构造函数，比如</p>
<pre><code class="language-js">var person={ 
    name:&quot;Jack&quot;, 
    age:10
};
</code></pre>
<p><strong>map 和 forEach</strong></p>
<pre><code class="language-js">const arr = [1,2,3];
// map 遍历数组并给每个数翻倍
const arr1 = arr.map(x=&gt;x*2); //[2,4,6]
// forEach 遍历数组，有三个参数，分别是：当前遍历的数组元素 item、当前的元素下标 index、数组本身 arr
let sum = 0;
arr.forEach(function(item, index, arr) {
    if (arr[index] &gt; 0) sum += item;
})
</code></pre>
<p>相同点：</p>
<ol>
<li>均循环遍历数组每一项</li>
<li>只能遍历数组</li>
<li>匿名函数都支持三个参数 item、index、arr</li>
<li>匿名函数中的 this 指向 window</li>
</ol>
<p>不同点：</p>
<ol>
<li>map 创建新数组并返回，forEach 无返回</li>
<li>forEach 可以修改原数组，map 不会</li>
</ol>
<p><strong>for of</strong><br>
es6 的新增方法，只限于迭代器(iterator)，也就是<strong>可迭代</strong>对象，比如 Array、Map、Set、String、arguments、TyoedArray 等</p>
<p><strong>js 静态类型检查</strong><br>
静态类型语言：变量在定义的时候有类型声明，类型的检查发生在编译时，在运行的时候无法修改变量类型，编译器可以确定运行时需要的内存总量<br>
动态类型语言：变量在定义的时候无类型声明，类型的检查发生在运行时，在运行的时候可以修改变量类型<br>
对比：静态类型可以尽早发现错误，减少了复杂的错误处理，将数据和行为分离，也有利于代码重构；动态类型的代码比较精简，并且不需要花时间掌握类型<br>
js 的静态类型检查方法：<strong>Flow</strong>是 Facebook 的 js 静态类型检查工具，能够找出类型错误；<strong>TypeScript</strong> 在 js 的基础上添加静态类型定义，并且会被编译成 js</p>
<p><strong>indexOf</strong><br>
<code>str.indexOf(searchValue[, fromIndex])</code> 找到返回第一个匹配字串的起始下标，未找到返回 0<br>
searchValue 不设置会查找字符串 'undefined'<br>
fromIndex 是可选的，不填默认 0，负数等同 0，大于字符串长度等同于字符串长度<br>
<strong>严格区分大小写</strong></p>
<p><strong>变量提升</strong><br>
js 是单线程语言，是按顺序执行，但是一段一段地分析执行，代码执行前的编译阶段会检测到所有的变量和函数声明，添加到叫做 Lexical Environment 的 js 数据结构的内存中，所以能够在真正被声明前使用</p>
<p><strong>HashMap 和 Array</strong><br>
HashMap 散列表 是 数组 + 链表</p>
<ul>
<li>查找效率：HashMap 根据 hashcode 直接算出 index，在数组每个下标的链表只有一个元素的时候，能达到 O(1)；Array 二分查找，受数组长度影响较大</li>
<li>扩容数量：HashMap 初始长度 16，每次扩容申请双倍，扩容次数少；Array 小于 4 申请 4，小于 8 申请 8，大于 8 申请 size * 1.5，申请空间少</li>
<li>扩容效率：HashMap 扩容重新计算每个元素的位置，然后放到新的位置；Array 直接赋值数组，效率更高</li>
<li>内存消耗：Array 使用了独特的方式重复利用因为数组扩容遗留的数组空间，HashMap 没有</li>
</ul>
<p>总的来说，数据量小且使用频繁使用 Array，数据量大使用 HashMap</p>
<p><strong>HashMap 和 Object</strong><br>
两者累次允许按键存取值，删除键，检测键是否有值，不过 Map 有些优势：</p>
<ul>
<li>意外的键：Map 默认不包含任何键；Object 有原型，可能与插入的键名冲突</li>
<li>键的类型：Map 键可以是任意值；Object 只能是 String 或 Symbol</li>
<li>键的顺序：Map 键是有序的，迭代时以<strong>插入顺序</strong>返回；Object 无序</li>
<li>Size：Map 通过 size 容易获取键值对个数；Object 手动计算</li>
<li>迭代：Map 可直接迭代；获取 Object 的键值后才能迭代</li>
<li>性能：Map 在频繁增删时性能更优；Object 无优化</li>
</ul>
<p><strong>原型与原型链</strong><br>
js 每个构造函数都有 prototype 属性指向它的原型对象（实例原型），原型对象派生的子对象叫构造函数<br>
每个构造函数的实例都包含一个指向原型对象的内部指针 __proto__，该属性可以访问原型，但不存在于 Person.prototype 中，而是来自 Object.prototype，使用了 getter 方法<br>
每个原型对象有一个 constructor 指针指向其关联的构造函数<br>
如果原型对象是另一个类型的实例，则该原型对象包含着指向另一个原型的指针，层层递进就会形成实例与原型的链条，称为原型链，是图中蓝色的箭头<br>
<img src="https://AriesSK.github.io/post-images/1658986531078.png" alt="" loading="lazy"><br>
根据原型链，就可以实现 instanceOf，其原理就是判断右边变量的 prototype 是否在左边变量的原型链上即可：</p>
<pre><code class="language-js">funcion instance_of(left, right) {
    let rightProto = right.prototype;
    left = left._proto_;
    while (true) {
        if (left === null) return false;
        if (left === rightProto) return true;
        left = left._proto_;
    }
}
</code></pre>
<p><strong>强弱引用</strong><br>
对象的引用就是强引用，WeakMaps 和 WeakSets 是 js 弱引用的唯一途径，弱引用不能防止对象被垃圾回收</p>
<p><strong>垃圾回收</strong><br>
内存是临时存储变量等数据的位置，内存也有生命周期，从内存创建分配到内存读写再到内存销毁，当内存不再使用，则会被垃圾回收，防止内存泄露（在执行垃圾回收时，遗漏一些内存没有回收）<br>
所以垃圾回收机制的<strong>核心</strong>就是判断内存是否不再使用，有两种方法：</p>
<ul>
<li>引用计数：早期浏览器方法，计算内存被引用的次数，被引用一次计数 +1，不被引用一次计数 -1，计数为 0 就将内存释放回收，该方法简单有效，但循环引用会导致内存泄漏</li>
<li>标记清除：目前浏览器方法，标记所有从根节点开始能够访问到的对象，未被标记的对象就是未被强据引用的垃圾对象，被清除</li>
</ul>
<p><strong>内存泄漏</strong></p>
<ul>
<li>意外的全局变量：全局变量内存不会回收，若全局变量使用不当又没有手动回收（赋值 null），就发生内存泄漏</li>
<li>未被清空的定时器：定时器的生命周期有专门的线程维护，不挂靠在页面上，所以在某个页面使用定时器，页面销毁而没有手动清空定时器，就发生内存泄漏</li>
<li>使用不当的闭包：在一个函数内部定义一个子函数，并且子函数调用了在父函数内定义的变量，并且在父函数外部被调用，这就形成了闭包；通常函数使用完后申请的内存会被回收，但闭包会导致父函数执行完内存仍无法被回收，造成内存泄漏</li>
<li>遗漏的 DOM 引用：DOM 元素的生命周期正常取决与是否挂载在 DOM 树上，但被 js 引用时，还由 js 决定，若未清理则发生内存泄露</li>
<li>未被销毁的事件监听：垃圾回收机制不能判断事件是否需要被解除，需要手动解除，否则出现内存泄漏</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[48. 旋转图像]]></title>
        <id>https://AriesSK.github.io/post/top_48/</id>
        <link href="https://AriesSK.github.io/post/top_48/">
        </link>
        <updated>2022-07-30T05:31:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二维矩阵翻转替代旋转">二维矩阵翻转替代旋转</h3>
<p>二维矩阵的翻转问题和旋转问题在很多情况下可以相互转换。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一原地旋转">法一：原地旋转</h3>
<p>每个元素旋转后的位置与原位置的关系还是很好找的，但难点就在如何保证<strong>不重复</strong>旋转。<br>
仔细观察后发现规律：对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的二维数组，只需要保证对第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的从第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个元素开始的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 2i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素进行旋转，即可保证不重复旋转。</p>
<pre><code class="language-js">var rotate = function(matrix) {
    const n = matrix.length;
    for (let i = 0; i &lt; n &gt;&gt; 1; ++i) {
        for (let j = i; j &lt; n - i - 1; ++j) {
            const tmp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = tmp;
        }
    }
    return matrix;
};
</code></pre>
<h3 id="法二翻转替代旋转">法二：翻转替代旋转</h3>
<p>法一的规律还是有一些难度的，比较容易出错，还有更巧妙的办法：<br>
先将数组沿水平的中心轴翻转，再将数组沿主对角线翻转，即可起到要求的旋转效果，因为这两步翻转的公式合并起来与法一的公式是相同的：</p>
<pre><code class="language-js">var rotate = function(matrix) {
    const n = matrix.length;
    for (let i = 0; i &lt; n &gt;&gt; 1; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            const tmp = matrix[i][j];
            matrix[i][j] = matrix[n - i - 1][j];
            matrix[n - i - 1][j] = tmp;
        }
    }
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; i; ++j) {
            const tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
        }
    }
    return matrix;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[46. 全排列]]></title>
        <id>https://AriesSK.github.io/post/top_46/</id>
        <link href="https://AriesSK.github.io/post/top_46/">
        </link>
        <updated>2022-07-30T05:20:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>这道题在做的时候又踩了坑，直接将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 加入了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 中，然而后续 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的改变都会影响 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 中的值，记住一定要<strong>深拷贝</strong>数组！详见<a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a>。希望下次别再犯同样的错误了！</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>本题与<a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a>解法一致并且因为元素均不重复，不用考虑剪枝问题，相对简单：</p>
<pre><code class="language-js">var permute = function(nums) {
    const res = [];
    dfs(0);
    return res;

    function dfs(x) {
        if (x === nums.length - 1) {
            // 深拷贝
            res.push([...nums]);
            return;
        }
        for (let i = x; i &lt; nums.length; ++i) {
            swap(x, i);
            dfs(x + 1);
            swap(x, i);
        }
    }

    function swap(a, b) {
        const tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue]]></title>
        <id>https://AriesSK.github.io/post/vue/</id>
        <link href="https://AriesSK.github.io/post/vue/">
        </link>
        <updated>2022-07-29T07:01:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vue-知识">Vue 知识</h2>
<p><strong>单向绑定 与 双向绑定</strong></p>
<ul>
<li>单向绑定：数据改变，页面元素会跟着改变；而页面元素改变，数据不会改变（v-text, v-html, 插值表达式{{}}, v-bind）</li>
<li>双向绑定：页面元素与数据的双向绑定，一方改变另一方也改变（v-model）</li>
</ul>
<p><strong>Vue 的响应式原理</strong><br>
把一个 JS 对象传给 Vue 实例的 data 属性时，Vue 将遍历此对象的所有属性，并且使用 <strong>Object.defineProperty</strong> 将这些属性转换为 getter/setter</p>
<p><strong>Vue 的异步渲染</strong><br>
Vue 实现响应式<strong>不是在数据变化后 DOM 立即变化</strong>，是按异步策略更新的：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li>
<li>主线程之外，还存在一个&quot;任务队列&quot;（task queue），只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件</li>
<li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
<p><strong>Vue 的渲染过程</strong><br>
Vue 加载时文件的执行顺序：</p>
<ol>
<li>执行 index.html 文件</li>
<li>执行 main.js 文件</li>
<li>main.js 挂载 app.vue，用 app.vue 的 templete 替换 index.html 中的<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></li>
<li>main.js 注入路由文件<code>router/index.js</code>，通过路由文件路由到相关组件并将其渲染到 router-view 中</li>
<li>router-view 加载 Layout 文件<br>
Vue 内部页面的执行顺序：</li>
<li>将模板编译为 render 函数</li>
<li>实例挂载，根据根节点 render 函数调用，递归生成虚拟 DOM</li>
<li>将虚拟 DOM 转化为真实 DOM</li>
<li>组件内 data 发生变化，组件重新调用 render 函数生成虚拟 DOM，返回步骤 3</li>
</ol>
<p><strong>render</strong><br>
渲染函数，返回值是 VNode 虚拟节点，使用 render 函数允许使用 js 构建 DOM<br>
createElement 是 render 的参数，也是一个函数，用于构建虚拟 DOM，该函数简写 h</p>
<p><strong>$ 的作用</strong><br>
用于区分 Vue 中自带的实例和用户自定义的属性，有 $ 前缀的是自带的</p>
<p><strong>this</strong><br>
Vue 中会定义很多函数或变量，往往需要在 template 或 script 标签中使用：</p>
<ul>
<li>在 template 中不需要 this</li>
<li>在 script 标签中需要 this（除了在 watch 监听中）</li>
</ul>
<h2 id="vue-指令">Vue 指令</h2>
<p>** v-text 与 v-html**<br>
相同点：均能够展示数据，单向绑定<br>
不同点：</p>
<ul>
<li>v-text 渲染纯文本，浏览器不对其进行 html 解析</li>
<li>v-html 输出 html，浏览器对其进行 html 解析</li>
</ul>
<p><strong>v-if 与 v-show</strong><br>
相同点：通过变量控制标签内容的显示或隐藏<br>
不同点：</p>
<ul>
<li>v-if 是动态地往 DOM 树中添加或删除元素，在初始条件为假则直接不渲染 DOM（惰性的），在条件切换时会对标签进行适当的创建和销毁</li>
<li>v-show 的本质是给 DOM 节点设置 display: none; 来控制隐藏，不论初始条件真假均会渲染DOM，只在初始化时加载一次</li>
</ul>
<p>可以看出 v-if 的开销要大于 v-show，因此前者适用于不频繁切换状态的情况，后者则适用于频繁切换的场景</p>
<p><strong>v-for</strong><br>
用于解决模板循环渲染的问题，还可以渲染 Object 对象</p>
<pre><code class="language-html">&lt;div v-for=&quot;(item, index) in list&quot;&gt;{{index}}{{item}}&lt;/div&gt;
&lt;div v-for=&quot;(val, key, index) in listObj&quot;&gt;{{index}}{{item}}&lt;/div&gt;
</code></pre>
<p>*注意：*v-for 和 v-if 不推荐一起使用，因为处于同一节点时 v-for 的优先级高于 v-if，就会在每一个 v-for 循环中重复运行 v-if，也就意味着即使渲染小部分也要遍历整个数组，造成不必要的计算，影响性能；在 vue3 中 v-if 的优先级高于 v-for 但会导致 v-if 无法访问 v-for 刚定义的变量，因此仍不推荐一起使用<br>
解决方法：使用 computed 属性将需要渲染的列表提前过滤后再给 v-for 渲染</p>
<pre><code class="language-js">computed: {
	activeUsers: function () {
		return this.users.filter( (user)=&gt; {
			return user.isShow;//返回isShow=true的项，添加到activeUsers数组
		})
	}
}
</code></pre>
<p><strong>v-on</strong><br>
监听事件，用来监听 DOM 事件来触发一些方法函数，简写 @</p>
<pre><code class="language-html">&lt;div id='app'&gt;
    &lt;!-- 鼠标点击事件 --&gt;
    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;
    &lt;!-- 键盘输入enter --&gt;
    &lt;input v-model=&quot;username&quot; v-on:keyup.enter=&quot;login&quot; /&gt;
  &lt;/div&gt;
</code></pre>
<p><strong>v-bind</strong><br>
用于属性与变量的绑定</p>
<pre><code class="language-html">&lt;!-- src 属性 imageSrc 变量 --&gt;
&lt;img v-bind:src=&quot;imageSrc&quot;&gt;
&lt;!-- 简写 --&gt;
&lt;img :src=&quot;imageSrc&quot;&gt;
</code></pre>
<p><strong>v-model</strong><br>
语法糖：计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用<br>
双向绑定，可以结合输入框、复选框、单选框等实现动态地修改数据<br>
v-model 是一个语法糖，本质上包含两个操作：</p>
<ul>
<li>v-bind 绑定一个 value 属性</li>
<li>v-on 给当前元素绑定 input 事件</li>
</ul>
<p>v-model 的修饰符：</p>
<ul>
<li>v-model.lazy 接管 input 的事件监听事件，在用户输入时不会马上响应在展示层，只有确认改变时才显示</li>
<li>v-model.trim 去除首尾空格</li>
<li>v-model.trim 输入的字符串转化为数字</li>
</ul>
<p><strong>v-cloak</strong><br>
使用 v-cloak 设置的样式会在 vvue 实例编译完成后从绑定的 html 标签上移除<br>
可以有效防止页面加载的时候出现 vue 的变量名</p>
<pre><code class="language-css">[v-cloak] {
    display: none;
}
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;app&quot; v-cloak&gt;
    {{msg}}
&lt;/div&gt;
</code></pre>
<p><strong>v-pre</strong><br>
跳过 vue 的编译，直接输出原始值</p>
<pre><code class="language-html">&lt;!-- 输出 {{msg}} --&gt;
&lt;div v-pre&gt;{{msg}}&lt;/div&gt;
</code></pre>
<h2 id="vue-全局-api">Vue 全局 API</h2>
<p><strong>Vue.extend</strong><br>
扩展实例构造器，往往和 $mount 配合使用，创建实例并挂载到元素上</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.extend-扩展实例构造器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 实现了自定义纯标签的效果 --&gt;
    &lt;official&gt;&lt;/official&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // 定义构造器
        var official = Vue.extend({
            template:&quot;&lt;p&gt;&lt;a target='_blank' :href='url'&gt;{{name}}&lt;/a&gt;&lt;/p&gt;&quot;,
            data:function(){
                return{
                    name:'AriesSK的博客',
                    url:'https://ariessk.github.io/'
                }
            }
        });
        // 生成实例并挂载到 official DOM 上
        new official().$mount('official');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.directive</strong><br>
自定义指令，回调函数有三个参数：</p>
<ul>
<li>el 被绑定的 node 节点</li>
<li>binding 一个对象包含指令的信息</li>
<li>vnode Vue 编译生成的虚拟节点</li>
</ul>
<p>自定义指令的生命周期函数（钩子函数）：</p>
<ul>
<li>bind 只调用一次，第一次绑定元素被调用，初始化操作</li>
<li>inserted 被绑定元素插入了父节点</li>
<li>update 被绑定的元素模板更新时调用</li>
<li>componentUpdated 被绑定的元素模板完成一次生命周期</li>
<li>unbind 指令和被绑定元素解绑时调用</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.directive 自定义标签&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p v-color=&quot;setRed&quot;&gt;我要红&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
window.onload = function () {
    Vue.directive('color', function(el, binding, vnode){ // 这里的 color 指的是 v-color 的 color，表示指令名
      console.log('el', el) // &lt;p style=&quot;color: red;&quot;&gt;我要红&lt;/p&gt;
      el.style = &quot;color:&quot; + binding.value // binding.value 表示指令绑定的值，这里指 setRed
    });

    new Vue({
      el: '#app', // 根据属性绑定
      data:{
        setRed: 'red'
      }
    })
  }
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.set</strong><br>
全局操作，Vue 不允许在已创建的实例上动态添加新的根级响应式属性，但可以用 Vue.set 方法将响应式属性添加到嵌套的对象上<br>
下面的例子可以发现，data 的数据是数组或对象时，调用 change 虽然修改了 fruit 的值，但视图并不会更新（失去了getter/setter），而调用 Vue.set(target, key, value) 则会更新视图，说明它能够向响应式对象中添加属性，并确保这个新属性同样是响应式的，且触发视图更新</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.set 全局操作&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p v-for=&quot;item in fruit&quot;&gt;{{ item }}&lt;/p&gt;
    &lt;!-- v-on 的事件处理方法在 Vue 实例内的 methods 声明，也可以在实例外声明函数，前者不用加括号，后者需要 --&gt;
    &lt;button v-on:click=&quot;change&quot;&gt;变&lt;/button&gt;
    {{ fruit }}
  &lt;/div&gt;
  &lt;!-- onclick 事件不能调用 Vue 实例内的 methods --&gt;
  &lt;button onclick=&quot;add()&quot;&gt;外部添加&lt;/button&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  function add(){
    Vue.set(app.fruit, 1, 'melon');
  }
  var app = new Vue({
    el: '#app',
    data: {
      fruit: ['apple', 'banana', 'pear', 'grape']
    },
    methods: {
      change: function () {
        this.fruit[1] = 'melon'
        console.log(this.fruit) // ['apple', 'melon', 'pear', 'grape']
      }
    }
  })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.filter</strong><br>
全局过滤器，注意声明过滤器必须放在<strong>声明实例 app 之前</strong>，否则不被注入实例中<br>
过滤器可用在插值表达式 {{ message | filter}} 和 v-bind 中 v-bind:msg=&quot;message | filter&quot;</p>
<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.filter 过滤器&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p&gt;{{ count | sum }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  Vue.filter(&quot;sum&quot;, function(value) { //声明 sum 过滤器
    return value + 4;
  });

  var app = new Vue({
    el: '#app',
    data: {
      count: 20
    },
  })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.nextTick</strong><br>
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM<br>
应用场景：需要在视图更新之后，基于新的视图进行操作</p>
<h2 id="vue-生命周期函数">Vue 生命周期函数</h2>
<p>对于单页面开发模式，每个页面都可以理解为一个 Vue 组件，在它们的生命周期中，都有对应的钩子函数：</p>
<ul>
<li>beforeCreate 在组件创建之前</li>
<li>created 在组件创建之后，一般用于初始化一些固定数据</li>
<li>beforeMount 在 DOM 节点渲染之前</li>
<li>mounted 在 DOM 节点渲染完后除法，常通过 ajax 获取服务端的数据</li>
<li>beforeUpdate 数据更新时调用，适用于在更新之前访问现有的 DOM</li>
<li>updated DOM 已经更新，执行依赖于 DOM 的操作</li>
<li>activated 被 keep-alive 缓存的组件激活时调用</li>
<li>deactivated 被 keep-alive 缓存的组件停用时调用</li>
<li>beforeDestroy 实例销毁之前调用，这一步实例仍完全可用</li>
<li>destroyed 实例销毁后调用，一般用于销毁页面内创建的 setTimeout 等变量，防止内存泄漏</li>
</ul>
<h2 id="vue-router">Vue-Router</h2>
<p>Vue 官方提供的路由插件</p>
<p><strong>传统页面与单页面跳转的区别</strong></p>
<ul>
<li>传统页面：传统的开发模式，路由一般是由超链接（a 标签）来控制页面的跳转与切换，每次跳转需要刷新整个页面，体验上不如单页模式</li>
<li>单页面：Vue 的单页面是基于组件和路由的配合，所有的页面都可以视为组件，路由控制访问路径，每一个路径映射一个组件。单页模式中无法使用 a 标签进行路由跳转，因为单页模式本质上就只有一个 index.html 页面。所有的页面组件都放在打包好的 js 文件中，所以要使用 Vue-Router 的路由组件实现跳转</li>
</ul>
<p><strong>路由模式</strong><br>
Vue-Router 提供了三种路由模式：</p>
<ul>
<li>Hash 模式</li>
<li>History 模式</li>
<li>abstract 模式</li>
</ul>
<p><strong>Hash 模式</strong><br>
Vue-Router 的默认模式，特点是 URL 始终带着 #，它不会发起对服务端的请求，也不会重加载页面。浏览器的原生方法提供了一个监听事件 hashchange，它能监听到下面的改变：</p>
<ul>
<li>点击 a 标签改变 URL 地址</li>
<li>浏览器的前进后退行为</li>
<li>通过 window.location 方法改变地址栏</li>
</ul>
<p>当初始的 html 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架完成加载。由于 hashchange 不会被默认触发，因此需要在 DOMContentLoaded 被触发时执行一次 hashchange 监听方法要执行的函数 HashChange。之后在点击 a 标签改变 URL 地址时会触发 hashchange 事件，获取到 location.hash，执行的 HashChange 函数通过判断 location.hash 的值来匹配相应的组件，简易的实现如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Hash 模式&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    // 这两个事件名是确定的，函数名可以改
    window.addEventListener('DOMContentLoaded', Load);
    window.addEventListener('hashchange', HashChange);
    var routeView = null;
    function Load() {
        routeView = document.getElementById('route-view');
        HashChange();
    }
    function HashChange() {
        switch(location.hash) {
            case '#/page1':
                routeView.innerHTML = '我是page1';
                return;
            case '#/page2':
                routeView.innerHTML = '我是page2';
                return;
            default:
                routeView.innerHTML = '我是page1';
                return;
        }
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>History 模式</strong><br>
使用 History 模式是使用 html5 的 history API实现路由的模式，表现是去除了 Hash 模式中 URL 的 #，使 URL 比较好看。控制路由会有一些麻烦，根本原因是使用 History 模式，popstate 监听事件无法监听到 pushState、replaceState(前者新建记录，后者修改记录)、a 标签三种形式的变化，可以监听到浏览器的前进和后退。<br>
为了实现路由，可以如下做：</p>
<ol>
<li>遍历页面上的所有 a 标签，阻止其默认事件，同时加上点击事件的回调函数，在回调函数中获取 a 标签的 href 属性值</li>
<li>通过 pushState 改变浏览器的 location.pathname 属性值为 a 标签的 href 属性值</li>
<li>手动执行 popstate 事件的回调函数，匹配相应的路由</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;History 模式&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        window.addEventListener('DOMContentLoaded', Load);
        window.addEventListener('popstate', PopChange);
        var routeView = null;
        function Load() {
            routeView = document.getElementById('route-view');
            PopChange();
            // 获取所有带有 href 属性的 a 标签
            var aList = document.querySelectorAll('a[href]')
            // 遍历标签，添加点击事件的回调函数，参数 e 代表当前事件
            aList.forEach(aNode =&gt; aNode.addEventListener('click', function(e) {
                // 阻止默认事件
                e.preventDefault();
                // 获取 href 属性值
                var href = aNode.getAttribute('href');
                // pushState(state, title. url)，state 对象不需要可填 null，title 表示新页面的标题，url 是新页面的网址
                //这个方法的作用就是在 history 对象中添加记录，同时改变地址栏为新的 url
                history.pushState(null, &quot;&quot;, href);
                // 因为 popstate 监听不到地址栏的变化，所以需要手动执行 PopChange
                PopChange();
            }));
        }
        function PopChange() {
            switch(location.pathname) {
                case '/page1' :
                    routeView.innerHTML = '我是page1';
                    return;
                case '/page2' :
                    routeView.innerHTML = '我是page2';
                    return;
                default :
                    routeView.innerHTML = '我是page1';
                    return;
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>history 模式相对于 hash 模式没有 #，比较符合开发习惯，也比较好看，但由于是 html5 新出的 api，所以不想 hash 模式可以兼容低版本。并且 history 在访问二级页面的时候刷新网页会出现 404 错误，这是因为刷新网页相当于向服务端发送了一次 GET 请求，而服务端并没有定义这样的接口，所以 history 模式需要服务端配合进行路由处理，比如重定向回首页路由</p>
<p><strong>abstract 模式</strong><br>
针对没有浏览器环境的情况，没有浏览器的 API，就会强制切换到 abstract 模式（比如 Weex）<br>
如果在 Vue-Router 的配置项中不填写 mode 的值，则在浏览器环境下默认 Hash 模式，移动客户端环境下使用 abstract 模式</p>
<p><strong>引入与使用</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;!-- 引入静态资源 --&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt;
  &lt;title&gt;Vue Router&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
      &lt;!-- 使用 router-link 组件来导航. --&gt;
      &lt;!-- 通过传入 to 属性指定链接. --&gt;
      &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &lt;a&gt; 标签 --&gt;
      &lt;router-link to=&quot;/page1&quot;&gt;Go to Page1&lt;/router-link&gt;
      &lt;br/&gt;
      &lt;router-link to=&quot;/page2&quot;&gt;Go to Page2&lt;/router-link&gt;
    &lt;/ul&gt;
    &lt;!-- 路由匹配到的组件将渲染在&lt;router-view&gt; --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    // 1. 定义 (路由) 组件
    // 可以从其他文件 import 进来，这里简单写
    const Page1 = { template: '&lt;div&gt;Page1&lt;/div&gt;' }
    const Page2 = { template: '&lt;div&gt;Page2&lt;/div&gt;' }
    // 2. 定义路由
    // 每个路由应该映射一个组件，其中 component 可以是通过 Vue.extend() 创建的组件构造器，或者只是一个组件配置对象
    const routes = [
      { path: '/page1', component: Page1 },
      { path: '/page2', component: Page2 }
    ]
    // 3. 创建 router 实例，然后传 routes 配置
    const router = new VueRouter({
      routes: routes
    })
    // 4. 创建和挂载根实例
    // 要通过 router 配置参数注入路由，从而让整个应用都有路由功能
    const app = new Vue({
      router: router
    }).$mount('#app')
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>获取全局路由跳转参数的变化</strong><br>
同一在入口页面通过 watch $route 对象实现，在上面代码的基础上修改，可以拿到 to 和 from 两个参数，to 代表跳转后的页面参数，from 代表从那个页面跳转来的，通过这两个参数就能够设置一级二级页面，制作过场动画</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
const app = new Vue({
      router: router,
      watch: {
          // $ 前缀是让让系统的属性与用户定义的属性区分开来
        $route(to, from) {
            console.log('to', to);
            console.log('form', from);
        }
      }
    }).$mount('#app')
&lt;/script&gt;
</code></pre>
<p><strong>路由传参</strong><br>
Page1 跳转到 Page2，Page1通过 <router-link> 传参：</p>
<pre><code class="language-html">&lt;!-- 注意 to 前面需要加 : 即使用了 v-bind --&gt;
&lt;router-link :to=&quot;{path: '/page1', query: { id: 123 }}&quot;&gt;Go to Page1&lt;/router-link&gt;
</code></pre>
<p>接收参数：</p>
<pre><code class="language-js">const Page1 = { template: '&lt;div&gt;Page1 {{ $route.query.id }}&lt;/div&gt;'}
</code></pre>
<p>还有另一种方式：</p>
<pre><code class="language-html">&lt;!-- 注意 to 前面需要加 : 即使用了 v-bind --&gt;
&lt;router-link :to=&quot;{path: '/page1/123'}&quot;&gt;Go to Page1&lt;/router-link&gt;
</code></pre>
<pre><code class="language-js">// 这里不是 query 而是 params
const Page1 = { template: '&lt;div&gt;Page1 {{ $route.params.id }}&lt;/div&gt;'}
// 还需要修改 routes
const routes = [
    { path: 'page1/:id', component: Page1 },
    { path: '/page2', component: Page2 }
]
</code></pre>
<p><strong>重定向页面</strong><br>
输入一个不存在的路由，Vue-Router 就会无法匹配到，这时候应当默认返回首页，就需要用到重定向匹配，在 * 上面的路径都没被匹配到时，重定向至 /page1 对应的组件</p>
<pre><code class="language-js">const routes = [
    { path: '/page1', component: Page1 },
    { path: '/page2', component: Page2 },
    {path: '*', redirect: '/page1'}
]
</code></pre>
<h2 id="vuex">Vuex</h2>
<p>Vuex 是一个专门为 Vue 开发的状态管理模式，集中式存储管理应用的所有组件的状态<br>
是用于管理 Vue 应用跨组件数据的工具</p>
<p><strong>Vuex 与 localStorage、sessionStorage</strong><br>
虽然 localStorage 存储时限长，但比较适合存一些不怎么变化的数据，在 Vue 中不同组件共用的数据，组件需要响应另一个组件对数据的修改，就需要 Vuex</p>
<ul>
<li>Vuex：存储在浏览器内存，集中式存储管理应用的所有组件的状态，不刷新页面则状态会一直保持，刷新网页则状态重置</li>
<li>sessionStorage：会话型存储，用于保存同一窗口或标签页的数据，数据保存在浏览器本地，关闭窗口或标签页后删除数据，就像人之间的会话，人走了会话就结束了</li>
<li>localStorage：持久性存储，与 sessionStorage 类似，不过可以一直存储数据在浏览器本地，直到主动清除或重装浏览器</li>
</ul>
<p><strong>单向数据流</strong><br>
根据一定规则改变数据，数据触发视图的更新，通过视图中的方法触发数据的更新的闭环<br>
<img src="https://AriesSK.github.io/post-images/1657809170855.png" alt="" loading="lazy"><br>
但实际应用中往往有多组件共享状态，这样不同视图的行为需要变更同一个状态，这就破坏了单向数据流<br>
这些复杂的应用场景就需要依靠 Vuex 来解决<br>
<img src="https://AriesSK.github.io/post-images/1657809816279.png" alt="" loading="lazy"><br>
虚线框中的部分就是 Vuex 生效的部分，Vue 组件通过 Dispatch 关键字触发 Actions，再通过 Commit 调用 Mutation 里的方法修改 State 数据，组件中如果有依赖 Store 里的数据，就触发 Render 重绘，形成了一个闭环</p>
<p><strong>State</strong><br>
所有状态都被存放在 State 中，类似 Vue 组件中的 data 属性，State 面向整个应用，data 针对单个组件。在 Vue 入口页构造 Vue 实例的时候引入 store，就可以在组件中通过 this.$store.state 拿到</p>
<p><strong>Getter</strong><br>
类似于 Vue 组件中的 computed 属性，计算一些需要二次改造的数据，比如使用 filter 过滤，可以在 store 中定义 getter 属性，state 数据作为参数传入：</p>
<pre><code class="language-js">const store = new Vuex.Store({
    state: {
        todos: [
            { id: 1, text: '...', done: true },
            { id: 2, text: '...', done: false }
        ]
    },
    getters: {
        doneTodos: state =&gt; {
            return state.todos.filter(todo =&gt; todo.done);
        },
        // 还可以接收其他 getters 作为参数
        doneTodesCount: (state, getters) =&gt; {
            return getters.doneTodos.length; // 1
        }
    }
})
</code></pre>
<p>在组件中通过如下访问：</p>
<pre><code class="language-js">this.$store.getters.doneTodos; // [{ id: 1, text: '...', done: true }]
</code></pre>
<p><strong>Mutation</strong><br>
修改 State 状态需要触发一些方法，这些方法放在 mutations 属性中，mutations 属性中的方法能够接收两个参数，第一个是 state，包含所有的状态值；第二个是提交载荷 Payload，在外部通过 store.commit 方法触发 mutations 时额外带入的值：</p>
<pre><code class="language-js">const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment (state) {
            state.count++;
        }
    }
})
store.commit('increment'); // 无载荷触发

const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment (state, n) {
            state.count += n;
        }
    }
})
store.commit('increment', 10); // 带载荷触发
</code></pre>
<p><strong>Action</strong><br>
与 Mutation 类似，不过 Action 是提交 mutation 而不是直接修改 State。Action 有异步的能力，能够在请求异步数据后再触发状态的更新：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state, data) {
      state.count += data.length;
    }
  },
  actions: {
    // 定义一个异步函数，等待 getData 获值后继续执行 commit
    async increment (ctx) {
      const data = await getData();
      ctx.commit('increment', data);
    }
  }
})
store.dispatch('increment'); // 分发 Action
</code></pre>
<p><strong>Module</strong><br>
给状态分模块管理：</p>
<pre><code class="language-js">// 模块 A 的状态及触发更新的方法
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}           
// 模块 B 的状态及触发更新的方法
const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}
// modules 方法可以将 store 分割成模块，每个模块可以定义自己的 state、getter、mutation、action
const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})
store.state.a // moduleA 的状态
store.state.b // moduleB 的状态
</code></pre>
<p><strong>实例</strong><br>
引入静态资源时，Vuex 要在 Vue 的<strong>后面</strong>，否则会报错，这是因为 Vuex 内部依赖 Vue<br>
通过 Vuex.Store 生成实例建议使用<code>strict: true</code>严格模式，减少代码紊乱<br>
使用 Mutation 直接修改状态：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.3/vuex.min.js&quot;&gt;&lt;/script&gt;
  &lt;title&gt;Vuex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;div&gt;{{ $store.state.count }}&lt;/div&gt;
    &lt;button @click=&quot;add&quot;&gt;加1&lt;/button&gt;
    &lt;button @click=&quot;dec&quot;&gt;减1&lt;/button&gt;
  &lt;div&gt;
  &lt;script&gt;
    const store = new Vuex.Store({
      state: {
        count: 0
      },
      // 开启严格模式，开启严格模式后，必须通过 mutation 来修改状态。
      strict: true,
      // 触发 state 中的 count 加减运算的方法
      mutations: {
        add(state) {
          state.count += 1
        },
        dec(state) {
          state.count -= 1
        }
      },
      getters: {
        // 过滤偶数的 getter，没用到
        filterEven: state =&gt; {
          return !(state.count % 2)
        }
      }
    })
    const app = new Vue({
      el: '#app',
      store, // 将 Vuex 生成的实例作为 Vue 生成实例的参数
      data: {
        message: 'Hello Vue!'
      },
      methods: {
        add() {
          this.$store.commit('add')
        },
        dec() {
          this.$store.commit('dec')
        }
      }
    }).$mount('#app');
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用 Action 异步改变状态：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.3/vuex.min.js&quot;&gt;&lt;/script&gt;
  &lt;title&gt;Vuex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;div&gt;{{ $store.state.count }}&lt;/div&gt;
    &lt;button @click=&quot;asyncAdd&quot;&gt;异步加1&lt;/button&gt;
    &lt;button @click=&quot;asyncDec&quot;&gt;异步减1&lt;/button&gt;
  &lt;div&gt;
  &lt;script&gt;
    // 模拟请求数据，延迟 2 秒返回数据
    function AsyncData() {
        // Promise.resolve(x) 用于将字面量或对象封装成 Promise 实例
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve(1)
        }, 2000)
      })
    }

    const store = new Vuex.Store({
      state: {
        count: 0
      },
      // 开启严格模式，开启严格模式后,必须通过 mutation 来修改状态
      strict: true,
      mutations: {
        add(state, num) {
          state.count += num
        },
        dec(state, num) {
          state.count -= num
        }
      },
      actions: {
        // async await 异步获取
        // async 函数返回一个 Promise 对象
        // 参数 ctx 是 context 的缩写，代表着上下文
        async add(ctx) {
            // await 是个运算符，await 表达式的结果取决于后面的内容
            // 如果后面不是 Promise 对象，则表达式结果就是后面的内容
            // 如果后面是 Promise 对象，则阻塞后面的代码，等待 Promise 对象 resolve，得到其值作为表达式的结果
            // AsyncData() 返回一个 Promise 对象，因此 await 会等待
          const num = await AsyncData()
          ctx.commit('add', num)
        },
        async dec(ctx) {
          const num = await AsyncData()
          ctx.commit('dec', num)
        }
      },
      getters: {
        filterOdd: state =&gt; {
          return !(state.count % 2)
        }
      }
    })
    const app = new Vue({
      el: '#app',
      store,
      data: {
        message: 'Hello Vue!'
      },
      methods: {
        asyncAdd() {
            // 注意使用 Action 调用的是 dispatch
          this.$store.dispatch('add')
        },
        asyncDec() {
          this.$store.dispatch('dec')
        }
      }
    }).$mount('#app');
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>不是所有项目都要用 Vuex，对于小型的项目反而会使项目变得繁琐</p>
<h2 id="前端鉴权">前端鉴权</h2>
<p>前端鉴权，处理用户的鉴权信息的两种方式：<br>
<strong>cookie</strong><br>
cookie 用于存储变量，在前端请求网络资源或者后端接口时，请求头 Header 里都会带上当前域下的 cookie 信息，服务端通过检测请求头内的 cookie 判断当前用户的登录状态是否过期（或者 cookie是否错误），来判断当前用户能否成功地返回响应<br>
<strong>token</strong><br>
token 是服务器生成的一串随机字符串或 json 串，作为客户端进行资源请求的令牌。调用登录接口后，服务端返回给前端一个 token，之后将 token 存储到本地环境，每次前端请求接口的时候，都需要在请求头里带上 token 信息，并且 token 还可以在服务端设置过期时间，过期后返回前后端商量好的错误码，跳转到登录节点重新鉴权</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML + CSS]]></title>
        <id>https://AriesSK.github.io/post/html-css/</id>
        <link href="https://AriesSK.github.io/post/html-css/">
        </link>
        <updated>2022-07-29T07:00:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>操作快捷键</strong><br>
Ctrl + Enter 换行，不改变光标后面代码<br>
Alt + Shift + up/down 在上一行/下一行复制该行<br>
选中词后 Ctrl + D，向下一次选择相同的词</p>
<h2 id="网页">网页</h2>
<p><strong>C/S和B/S</strong><br>
C/S：Client/Sever<br>
B/S：Browser/Sever</p>
<p><strong>网页三要素：结构、表现、行为</strong><br>
结构：HTML用于描述页面的结构<br>
表现：CSS用于控制页面中元素的样式<br>
行为：JavaScript用于响应用户操作</p>
<hr>
<h2 id="html">HTML</h2>
<p><strong>超文本标记语言（Hypertext Markup Language, HTML)</strong><br>
超文本指的是使用超链接的方法，将不同空间的文字信息组织在一起的网状文本</p>
<pre><code class="language-html">&lt;!--HTML的注释--&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>标签一般成对出现，单个出现的称为<strong>自结束标签</strong></p>
<p><strong>标签的属性</strong><br>
在开始标签或字节数标签中可以设置标签的属性，属性是一个名值对，属性应当根据文档中的规定编写，有些属性没有属性值</p>
<pre><code class="language-html">&lt;font color=&quot;red&quot;&gt;红色&lt;/font&gt;
</code></pre>
<p><strong>文档声明（DOCTYPE）</strong><br>
html5的文档声明：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
</code></pre>
<p><strong>二进制与十六进制</strong><br>
二进制作为计算机底层的进制使用，而一般显示二进制数使，会转换为十六进制</p>
<p><strong>字符编码</strong><br>
字符集（charset）是编码和解码所从用的规则<br>
若编码和解码使用的字符集不同，则会出现乱码问题<br>
UTF-8 万国码 开发时使用</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>实体</strong><br>
在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格<br>
使用实体（转义字符） <code>&amp;实体的名字;</code><br>
空格<code>&amp;nbsp;</code> 大于<code>&amp;gt;</code> 小于<code>&amp;lt;</code> 版权符<code>&amp;copy;</code></p>
<p><strong>meta标签</strong><br>
charset 指定网页的字符集<br>
name 指定的数据的名称<br>
content 指定的数据的内容</p>
<pre><code class="language-html">&lt;!-- title 标签的内容会作为搜索引擎超链接上的文字显示 --&gt;
&lt;!-- keywords 表示网站的关键字 搜索时的关键词 --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;HTML5,CSS3&quot;&gt;
&lt;!-- description 表示网站的描述 会显示在搜索引擎的搜索结果中 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;这是一个网站&quot;&gt;
&lt;!-- refresh 将网页重定向到另一个网站 --&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://ariessk.github.io&quot;&gt;
</code></pre>
<p>###语义化标签<br>
<strong>HTML负责网页的结构</strong><br>
在使用html标签时，应该关注的是标签的语义，而不是样式</p>
<p><strong>块元素</strong><br>
在页面中独占一行的元素称为块元素（block element） 网页布局主要用块元素 块元素内能放块元素和行内元素 但<code>&lt;p&gt;</code>元素内能放块元素<br>
<code>&lt;h1&gt;</code> h1~h6 h1最重要 仅次于title 一般一个页面只有一个h1 一般只会用h1~h3<br>
相关的标题可以放标题组里</p>
<pre><code class="language-html">&lt;hgroup&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;h2&gt;&lt;/h2&gt;
&lt;/hgroup&gt;
</code></pre>
<p><code>&lt;p&gt;&lt;/p&gt;</code>段落<br>
<code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>表长引用<br>
<code>&lt;br&gt;</code>换行</p>
<p><strong>行内元素</strong><br>
在页面中不会独占一行的元素称为行内元素（inline element） 主要用于包裹元素<br>
<code>&lt;em&gt;&lt;/em&gt;</code>表示语音语调的加重<br>
<code>&lt;strong&gt;&lt;/strong&gt;</code>表强调<br>
<code>&lt;q&gt;&lt;/q&gt;</code>短引用<br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code> 超链接</p>
<p><strong>浏览器修正</strong><br>
浏览器在解析网页时，会对网页中不符合规范的内容进行修正 标签卸载了根元素<code>&lt;html&gt;</code>外面</p>
<p><strong>网页主体</strong></p>
<pre><code class="language-html">&lt;body&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;main&gt;&lt;/main&gt;
    &lt;footer&gt;&lt;/footer&gt;
    &lt;!-- 导航 --&gt;
    &lt;nav&gt;&lt;/nav&gt;
    &lt;!-- 与主体相关的内容（侧边栏） --&gt;
    &lt;aside&gt;&lt;/aside&gt;
    &lt;!-- 文章--&gt;
    &lt;article&gt;&lt;/article&gt;

&lt;/body&gt;
</code></pre>
<p><strong>列表</strong><br>
列表之间可以互相嵌套<br>
无序列表</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>有序列表</p>
<pre><code class="language-html">&lt;ol&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p>定义列表，dt表示定义的内容，dd对内容进行解释说明</p>
<pre><code class="language-html">&lt;dl&gt;
    &lt;dt&gt;&lt;/dt&gt;
    &lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<p><strong>超链接</strong><br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>能够嵌套除它自身的任何元素<br>
目标路径可以是<strong>外部网站</strong>或<strong>内部页面</strong><br>
内部页面通常使用<strong>相对路径</strong>：<code>./</code>表示当前文件所在的目录（可省略），<code>../</code>表示上一级目录</p>
<pre><code class="language-html">&lt;!-- 当前页面打开与新的页面打开 --&gt;
&lt;a href=&quot;&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
</code></pre>
<p><strong>id 属性</strong><br>
通过超链接到页面中的特定位置，要使用 id 属性<br>
id 属性是唯一不重复的，每个标签可以添加一个 id 属性</p>
<pre><code class="language-html">&lt;!-- 回到顶部 --&gt;
&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;
&lt;!-- 回到 id 为bottom的标签处 --&gt;
&lt;a href=&quot;#bottom&quot;&gt;&lt;/a&gt;
&lt;!--未设置是可以用 javascript:; 占位 点击无反应 --&gt;
&lt;a href=&quot;javascript:;&quot;&gt;1&lt;/a&gt;
</code></pre>
<p><strong>图片标签</strong><br>
用于引入外部图片<br>
<code>&lt;img width=&quot;&quot; height=&quot;&quot; src=&quot;&quot; alt=&quot;&quot;&gt;</code> 自结束标签 替换元素<br>
alt 是图片的描述，有些浏览器会在图片无法加载时显示，搜索引擎会根据 alt 中的内容来识别图片<br>
width height 只修改其中一个会等比例缩小<br>
一般在 pc 端不建议修改图片的大小，而在移动端经常需要缩放图片（主要是大图缩小确保清晰度）<br>
<strong>图片格式</strong><br>
jpeg(jpg) 支持颜色比较丰富，不支持透明效果，不支持动图，一般显示照片<br>
gif 支持颜色比较少，支持简单透明，支持动图，一般显示动图<br>
png 支持颜色丰富，支持复杂透明，不支持动图，专为网页而生<br>
webp 谷歌推出的专门用来表示网页中的图片的一种格式，具备其他图片的所有优点，并且文件特别小，但<strong>兼容性不好</strong><br>
base64 将图片使用base64编码，将土拍你转换为字符，通过字符的形式来引入图片，一般用于需要和网页一起加载的图片</p>
<p><strong>内联框架</strong><br>
用于向当前页面中引入一个其他页面<br>
<code>&lt;iframe src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code><br>
frameborder 指定内联框架的边框，0无1有</p>
<p><strong>音视频</strong><br>
<code>&lt;audio src=&quot;&quot; controls autoplay loop&gt;&lt;/audio&gt;</code>controls 是否允许用户控制播放，autoplay 自动播放，但大部分浏览器不会自动播放，loop循环播放，都是无值的属性<br>
下面这种写法能够解决<strong>浏览器不兼容</strong>的问题，不支持<code>&lt;audio&gt;</code>则显示文字，第一个音频无法播放则播放第二个<code>&lt;emobed&gt;</code>支持比较低的浏览器版本，需要设置文件类型以及宽和高，且比较丑。</p>
<pre><code class="language-html">&lt;audio controls&gt;
        &lt;!-- 文字和 embed 二选一即可 --&gt;
        对不起，您的浏览器不支持播放音频，请升级浏览器！
        &lt;source src=&quot;audio.mp3&quot;&gt;
        &lt;source src=&quot;audio.ogg&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;audio/mp3&quot; width=&quot;&quot; height=&quot;&quot;&gt;
    &lt;/audio&gt;
</code></pre>
<p>video 与 audio 使用方法基本相同</p>
<pre><code class="language-html">&lt;video controls&gt;
        &lt;source src=&quot;video.webm&quot;&gt;
        &lt;source src=&quot;video.mp4&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;video/mp4&quot; width=&quot;&quot; height=&quot;&quot;&gt;
&lt;/video&gt;
</code></pre>
<h2 id="css">CSS</h2>
<p>层叠样式表<br>
网页实际上是一个多层的结构，通过css可以分别为网页的每一层来设置样式，而最终我们能看到的是最上边的一层</p>
<p><strong>使用 css 修改元素样式</strong><br>
法一：内联样式、行内样式<br>
在标签内部通过 style 属性来设置元素的样式，只能对一个标签生效，修改很麻烦（不推荐使用）<br>
<code>&lt;p style=&quot;color: red; font-size: 60px;&quot;&gt;</code><br>
法二：内部样式表<br>
将样式编写到 head 中的 style 标签里，同时设置多个标签，方便修改和复用，但只能对一个网页使用</p>
<pre><code class="language-html">&lt;style&gt;
    p{
        color: red;
        font-size: 60px
    }
&lt;/style&gt;
</code></pre>
<p>法三：外部样式表<br>
将样式编写到外部的 css 文件中，然后在页面中通过 link 标签引入外部的 css 文件，方便多网页复用（最佳），多个网页引用同一个 css 时能够使用到浏览器的缓存机制，加块网站加载速度，提高用户体验</p>
<pre><code class="language-css">p{
    color: red;
    font-size: 60px;
}
</code></pre>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>css 语法</strong><br>
选择器，选择页面中的指定元素<br>
声明块，为指定元素设置样式，声明是名值对结构，名和值以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 连接，以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mpunct">;</span></span></span></span> 结尾</p>
<h3 id="选择器">选择器</h3>
<p>常用选择器：</p>
<ul>
<li>元素选择器，根据标签名选定元素，<code>标签名{}</code></li>
<li>id 选择器，根据元素 id 选中元素，<code>#id属性值{}</code></li>
<li>类选择器，根据元素 class 选中元素，<code>.class值{}</code>，class 和 id 类似，但 class 可重复使用，可以为一个元素指定多个 class，多个 class 之间使用<strong>空格</strong>分隔</li>
<li>通配选择器，选中页面中的所有元素，<code>*{}</code></li>
</ul>
<p>复合选择器：</p>
<ul>
<li>交集选择器，选中同时复合多个条件的元素，<code>选择器1选择2选择器3{}</code>，有元素选择器则必须以<strong>元素选择器开头</strong></li>
<li>选择器分组（并集选择器），同时选择多个选择器对于的元素，<code>选择器1,选择2,选择器3{}</code></li>
</ul>
<p>关系选择器：<br>
父元素：直接包含子元素的元素<br>
祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素<br>
兄弟元素：拥有相同父元素的元素</p>
<ul>
<li>子元素选择器，选中父元素的指定子元素，<code>父元素 &gt; 子元素{}</code></li>
<li>后代元素选择器，选中祖先元素内的指定后代元素，<code>祖先元素 后代元素{}</code></li>
<li>兄弟选择器，选择下一个兄弟，<code>前一个 + 后一个{}</code>，需要<strong>直接相邻</strong>；选择下边所有兄弟，<code>兄 ~ 弟{}</code></li>
</ul>
<p>属性选择器：</p>
<ul>
<li>选择含有指定属性的元素，<code>[属性名]{}</code>，<code>*[属性名]{}</code>表示所有拥有该属性的标签(* 可省略)，<code>标签名[属性名]{}</code>表示拥有该属性的指定标签，比如<code>a[href]{}</code></li>
<li>选择含有指定属性和属性值的元素，<code>[属性名=属性值]{}</code></li>
<li>选择属性值以指定值开头的元素，<code>[属性名^=属性值]{}</code></li>
<li>选择属性值以指定值结尾的元素，<code>[属性名$=属性值]{}</code></li>
<li>选择属性值中含有指定值的元素，<code>[属性名*=属性值]{}</code></li>
</ul>
<p>伪类选择器：<br>
伪类，特殊的类，用来描述一个元素的特殊状态，比如：第一个元素、被点击的元素、鼠标移入的元素<br>
伪类一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>:first-child</code>，第一个子元素</li>
<li><code>:last-child</code>，最后一个子元素</li>
<li><code>:nth-child()</code>，第 n 个子元素，括号内可填值表示第几个，其中有特殊值：n 表示选中所有（0~正无穷）；2n 或 even 表示选中偶数位的元素；2n+1 或 odd 表示奇数位的元素</li>
</ul>
<p>上述的伪类均根据<strong>所有的子元素</strong>进行排序</p>
<ul>
<li><code>:first-of-type</code></li>
<li><code>:last-of-type</code></li>
<li><code>:nth-of-type()</code></li>
</ul>
<p>上述这三个与前面的功能类似，但是是在<strong>相同元素</strong>中进行排序</p>
<ul>
<li><code>:not()</code>，否定选择器，将复合条件的元素从选择器中去除，比如``ul &gt; li:not(:nth-of-type(1)){}`是排除第一个</li>
</ul>
<p>超链接的伪类：<br>
其执行顺序是 <strong>LoVeHAte</strong>，原因如下：</p>
<ul>
<li>未访问的链接（正常的链接），<code>a:link</code>，专属于超链接标签，无操作便具有<code>:link</code>状态</li>
<li>访问过的链接，<code>a:visited</code>，由于隐私的原因，这个伪类只能修改颜色，专属于超链接标签，访问后具备<code>:link</code>和<code>:visited</code>两种状态</li>
<li>鼠标移入的状态，<code>:hover</code>，鼠标移入访问过的链接，同时具备<code>:link</code>、<code>:visited</code>和<code>:hover</code>三种状态</li>
<li>鼠标点击的状态，<code>:active</code>，点击已访问链接未松开，同时具备<code>:link</code>、<code>:visited</code>、<code>:hover</code>和<code>:active</code>四种状态</li>
</ul>
<p>伪元素选择器：<br>
伪元素，表示页面中一些特殊的不真实存在的元素（特殊的位置），一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>::first-letter</code>，第一个字母</li>
<li><code>::first-line</code>，第一行</li>
<li><code>::selection</code>，选中的内容</li>
<li><code>::before</code>，表示元素的开始，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
<li><code>::after</code>，表示元素的结束，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
</ul>
<pre><code class="language-css">/* before 和 after 需要结合 content 属性使用才能看出效果 */
/* 下面的例子是在元素的开头插入红色字符串 'abc' */
div::before{
    content: 'abc';
    color: red;
}
</code></pre>
<p><strong>选择器的权重</strong><br>
样式的冲突，通过不同的选择器选中了相同的元素，并且为相同的样式设置了不同的值时，就发生了冲突<br>
此时应用哪个样式有选择器的权重（优先级）决定，选择器越具体优先级越高<br>
选择器的权重（数字仅是为了说明数量级）：</p>
<ul>
<li>内联样式 1,0,0,0</li>
<li>id 选择器 0,1,0,0</li>
<li>类和伪类选择器 0,0,1,0</li>
<li>元素选择器 0,0,0,1</li>
<li>通配选择器 0,0,0,0</li>
<li>继承的样式 没有优先级，即优先级低于通配</li>
</ul>
<p>比较优先级是，需要将所有选择器的优先级相加后再比较优先级（除了<strong>分组选择器</strong>是单独计算的），而选择器的累加不会超过其最大的<strong>数量级</strong>，类选择器再多也不会超过 id 选择器<br>
相同优先级，后面的会覆盖前面的<br>
可以在某一个样式后边添加<code>!important</code>则会获取到最高的优先级（超过内联样式），需要<strong>慎用</strong></p>
<pre><code class="language-css">.class{
    background-color: red !important;
}
</code></pre>
<p><strong>样式的继承</strong><br>
继承发生在<strong>祖先与后代</strong>之间，为一个元素设置样式同时也会应用到它的<strong>后代元素</strong><br>
继承的设计是为了方便开发，利用继承可以将一些通用的样式设置到共同的祖先元素上，这样只需设置一次<br>
并不是<strong>所有</strong>的样式都会被继承，比如背景相关的，布局相关的样式等</p>
<p><strong>长度单位</strong><br>
像素（px）：不同屏幕的像素大小是不同的<br>
百分比：能够将属性值设置为相对于其父元素属性的百分比，能够使子元素跟随父元素的改变而改变<br>
em：相对于元素的字体大小来计算的，1em = 1font-size，会随着字体的大小改变<br>
rem：相对于根元素的字体大小来计算</p>
<p><strong>颜色单位</strong><br>
颜色名：在 css 中可以直接使用颜色名来设置颜色，但不常用<br>
RGB：通过三种颜色的不同浓度来调配出不同的颜色，每一种范围在 0 - 255(0% - 100%) 之间，是光的三原色，均为 0 则黑，均为 255 则黑</p>
<pre><code class="language-css">.box{
    background-color: rgb(0, 0, 0);
    background-color: rgb(255, 255, 255);
}
</code></pre>
<p>RGBA：在 RGB 的基础上多了一个透明度 A，1 表示不透明，0 表示全透明，.5 半透明<br>
十六进制的 RGB 值：语法 #RGB，每种颜色用两位十六进制数表示，00 - ff<br>
HSL：H 色相(0 - 360)，S 饱和度(0% - 100%)，L 亮度(0% - 100%)<br>
HSLA：多一个透明度</p>
<h3 id="布局">布局</h3>
<p><strong>文档流</strong><br>
网页是多层结构，最底下的一层称为文档流，是网页的基础，创建的元素默认都在文档流中进行排列<br>
元素主要有两个状态：<strong>在文档流中</strong>和<strong>不在文档流中（脱离文档流）</strong><br>
元素在文档流中的特点：</p>
<ul>
<li>块元素：在页面中独占一行（自上向下垂直排列）；默认宽度是父元素的全部（把父元素撑满）；默认高度是被内容（子元素）撑开</li>
<li>行内元素：不会独占页面的一行，只占自身的大小；在页面中从左向右排列，如果在一行中不能容纳，则换到第二行；默认宽度和高度都被内容撑开</li>
</ul>
<p><strong>盒模型</strong><br>
css 将页面中的所有元素都设置为了一个矩形的盒子，盒子的可见框大小由内容区、内边距和边框共同决定<br>
每一个盒子都由以下击鼓部分组成：</p>
<ul>
<li>内容区(content)： 元素中的所有子元素和文本内容都在内容区中排列，内容区的大小由 width 和 height 两个属性来设置</li>
<li>内边距(padding)，内容区和边框之间的距离，可以用 padding 简写，也可以用 padding-xxx (xxx 可以是 top right bottom left)，内边距的大小会影响到盒子的大小，背景颜色会延伸到内边距上</li>
<li>边框(border)：属于盒子的边缘，需要设置三个样式
<ol>
<li>边框的宽度(border-width)，可以用来指定四个方向边框的宽度，四个值（上 右 下 左、顺时针），三个值（上 左右 下），两个值（上下 左右），一个值（上下左右）；或者使用 boder-xxx-width 单独指定某一个边框，默认 3px，边框的大小会直接影响盒子的大小</li>
<li>边框的颜色(border-color)，同样可分别以指定四个边的颜色，规则同上，默认黑</li>
<li>边框的样式(border-style)，实线(solid)，点状虚线(dotted)，虚线(dashed)，双线(double)，默认 none 表示没有边框<br>
boder 还有简写属性，同时设置边框的所有相关样式，并且<strong>没有</strong>顺序要求<code>border: 10px red solid</code>，也可以使用<code>border-xxx</code>分别设置四个边</li>
</ol>
</li>
<li>外边距(margin)，不影响可见框大小，但影响盒子的位置，有四个方向的外边距，可以用 margin 简写，也可以用 margin-xxx 设置（默认情况下设置 margin-right 不会产生效果，一般由浏览器调整），由于元素默认自左向右排列，因此设置左、上外边距会移动元素自身，而设置右、下外边距会移动其他元素。margin 设置负值则反向移动。margin 会影响盒子实际占用空间</li>
</ul>
<p><strong>盒模型的水平布局</strong><br>
元素在其父元素中水平方向的位置由以下几个属性共同决定：margin-left，border-left，padding-left，width，padding-right，border-right，margin-right<br>
它们的总和<strong>必须等于</strong>父元素内容区的宽度<br>
如果等式不成立，称为过度约束，等式自动调整：</p>
<ul>
<li>若七个值没有 auto 的情况，则自动调整 margin-right 使等式成立；</li>
<li>而 width，margin-left，margin-right能够设置 auto，设置后会自动调整该属性，其中 width 的默认值就是 auto；</li>
<li>宽度和一个外边距设置为 auto，宽度会调整到最大值，外边距为 0</li>
<li>三个都设置为 auto，则外边距都是 0，宽度最大</li>
<li>外边距为 auto，宽度固定，则将外边距设计为相同值（常用于在父元素中水平居中）</li>
</ul>
<p><strong>盒模型的垂直布局</strong><br>
子元素在父元素的内容区中排列，若子元素的大小超过了父元素，则子元素会从父元素中溢出<br>
使用 overflow 属性来设置父元素如何处理溢出的子元素（在父元素中设置），可选值：</p>
<ul>
<li>visible，默认值，使子元素溢出，在父元素外显示</li>
<li>hidden，溢出内容将被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整的内容</li>
<li>auto，根据需要生成滚动条<br>
overflow-x 和 overflow-y 可以分别设置横向和纵向的溢出</li>
</ul>
<p><strong>垂直外边距的重叠(折叠)</strong><br>
相邻的垂直方向的外边距会发生重叠现象：</p>
<ul>
<li>兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大的（都是正或负值），如果一正一副取两者和，对开发有利，不需要处理</li>
<li>父子元素间的相邻垂直外边距，子元素的会传递给父元素（上外边距），会影响到页面的布局，需要进行处理</li>
</ul>
<p><strong>行内元素的盒模型</strong><br>
行内元素不支持设置宽度和高度<br>
行内元素可以设置 padding，但不会影响页面的布局<br>
行内元素可以设置 border，垂直方向的 border 不会影响页面的布局<br>
行内元素可以设置 margin，垂直方向的 margin 不会影响页面的布局</p>
<p>display 用来设置元素的显示类型，可选值：</p>
<ul>
<li>inline 将元素设置为行元素</li>
<li>block 将元素设置为块元素</li>
<li>inline-block 将元素设置为行内块元素，可以设置宽高又不会独占一行</li>
<li>table 将元素设置为一个表格</li>
<li>none 元素不在页面中显示</li>
</ul>
<p>visibility 用来设置元素的显示状态，可选值：</p>
<ul>
<li>visible 默认值，元素在页面中正常显示</li>
<li>hidden 元素在也页面中隐藏不显示，但依然占据页面的位置</li>
</ul>
<p><strong>默认样式</strong><br>
通常情况浏览器都会为元素设置一些默认样式，会影响到页面的布局，因此需要去除浏览器的默认样式（PC端），可以使用别人的<strong>重置样式表</strong>，引入 css 文件</p>
]]></content>
    </entry>
</feed>