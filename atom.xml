<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-06-21T14:38:02.822Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[58 - I. 翻转字符单词顺序]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_58_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_58_i/">
        </link>
        <updated>2022-06-21T12:29:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的正则表达式">JavaScript 的正则表达式</h3>
<p>语法：<br>
<code>/正则表达式主体/修饰符(可选)</code><br>
修饰符不区分大小写：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td>g</td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配</td>
</tr>
</tbody>
</table>
<p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>查找方括号之间的任何字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找任何以 | 分隔的选项</td>
</tr>
</tbody>
</table>
<p>元字符是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>查找数字</td>
</tr>
<tr>
<td>\s</td>
<td>查找空白字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>查找以十六进制数 xxxx 规定的 Unicode 字符</td>
</tr>
</tbody>
</table>
<p>量词:</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>n+</td>
<td>匹配任何包含至少一个 n 的字符串</td>
</tr>
<tr>
<td>n*</td>
<td>匹配任何包含零个或多个 n 的字符串</td>
</tr>
<tr>
<td>n?</td>
<td>匹配任何包含零个或一个 n 的字符串</td>
</tr>
</tbody>
</table>
<h3 id="javascript-的字符串函数">JavaScript 的字符串函数</h3>
<p>本题中使用的一些字符串函数及它们的时间复杂度：</p>
<pre><code class="language-js">trim() // 去除字符串头尾的空格 O(n)
split() // 拆分成数组 O(n)
reverse() // 反转数组 O(n)
join() // 使用特定分隔符将数组连接成字符串 O(n)
</code></pre>
<p>其中需要重点说明<code>split()</code>举例如下：</p>
<pre><code class="language-js">let s = &quot;a  b c&quot;
s.split() // [&quot;a  b c&quot;] // 直接返回数组
s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开
s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素
s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一字符串函数">法一：字符串函数</h3>
<p>首先想到使用<code>tirm()</code>删除头尾空格，<code>split(&quot; &quot;)</code>拆分成数组，从数组末尾开始拼接：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    const arr = s.trim().split(&quot; &quot;);
    let res = &quot;&quot;;
    for (let i = arr.length - 1; i &gt;= 0; --i) {
        if (arr[i] === &quot;&quot;) continue;
        res += i ? arr[i] + &quot; &quot; : arr[i];
    }
    return res;
};
</code></pre>
<p>事实上使用字符串函数代码可以更加简洁：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
};
</code></pre>
<h3 id="法二双指针">法二：双指针</h3>
<pre><code class="language-js">var reverseWords = function(s) {
    s = s.trim();
    let left = s.length - 1, right = left;
    let res = &quot;&quot;;
    // 保证 left 能够取到 0
    while (left &gt;= 0) {
        // 找到第一个空格
        while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left;
        res += s.substring(left + 1, right + 1) + &quot; &quot;;
        // 忽略空格找到第一个字符
        while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left;
        right = left;
    }
    // 删去最后末尾多余的一个空格
    return res.trim();
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[57. 和为s的两个数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_57/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_57/">
        </link>
        <updated>2022-06-21T11:46:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的const">JavaScript 的<code>const</code></h3>
<p>在允许的情况下，推荐使用<code>const</code>进行声明，<code>const</code>声明后无法重新赋值，但可以修改其属性值。</p>
<hr>
<h2 id="题解">题解</h2>
<p>双指针的简单应用：</p>
<pre><code class="language-js">var twoSum = function(nums, target) {
    let left = 0, right = nums.length - 1;
    const res = [];
    // 若允许同一个数自己加自己则取 =
    while (left &lt; right) {
        // 在值是正数的情况下，改加为减能够有效防止值溢出
        if (nums[left] &gt; target - nums[right]) --right;
        else if (nums[left] &lt; target - nums[right]) ++left;
        else {
            res.push(nums[left]);
            res.push(nums[right]);
            // 不适用 break 会导致无限循环入栈至溢出
            break;
        }
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[21. 调整数组顺序使奇数位于偶数前面]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_21/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_21/">
        </link>
        <updated>2022-06-21T10:56:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的运算符优先级">JavaScript 中的运算符优先级</h3>
<p><img src="https://AriesSK.github.io/post-images/1655809695939.png" alt="" loading="lazy"><br>
在写代码时需要注意运算符的优先级，如下由于<code>!</code>的运算优先级高于<code>%</code>，因此加不加<code>()</code>是两种结果：</p>
<pre><code class="language-js">let num = 2;
console.log(!num % 2); // 0
console.log(!(num % 2)); // true
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<p>简单的双指针运用：</p>
<pre><code class="language-js">var exchange = function(nums) {
    let left = 0, right = nums.length - 1;
    // while 中是否取等号均可
    while (left &lt; right) {
        if (nums[left] % 2) ++left;
        else if (!(nums[right] % 2)) --right;
        else {
            let temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
        } 
    }
    return nums;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 - I. 斐波那契数列]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_10_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_10_i/">
        </link>
        <updated>2022-06-16T14:47:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="动态规划总结">动态规划总结</h3>
<p><em>Those who cannot remember the past are condemned to repeat it.</em><br>
<em>那些不记得过去的人注定要重蹈覆辙。</em></p>
<p>动态规划(Dynamic Programming, DP)通过记住求过的解来节省时间，对每一个子问题只求解一次，并将结果存下来。</p>
<ul>
<li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响</li>
<li>最优子结构性质：大的问题的最优解可以由小问题的最优解推出</li>
</ul>
<p>判断能否使用 DP 解决：是否能够将大问题拆成几个小问题，且满足无后效性、最优子结构性质。<br>
步骤：</p>
<ol>
<li>状态定义：定义一个状态，这是一个最优解的结构特征；</li>
<li>转移方程：进行状态递推，得到递推公式；</li>
<li>初始状态：进行初始化；</li>
<li>返回结果。</li>
</ol>
<p>其中最重要的是<strong>状态转移方程</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一递归">法一：递归</h3>
<p>我第一时间想到的思路，且代码简单，但递归过程中重复的计算过多，导致超出了时间限制，无法通过：</p>
<pre><code class="language-js">var fib = function(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    return (fib(n - 1) + fib(n - 2)) % (1e9+7);
};
</code></pre>
<h3 id="法二递归-哈希表">法二：递归 + 哈希表</h3>
<p>法一的优化，将每次计算后的结果存在哈希表中，即可避免重复计算，但需要额外<code>O(n)</code>的空间：</p>
<pre><code class="language-js">var fib = function(n, hash = new Map()) {
    if (n &lt;= 1) return n;
    if (hash.has(n)) return hash.get(n);
    // 注意给 1e9+7 加括号 否则会出错
    else hash.set(n, (fib(n - 1, hash) + fib(n - 2, hash)) % (1e9+7));
    return hash.get(n);
};
</code></pre>
<h3 id="法三动态规划">法三：动态规划</h3>
<p>状态转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n) = F(n - 1) + F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><br>
由于只涉及到三个值，因此可以用滚动数组法使得空间复杂度为<code>O(1)</code>：</p>
<ol>
<li>状态定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个斐波那契数；</li>
<li>转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n) = F(n - 1) + F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>；</li>
<li>初始状态：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(0) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(1) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(2) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li>
<li>返回结果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<p><img src="https://AriesSK.github.io/post-images/1655808465832.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655808471264.png" alt="" loading="lazy"></p>
<pre><code class="language-js">var fib = function(n) {
    const MOD = 1e9+7;
    if (n &lt; 2) return n;
    let p = 0, q = 0, r = 1;
    for (let i = 2; i &lt;= n; ++i) {
        p = q; 
        q = r; 
        r = (p + q) % MOD;
    }
    return r;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 - II. 青蛙跳台阶问题]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_10_ii/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_10_ii/">
        </link>
        <updated>2022-06-16T13:50:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>类似斐波那契数列的问题，使用动态规划解决，需要注意初始状态的区别。</p>
<hr>
<h2 id="题解">题解</h2>
<p>动态规划：<br>
跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 种跳法，在所有跳法中，最后一步只有两种情况：</p>
<ul>
<li>跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 级，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 种；</li>
<li>跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 级，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 种。</li>
</ul>
<p>所以步骤如下：</p>
<ol>
<li>状态定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 表示跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶的跳法总数；</li>
<li>转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n) = F(n - 1) + F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>；</li>
<li>初始状态：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(0) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(1) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F(2) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>；</li>
<li>返回结果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<pre><code class="language-js">var numWays = function(n) {
    if (n &lt; 2) return 1;
    let p = 0, q = 1, r = 1;
    for (let i = 2; i &lt;= n; ++i) {
        p = q;
        q = r;
        r = (p + q) % (1e9+7);
    }
    return r;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[11. 旋转数组的最小数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_11/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_11/">
        </link>
        <updated>2022-06-13T14:00:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>这一题的二分法很特别，因为在<code>numbers[m] = numbers[r]</code>的情况下，无法判断旋转点在哪个半区，因此无法通过常规方法缩小区间，而需要使用<code>--r</code>来缩小区间，而<code>--r</code>的终止条件应当是<code>l === r</code>时，因此本题需要使用模板二，二分法具体模板见<a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>找到第一个变小的数字：</p>
<pre><code class="language-js">var minArray = function(numbers) {
    for (let i = 1; i &lt; numbers.length; ++i) {
        if (numbers[i] &lt; numbers[i - 1]) return numbers[i];
    }
    // 旋转0个数的情况
    return numbers[0];
};
</code></pre>
<h3 id="法二二分法">法二：二分法</h3>
<p>要保证每次缩小区间后最小值仍在区间内。<br>
二分会有三种情况：</p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] &gt; nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 一定在左排序数组中，即旋转点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一定在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[m + 1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 闭区间内，因此执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] &lt; nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 一定在右排序数组中，即旋转点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一定在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 闭区间内，因此执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">r = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>；</li>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] = nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时： 无法判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 在哪个排序数组中，即无法判断旋转点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 还是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[m + 1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间中，但由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] = nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 一定在区间内，因此即使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">num[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 是最小值，也可以执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = r - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 缩小范围。</li>
</ul>
<p>为什么本题二分法不用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 作比较？ 避免了旋转 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 个数出现的问题。<br>
二分目的是判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 在哪个排序数组中，从而缩小区间。而在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] &gt; nums[l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 情况下，无法判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 在哪个排序数组中。本质上是由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 初始值肯定在右排序数组中；但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 初始值无法确定在哪个排序数组中。</p>
<pre><code class="language-js">var minArray = function(numbers) {
    let l = 0, r = numbers.length;
    while (l &lt; r) {
        const m = l + Math.floor((r - l) / 2);
        if (numbers[m] &gt; numbers[r]) l = m + 1;
        else if (numbers[m] &lt; numbers[r]) r = m;
        else --r;
    }
    return numbers[l];
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[04. 二维数组中的查找]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_04/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_04/">
        </link>
        <updated>2022-06-13T13:31:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>注意题目中提示了输入可能是空数组，这种情况需要特别考虑：</p>
<pre><code class="language-js">var findNumberIn2DArray = function(matrix, target) {
    // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑
    if (!matrix.length) return false;
    let n = matrix.length, m = matrix[0].length;
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; m; ++j) {
            if (matrix[i][j] === target) return true;
        }
    }
    return false;
};
</code></pre>
<h3 id="法二标志数">法二：标志数</h3>
<p>将矩阵逆时针旋转 45°，能够发现其结构类似<strong>二叉搜索树</strong>，左分支更小，右分支更大；<br>
因此从根节点，也就是右上角开始搜索，比<code>target</code>大就向左，否则向右；<br>
矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。<br>
<img src="https://AriesSK.github.io/post-images/1655732925766.png" alt="" loading="lazy"></p>
<pre><code class="language-js">// 右上角开始
var findNumberIn2DArray = function(matrix, target) {
    if (!matrix.length) return false;
    let i = 0, j = matrix[0].length - 1;
    while (i &lt; matrix.length &amp;&amp; j &gt;= 0) {
        if (matrix[i][j] === target) return true;
        else if (matrix[i][j] &lt; target) ++i;
        else --j;
    }    
    return false;
};

// 左下角开始
var findNumberIn2DArray = function(matrix, target) {
    let i = matrix.length - 1, j = 0;
    // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错
    while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) {
        if (matrix[i][j] === target) return true;
        else if (matrix[i][j] &gt; target) --i;
        else ++j;
    }    
    return false;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[53 - I. 在排序数组中查找数字 I]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_53_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_53_i/">
        </link>
        <updated>2022-06-12T14:17:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二分法总结">二分法总结</h3>
<p>有序的序列查找，优先考虑二分法。</p>
<h4 id="无重复元素">无重复元素</h4>
<p>查找<code>target</code>在序列中是否出现：</p>
<pre><code class="language-js">const binarySearch(nums, target) {
    let left = 0, right = nums.length;
    while (left &lt;= right) {
        // 能够防止溢出
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) return mid;
        else if (nums[mid] &lt; target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
};
</code></pre>
<h4 id="有重复元素">有重复元素</h4>
<ul>
<li>查找首个大于<code>target</code>的元素序号；</li>
<li>查找首个大于等于<code>target</code>的元素序号（等同于查找首个大于<code>target - 1</code>的元素序号）。</li>
</ul>
<pre><code class="language-js">const binarySearch(nums, target) {
    let left = 0, right = num.length;
    while (left &lt;= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] &lt;= target) left = mid + 1;
        else right = mid - 1;
    }
    return i;
}
</code></pre>
<h4 id="循环条件写left-right和left-right的区别">循环条件写<code>left &lt;= right</code>和<code>left &lt; right</code>的区别</h4>
<p>区别在于是否包含最右边的边界值，因为当<code>left==right</code>时，不会再进入循环体，所以<code>right</code>初始化时就取值为<code>len(nums)</code>，这样在<code>for</code>循环中就能保证是在这样一个左闭右开的区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">[left,right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>，且<code>right</code>赋值应该为<code>right = mid</code>而非<code>right = mid-1</code>，因为右半边是开区间，取<code>mid-1</code>就无法验证到<code>mid-1</code>是否是目标值。简单来说区别是<code>right</code>所代表的位置是否参与计算。</p>
<h4 id="两种写法模板">两种写法模板</h4>
<pre><code class="language-js">// 模板一
// 若 target === nums[nums.length - 1]
// 在循环条件是 left &lt;= right 的情况下 right = nums.length - 1 以保证 mid 能够取到
const binarySearch = function(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left &lt;= right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) return mid;
        else if (nums[mid] &lt; target) left = mid + 1;
        else right = mid - 1; 
    }
    return left;
}
// 模板二
// 若 target === nums[nums.length - 1]
// 在循环条件是 left &lt; right 的情况下 right = nums.length 因为 mid 最多取到 right - 1
const binarySearch = function(nums, target) {
    let left = 0, right = nums.length;
    while (left &lt; right) {
        const mid = left + Math.floor((right - left) / 2);
        if (nums[mid] === target) return mid;
        else if (nums[mid] &lt; target) left = mid + 1;
        else right = mid; 
    }
    return left;
}
</code></pre>
<h3 id="javascript-中的数组越界">JavaScript 中的数组越界</h3>
<p>js 数组<strong>允许</strong>越界，越界返回的是<code>undefined</code>。<br>
js 在非严格模式的情况下变量允许不声明直接赋值。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>逐个遍历：</p>
<pre><code class="language-js">var search = function(nums, target) {
    let start = -1, end = -1;
    for (let i = 0; i &lt; nums.length; ++i) {
        if (nums[i] === target) {
            start = i;
            break;
        }
    }
    if (start === -1) return 0;
    // 这里只有在 js 中才行 因为允许数组越界 正常 i = nums.length 时 若nums[i] === target 则 end = nums.length
    for (let i = start;; ++i) {
        if (nums[i] !== target) {
            end = i;
            break;
        }
    }
    return end - start;
};
</code></pre>
<h3 id="法二二分法">法二：二分法</h3>
<p>这里的<code>binarySearch()</code>方法目的实际上是寻找<code>tar</code>值能够插入的最右的位置，因此答案为<code>target</code>的右边界减去<code>(target - 1)</code>的右边界。</p>
<pre><code class="language-js">var search = function(nums, target) {
    return binarySearch(nums, target) - binarySearch(nums, target - 1);
}

const binarySearch = function(nums, tar) {
    let i = 0, j = nums.length - 1;
    // 用 &lt;= 保证 tar 能够插入最右的位置 而不是 最右的前一位
    while (i &lt;= j) {
        // 不像 java 在 js 中需要手动取整
        const m = Math.floor((i + j) / 2);
        // 由于找最右插入位置 因此即使nums[m] = tar 插入位置也在 m + 1 及之后
        if (nums[m] &lt;= tar) i = m + 1;
        else j = m - 1; 
    }
    // i 永远比 j 大1 只能返回 i
    return i;
};
// while 中 &lt;= 换为 &lt; 后 改变 j 的初始值 和 j 每次的缩小值
const binarySearch = function(nums, target) {
    let i = 0, j = nums.length;
    while (i &lt; j) {
        const m = i + Math.floor((j - i) / 2);
        if (nums[m] &lt;= target) i = m + 1;
        else j = m; 
    }
    return i;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[03. 数组中重复的数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_03/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_03/">
        </link>
        <updated>2022-06-12T12:59:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的map对象与set对象">JavaScript 中的<code>Map</code>对象与<code>Set</code>对象</h3>
<p><code>Map</code>对象存储键值对，一些常用的方法如下：</p>
<pre><code class="language-js">set(key, value)
get(key)
has(key)
delete(key)
</code></pre>
<p><code>Set</code>对象是唯一值的集合，一些常用的方法如下：</p>
<pre><code class="language-js">add(key)
clear() // 删除所有
delete(key)
entries() keys() values() // 返回值的数组，分别返回键值对、键名、键值，在 Set 中结果相同
has(key)
size()
</code></pre>
<p><code>Map</code>和<code>Set</code>的 key 可以是任何数据类型。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一哈希表">法一：哈希表</h3>
<p>我一开始想到的是使用<code>Map</code>：</p>
<pre><code class="language-js">var findRepeatNumber = function(nums) {
    let hash = new Map();
    for (let i = 0; i &lt; nums.length; ++i) {
        // 这里需要使用 has()，而不是 get()，防止 get() 取到 0 导致判断出错
        if (!hash.has(nums[i])) hash.set(nums[i], i);
        else return nums[i];
    }
};
</code></pre>
<p>后来发现<code>Map</code>存储的是键值对，但在这题中只需要存 key，不需要存 value，因此用<code>Set</code>更好：</p>
<pre><code class="language-js">var findRepeatNumber = function(nums) {
    let set = new Set();
    for (let i = 0; i &lt; nums.length; ++i) {
        if (!set.has(nums[i])) set.add(nums[i]);
        else return nums[i];
    }
};
</code></pre>
<h3 id="法二原地算法">法二：原地算法</h3>
<p>遍历数组<code>nums</code>，设索引初始值为<code>i = 0</code>：</p>
<ul>
<li>若<code>nums[i] = i</code>：说明此数字已在对应索引位置，无需交换，因此跳过；</li>
<li>若<code>nums[nums[i]] = nums[i]</code>：代表索引<code>nums[i]</code>处和索引<code>i</code>处的元素值都为<code>nums[i]</code>，即找到一组重复值，返回此值<code>nums[i]</code>；</li>
<li>否则：交换索引为<code>i</code>和<code>nums[i]</code>的元素值，将此数字交换至对应索引位置。</li>
</ul>
<p>若遍历完毕尚未返回，则返回 -1。</p>
<pre><code class="language-js">var findRepeatNumber = function(nums) {
    let i = 0;
    while (i &lt; nums.length) {
        if (nums[i] === i) {
            // 直到该位置已放置正确数字再处理下一个位置，以保证数组被完全遍历
            ++i;
            continue;
        }
        if (nums[nums[i]] === nums[i]) return nums[i];
        let tmp = nums[i];
        nums[i] = nums[nums[i]];
        // 注意这里 num[i] 已经被修改了值，因此不能用 nums[nums[i]]
        nums[tmp] = tmp;
    }
    return -1;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[05. 替换空格]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_05/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_05/">
        </link>
        <updated>2022-06-11T14:11:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的字符赋值">JavaScript 中的字符赋值</h3>
<p>在 js 中不能直接对字符串中字符赋值：</p>
<pre><code class="language-js">var replaceSpace = function(s) {
    for (let i = 0; i &lt; s.length; ++i) {
        if (s[i] === &quot; &quot;) s[i] = &quot;%20&quot;;
    }
    return s;
};
</code></pre>
<p>正确的做法是使用<code>replace()</code>操作。</p>
<hr>
<h2 id="题解">题解</h2>
<p>不使用字符串方法的解法：</p>
<pre><code class="language-js">var replaceSpace = function(s) {
  let res = ''
  for(let i = 0;i &lt; s.length; i++) {
    if (s[i] === &quot; &quot;) res += &quot;%20&quot;;
    else res += s[i];
  }
  return res;
}
</code></pre>
<p>可以使用<code>split()</code>将字符串转化为数组：</p>
<pre><code class="language-js">var replaceSpace = function(s) {
    arr = s.split(&quot; &quot;);
    let res = &quot;&quot;;
    for (let i = 0; i &lt; arr.length; ++i) {
        if (i === arr.length - 1) res += arr[i]; 
        else res += arr[i] + &quot;%20&quot;;
    }
    return res;
};
</code></pre>
<p>可以使用字符串的自带函数，注意<code>replace()</code>只替换第一个，而<code>replaceAll()</code>替换全部：</p>
<pre><code class="language-js">var replaceSpace = function(s) {
    return s.replaceAll(&quot; &quot;, &quot;%20&quot;);
};
</code></pre>
<p><code>split()</code>以特定分隔符将字符串拆分为数组，<code>join()</code>则以特定分隔符将数组中元素连接成字符串：</p>
<pre><code class="language-js">var replaceSpace = function(s) {
    return s.split(&quot; &quot;).join(&quot;%20&quot;);
};
</code></pre>
]]></content>
    </entry>
</feed>