<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-08-15T12:29:26.876Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[#每日更新# 知识点导航]]></title>
        <id>https://AriesSK.github.io/post/zhishidian/</id>
        <link href="https://AriesSK.github.io/post/zhishidian/">
        </link>
        <updated>2022-08-15T15:59:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="javascript-知识点">JavaScript 知识点</h3>
<p><strong>变量</strong></p>
<ul>
<li>const 声明变量 —— <a href="https://ariessk.github.io/post/jianzhi_57/">57. 和为s的两个数字</a></li>
<li>全局变量的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
</ul>
<p><strong>函数与方法</strong></p>
<ul>
<li>函数与方法 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>赋值与传值</strong></p>
<ul>
<li>原始值与引用值 —— <a href="https://ariessk.github.io/post/jianzhi_25/">25. 合并两个排序的链表</a></li>
<li>函数传值 —— <a href="https://ariessk.github.io/post/jianzhi_13/">13. 机器人的运动范围</a></li>
<li>引用对象的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>赋值运算顺序 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
</ul>
<p><strong>浅拷贝和深拷贝</strong></p>
<ul>
<li>slice 和展开运算符 —— <a href="https://ariessk.github.io/post/top_78/">78. 子集</a></li>
</ul>
<p><strong>prototype</strong></p>
<ul>
<li>通过构造函数的 prototype 原型属性给对象添加新的方法 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>this 关键字</strong></p>
<ul>
<li>this 的指向 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>数值</strong></p>
<ul>
<li>Number 最值 —— <a href="https://ariessk.github.io/post/jianzhi_59_i/">59 - I.滑动窗口的最大值</a></li>
<li>安全整数 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>判空</strong></p>
<ul>
<li>通过数组长度判空 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>运算符</strong></p>
<ul>
<li>运算符优先级 —— <a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a></li>
<li>展开运算符 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>逻辑运算符的短路 —— <a href="https://ariessk.github.io/post/jianzhi_64/">64. 求1+2+...+n</a></li>
<li>右移运算符向下取整 按位与取余运算 —— <a href="https://ariessk.github.io/post/jianzhi_16/">16. 数值的整数次方</a></li>
<li>位运算 按位与消去最右的 0 —— <a href="https://ariessk.github.io/post/jianzhi_15/">15. 二进制中1的个数</a></li>
<li>位运算替代加法 —— <a href="https://ariessk.github.io/post/jianzhi_65/">65. 不用加减乘除做加法</a></li>
<li>按位异或找只出现一次的数字 —— <a href="https://ariessk.github.io/post/jianzhi_56_i/">56 - I. 数组中数字出现的次数 I</a></li>
<li>位运算获取每一位 为每一位赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>幂运算 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>正则表达式 —— <a href="https://ariessk.github.io/post/jianzhi_19/">19. 正则表达式匹配</a></li>
<li>位运算替代加减乘除运算 —— <a href="https://ariessk.github.io/post/top_29/">29. 两数相除</a></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>二维数组创建 赋值 —— <a href="https://ariessk.github.io/post/jianzhi_32_ii/">32 - II. 从上到下打印二叉树 II</a></li>
<li>创建指定大小的二维数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>数字数组赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>创建二维数组的问题 —— <a href="https://ariessk.github.io/post/jianzhi_29/">29. 顺时针打印矩阵</a></li>
<li>字符数组的 join —— <a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a></li>
<li>判断数组是否包含某元素 —— <a href="https://ariessk.github.io/post/top_2/">2. 两数相加</a></li>
<li>使用 map 创建二维数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>二维数组翻转替代旋转 —— <a href="https://ariessk.github.io/post/top_48/">48. 旋转图像</a></li>
<li>数组的原地算法 —— <a href="https://ariessk.github.io/post/top_73/">73. 矩阵置零</a></li>
<li>数组存放不同类型元素 —— <a href="https://ariessk.github.io/post/top_79/">79. 单词搜索</a></li>
</ul>
<p><strong>栈</strong></p>
<ul>
<li>数组模拟栈 —— <a href="https://ariessk.github.io/post/jianzhi_30/">30. 包含min函数的栈</a></li>
<li>栈相关的数组操作 —— <a href="https://ariessk.github.io/post/jianzhi_06/">06. 从头到尾打印链表</a></li>
<li>快速判断出栈序列合法 —— <a href="https://ariessk.github.io/post/jianzhi_31/">31. 栈的压入、弹出序列</a></li>
<li>括号匹配 —— <a href="https://ariessk.github.io/post/top_20/">20. 有效的括号</a></li>
<li>单调栈的应用 —— <a href="https://ariessk.github.io/post/top_84/">84. 柱状图中最大的矩形</a></li>
</ul>
<p><strong>队列</strong></p>
<ul>
<li>数组模拟队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>双端队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_iii/">32 - III. 从上到下打印二叉树 III</a></li>
</ul>
<p><strong>堆</strong></p>
<ul>
<li>封装堆的数据结构 —— <a href="https://ariessk.github.io/post/jianzhi_41/">41. 数据流中的中位数</a></li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>对象模拟链表 —— <a href="https://ariessk.github.io/post/jianzhi_35/">35. 复杂链表的复制</a></li>
<li>链表删除 —— <a href="https://ariessk.github.io/post/top_19/">19. 删除链表的倒数第 N 个节点</a></li>
</ul>
<p><strong>树</strong></p>
<ul>
<li>对象模拟树 树的比较 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>二叉搜索树 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>最近公共祖先 —— <a href="https://ariessk.github.io/post/jianzhi_68_ii/">68 - II. 二叉树的最近公共祖先</a></li>
</ul>
<p><strong>字符串</strong></p>
<ul>
<li>字符串中的字符赋值 —— <a href="https://ariessk.github.io/post/jianzhi_05/">05. 替换空格</a></li>
<li>字符串操作函数 —— <a href="https://ariessk.github.io/post/jianzhi_58_ii/">58 - II. 左旋字符串</a></li>
<li>转化为字符数组 获取 ASCII 值 —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>substr slice 与 substring —— <a href="https://ariessk.github.io/post/jianzhi_46/">46. 把数字翻译成字符串</a></li>
<li>slice substr 补充说明 字符 ASCII 范围 —— <a href="https://ariessk.github.io/post/jianzhi_48/">48. 最长不含重复字符的子字符串</a></li>
<li>操作函数的时间复杂度 split 说明 —— <a href="https://ariessk.github.io/post/jianzhi_58_i/">58 - I. 翻转字符单词顺序</a></li>
<li>判断数字字符 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>charAt 越界 —— <a href="https://ariessk.github.io/post/top_14/">14. 最长公共前缀</a></li>
<li>字符和 ASCII 码转化 —— <a href="https://ariessk.github.io/post/top_49/">49. 字母异位词分组</a></li>
</ul>
<p><strong>哈希表</strong></p>
<ul>
<li>Map 和 Set —— <a href="https://ariessk.github.io/post/jianzhi_03/">03. 数组中重复的数字</a></li>
<li>Map 的 key 和 value —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
<li>哈希表与数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>原地哈希表 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>排序函数</strong></p>
<ul>
<li>sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
<li>自定义 sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_61/">61. 扑克牌中的顺子</a></li>
</ul>
<p><strong>箭头函数</strong></p>
<ul>
<li>箭头函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
</ul>
<p><strong>循环遍历</strong></p>
<ul>
<li>for in 与 for of —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>for in 与 for of 遍历未赋值数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>for in 遍历的属性是字符串 —— <a href="https://ariessk.github.io/post/jianzhi_07/">07. 重建二叉树</a></li>
<li>for in 和 for of 遍历的坑 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>判断语句</strong></p>
<ul>
<li>if 判空 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
</ul>
<hr>
<h3 id="算法知识点">算法知识点</h3>
<p><strong>思路</strong></p>
<ul>
<li>算法的优化思路 —— <a href="https://ariessk.github.io/post/top_42/">42. 接雨水</a></li>
</ul>
<p><strong>递归与迭代</strong></p>
<ul>
<li>递归总结 —— <a href="https://ariessk.github.io/post/jianzhi_24/">24. 反转链表</a></li>
<li>迭代与递归的空间复杂度 —— <a href="https://ariessk.github.io/post/jianzhi_68_i/">68 - I. 二叉搜索树的最近公共祖先</a></li>
<li>归并的递归与迭代 —— <a href="https://ariessk.github.io/post/top_23/">23. 合并K个升序链表</a></li>
</ul>
<p><strong>双指针</strong></p>
<ul>
<li>双指针 剪枝 —— <a href="https://ariessk.github.io/post/top_11/">11. 盛水最多的容器</a></li>
<li>双指针 去重 —— <a href="https://ariessk.github.io/post/top_15/">15. 三数之和</a></li>
</ul>
<p><strong>二分法</strong></p>
<ul>
<li>二分法总结 —— <a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a></li>
<li>二分法核心思想 —— <a href="https://ariessk.github.io/post/top_33/">33. 搜索旋转排序数组</a></li>
<li>二分法的问题转化 —— <a href="https://ariessk.github.io/post/top_34/">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
</ul>
<p><strong>广度优先搜索</strong></p>
<ul>
<li>BFS —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>层序遍历 保存完整信息 —— <a href="https://ariessk.github.io/post/jianzhi_37/">37. 序列化二叉树</a></li>
</ul>
<p><strong>深度优先搜索</strong></p>
<ul>
<li>DFS —— <a href="https://ariessk.github.io/post/jianzhi_26/">26. 树的子结构</a></li>
<li>递归转迭代 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>剪枝 —— <a href="https://ariessk.github.io/post/jianzhi_12/">12. 矩阵中的路径</a></li>
<li>前序 中序 后序遍历 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>自顶向下与自底向上 —— <a href="https://ariessk.github.io/post/jianzhi_55_ii/">55 - II. 平衡二叉树</a></li>
<li>前序 中序 后序遍历序列 —— <a href="https://ariessk.github.io/post/jianzhi_33/">33. 二叉搜索树的后序遍历序列</a></li>
<li>字符串排列 —— <a href="https://ariessk.github.io/post/top_17/">17. 电话号码的字母组合</a></li>
<li>深度优先搜索代码优化 —— <a href="https://ariessk.github.io/post/top_22/">22. 括号生成</a></li>
</ul>
<p><strong>动态规划</strong></p>
<ul>
<li>动态规划总结 —— <a href="https://ariessk.github.io/post/jianzhi_10_i/">10 - I. 斐波那契数列</a></li>
<li>二维数组的动态规划 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>动态规划优化 —— <a href="https://ariessk.github.io/post/top_62/">62. 不同路径</a></li>
</ul>
<p><strong>排序</strong></p>
<ul>
<li>快速排序 —— <a href="https://ariessk.github.io/post/jianzhi_45/">45. 把数组排成最小的数</a></li>
<li>快速选择 计数排序 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
<li>归并排序 —— <a href="https://ariessk.github.io/post/jianzhi_51/">51. 数组中的逆序对</a></li>
</ul>
<p><strong>TopK 问题</strong></p>
<ul>
<li>TopK 问题两种解法及比较 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
</ul>
<p><strong>贪心算法</strong></p>
<ul>
<li>贪心算法 —— <a href="https://ariessk.github.io/post/top_55/">55. 跳跃游戏</a></li>
</ul>
<p><strong>超过一半的数</strong></p>
<ul>
<li>摩尔投票法 —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
</ul>
<p><strong>剪绳子</strong></p>
<ul>
<li>两个推论 —— <a href="https://ariessk.github.io/post/jianzhi_14_i/">14 - I.剪绳子 I</a></li>
</ul>
<p><strong>滑动窗口</strong></p>
<ul>
<li>重要性质 —— <a href="https://ariessk.github.io/post/jianzhi_57_ii/">57 - II. 和为s的连续正数序列</a></li>
<li>复杂的滑动窗口移动 —— <a href="https://ariessk.github.io/post/top_76/">76. 最小覆盖子串</a></li>
</ul>
<p><strong>约瑟夫环</strong></p>
<ul>
<li>推导 —— <a href="https://ariessk.github.io/post/jianzhi_62/">62. 圆圈中最后剩下的数字</a></li>
</ul>
<p><strong>有限状态自动机</strong></p>
<ul>
<li>步骤 —— <a href="https://ariessk.github.io/post/jianzhi_20/">20. 表示数值的字符串</a></li>
<li>思路 —— <a href="https://ariessk.github.io/post/top_8/">8. 字符串转换整数</a></li>
</ul>
<p><strong>质数</strong></p>
<ul>
<li>找质数 丑数 —— <a href="https://ariessk.github.io/post/jianzhi_49/">49. 丑数</a></li>
</ul>
<p><strong>正推与逆推</strong></p>
<ul>
<li>两种思路 —— <a href="https://ariessk.github.io/post/jianzhi_60/">60. n个骰子的点数</a></li>
</ul>
<p><strong>大数</strong></p>
<ul>
<li>大数处理 —— <a href="https://ariessk.github.io/post/jianzhi_17/">17. 打印从1到最大的n位数</a></li>
<li>大数越界的求余 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
<li>大数的溢出问题 —— <a href="https://ariessk.github.io/post/top_66/">66. 加一</a></li>
</ul>
<p><strong>中位数</strong></p>
<ul>
<li>中位数小技巧 —— <a href="https://ariessk.github.io/post/top_4/">4. 寻找两个正序数组的中位数</a></li>
</ul>
<p><strong>回文串</strong></p>
<ul>
<li>中心扩散法 —— <a href="https://ariessk.github.io/post/top_5/">5. 最长回文子串</a></li>
</ul>
<p><strong>模拟</strong></p>
<ul>
<li>模拟概念 —— <a href="https://ariessk.github.io/post/top_13/">13. 罗马数字转整数</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试]]></title>
        <id>https://AriesSK.github.io/post/qian-duan-mian-shi/</id>
        <link href="https://AriesSK.github.io/post/qian-duan-mian-shi/">
        </link>
        <updated>2022-08-15T06:15:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端基础">前端基础</h2>
<h3 id="html">HTML</h3>
<p><strong>h5 新特性</strong></p>
<ul>
<li>媒体播放 video 和 audio</li>
<li>本地存储 localStorge 和 sessionStorage</li>
<li>语义化标签 header、nav、article、section、footer</li>
<li>历史管理 history API</li>
<li>新增选择器 document.querySelector()、document.querySelectorAll()，可以方便地获取 DOM 元素，前者返回第一个，后者返回所有，参数为字符串类型的 &quot;选择器语法&quot;</li>
<li>拖拽释放 Drag and drop API</li>
</ul>
<p><strong>h5 新增加的表单元素</strong><br>
datalist：初始化是一个输入框，点击后出现下拉选项列表，下拉选项通过 option 标签创建<br>
keygen：密钥对生成器，提供验证用户的可靠方法，提交表单生成私钥存在客户端，公钥发到服务器<br>
output：用于不同类型的输出</p>
<p><strong>iframe</strong><br>
内联框架，往网页中引入另一个网页<br>
优点：</p>
<ul>
<li>把嵌入的网页原封不动展现</li>
<li>可以将网页公用的部分写成一个页面使用 iframe 来嵌套，有利于网页统一风格，增加代码可重用</li>
<li>多网页引用时只需修改 iframe 内容就可以更改调用它的每一个页面</li>
<li>可以解决加载缓慢的第三方内容</li>
</ul>
<p>缺点：</p>
<ul>
<li>阻塞主页面的 onload 事件</li>
<li>与主页面共享连接池，会影响页面的并行加载，并且产生的多个页面不容易管理</li>
<li>可能出现上下左右滚动条，用户体验差</li>
<li>不利于 SEO 搜索引擎优化，爬虫难处理 iframe 中的内容</li>
<li>许多移动端设备不兼容</li>
<li>增加服务器的 http 请求，大型网站不可取</li>
</ul>
<p><strong>Web Components</strong><br>
提供一套完善的封装机制使 Web 组件化能够标准化，每种框架的组件都统一标准，推动组件的复用<br>
包含四部分：</p>
<ul>
<li>Custom Elements：让开发者自定义 HTML 元素，包括组成、样式和行为</li>
<li>HTML Imports：在 HTML 中引用和复用其他 HTML 文档的方式</li>
<li>HTML Templates：模板</li>
<li>Shadow DOM：提供更好的组织页面元素的方式，类似 DOM 中的 DOM，其元素和样式独立于原始 DOM</li>
</ul>
<p><strong>浏览器渲染</strong><br>
总体流程：</p>
<ol>
<li>解析文档生成 DOM 树；解析 CSS 生成 CSS 规则树；解析 JavaScript 操作前面两种树</li>
<li>完成解析后通过 DOM 树和 CSS 规则树构造 Rendering Tree (渲染树)；然后计算树中每个渲染对象的位置，叫做回流(布局)</li>
<li>调用 UI 组件绘制(重绘)，将渲染树中的渲染对象内容显示在屏幕上</li>
</ol>
<p>构建 DOM 树：</p>
<ol>
<li>浏览器从磁盘或网络读取原始字节数据，通过指定编码转换为字符串</li>
<li>将字符串转换为 Token，其中会表示出当前 Token 是开始标签、结束标签或文本</li>
<li>根据 Token 生成节点对象，构建 DOM 树</li>
</ol>
<p>构建 CSSOM 树：与构建 DOM 树流程类似。<br>
构建渲染树：将两树组合为渲染树，只包含需要显示的节点及其样式信息(display: none; 的节点不会出现在渲染树中)<br>
布局(回流)：生成渲染树后根据渲染树进行布局，计算个节点在页面中的确切位置和大小，也被称为自动重排，布局输出盒模型，所以的相对测量值都会转化为屏幕上的<strong>绝对像素</strong><br>
绘制：布局完成后触发 Paint 事件，将渲染树转换为屏幕上的像素</p>
<p>渲染遇到 JS 文件：JS 的加载、解析和执行都会阻塞 DOM 的执行，遇到 JS 会暂停构建 DOM，等 JS 引擎运行完后再从中断的地方恢复 DOM 构建。所以想让首批渲染快就不应该在首屏加载 JS 文件，建议将 script 标签放在 body 标签底部。JS 不只是阻塞 DOM 构建，会导致 CSSOM 阻塞 DOM 构建，本来样式不改变 DOM，两者互不影响，但因为 JS 不仅能够更改 DOM，还能更改 CSSOM，而 JS 访问需要完整的 CSSOM，所以这种情况下，浏览器<strong>先下载构建 CSSOM，再执行 JS，再构建 DOM</strong></p>
<p>回流：渲染树中出现元素尺寸、布局、隐藏等改变，需要重新构建<br>
重绘：渲染树中元素更改外观，不影响布局<br>
回流必定重绘，重绘不一定回流<br>
减少回流、重绘：使用 transform 替代 top 做动画；使用 visibility 替换 display，opacity替代 visibility；不使用 table 布局；将频繁重绘或回流的节点设置为图层，避免影响别的节点</p>
<p><strong>首次渲染</strong><br>
为了尽快完成首次渲染，需要最大限度减少以下三种可变因素：</p>
<ol>
<li>关键资源数量：可能阻止网页首次渲染的资源</li>
<li>关键路径长度：受关键资源和字节大小一级依赖关系影响</li>
<li>关键字节数量</li>
</ol>
<p>优化关键渲染路径步骤：</p>
<ol>
<li>分析关键路径的资源数、字节数、长度</li>
<li>最大限度减少关键资源的数量：延迟下载，标记为异步等</li>
<li>优化关键字节数，缩短下载时间</li>
<li>优化关键资源加载顺序：尽早下载所有关键资源</li>
</ol>
<p><strong>web 标准的理解</strong><br>
web 标准是多个标准的集合，主要有结构标准、表现标准、行为标准<br>
结构标准：文档的结构与组织，对应 HTML 和 XML<br>
表现标准：文档的表现效果，对应 CSS<br>
行为标准：对网页的逻辑操作，网页的交互，对应 ECMA Script</p>
<p><strong>前端优化</strong><br>
目的：提高页面的加载速度，优化用户的访问体验<br>
可以从三方面优化：<br>
页面内容方面：</p>
<ol>
<li>通过文件合并、css sprite（雪碧图，将页面中涉及到的图都包含到一张大图中）、将图片打包成 base64 格式等方式减少 HTTP 请求数，避免过多的请求造成等待</li>
<li>通过 DNS 缓存机制减少 DNS 的查询次数</li>
<li>通过设置缓存策略，对常用的不变资源进行缓存</li>
<li>使用延迟加载方式减少首屏加载需要请求的资源，延迟加载的资源等需要访问时在请求加载</li>
<li>通过用户行为，对某些资源使用预加载的方式，提高用户需要访问资源时的响应速度</li>
</ol>
<p>服务器方面：</p>
<ol>
<li>使用 CDN(Content Delivery Network，内容分发网络，利用最靠近用户的服务器将用户请求的资源更快更稳定地传输过去) 服务，提高用户对于资源请求时的响应速度</li>
<li>服务器启用 Gzip 对传输资源进行压缩，减小文件体积</li>
<li>尽可能减小 cookie 的大小，并且将静态资源分配到其他域名下，避免请求静态资源时携带不必要的 cookie</li>
</ol>
<p>CSS 和 JS 方面：</p>
<ol>
<li>样式表（外部，内联）放在 head 标签中而不是 body 底部</li>
<li>避免使用 @import 标签</li>
<li>尽量把 js 脚本放在 body 结束标签前或使用 defer、async，避免脚本加载和执行阻塞页面渲染</li>
<li>压缩 js 和 css 文件大小，减小文件体积，比如使用 webpack</li>
</ol>
<h3 id="css">CSS</h3>
<p><strong>水平居中</strong></p>
<ol>
<li>给 div 设置宽度，然后 margin: 0 auto; （margin 上下为 0，左右根据宽度自适应相同值，就实现了居中，注意 div 一定要设置宽度</li>
<li>父容器设置 text-align: center;</li>
</ol>
<p><strong>水平垂直居中</strong></p>
<ol>
<li>绝对定位，top、left、bottom、right 均设为 0，margin 设为 auto</li>
<li>绝对定位，top、left 设置为 50%，margin-left、margin-top 设置为负的宽高的一半（也可以将长宽的一半直接在 top 、left 中减掉；或者使用 transform: translate(-50%, -50%); 向左上角移动一半的宽和高）</li>
<li>父容器设置 flex 布局，并设置 align-item: center; 垂直居中和 justify-content: center; 水平居中</li>
</ol>
<p><strong>浮动高度坍塌</strong><br>
在文档流中，父元素的高度默认被子元素撑开，但当子元素设置为浮动后，就会脱离文档流，导致无法撑起父元素的高度，使父元素高度塌陷，会导致父元素下面的所有元素向上移动，使页面布局混乱。</p>
<p><strong>清除浮动</strong></p>
<ol>
<li>固定父元素的高度，但会导致父元素无法自适应子元素高度（不推荐使用）</li>
<li>触发父元素 BFC，副作用最小的方式是将父元素的 overflow 设置为 hidden，缺点是内容增多时容易造成超出尺寸的内容隐藏</li>
<li>zoom 属性，设置对象缩放比例，触发 hasLayout，清除浮动，是 ie 的专有属性</li>
<li>使用 clear 属性，可以清除浮动元素对该元素的影响，而不是清除浮动，可以在要清除浮动的元素后面加一个空白 div 设置 clear: both;，缺点是会产生很多无意义的标签</li>
<li>根据 3 的思路使用伪元素 after 替代空白标签，注意要设置内容为空，设置为块级元素，设置 clear 属性，因为 clear 属性只有块级元素才有效，而伪元素默认是内联元素（最推荐）</li>
</ol>
<pre><code class="language-css">.clear::after {
    content: '';
    display: block;
    clear: both;
}
</code></pre>
<p><strong>transition 和 animation 的区别</strong><br>
transition 只有开始和结束状态，需要借助别的方式触发<br>
animation 可以有多个状态，有帧的概念，并且可以自动触发</p>
<p>**height: 100%; 失效 **<br>
百分比高度要生效需要父级有一个生效的高度值<br>
所以给父元素设置高度，或者给该元素设置绝对定位（绝对定位的元素会有计算值）</p>
<p><strong>white-space</strong></p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>自动换行</th>
<th>合并空格</th>
<th>换行符(enter)</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td>允许</td>
<td>是</td>
<td>变成空格</td>
</tr>
<tr>
<td>nowarp</td>
<td>不允许</td>
<td>是</td>
<td>变成空格</td>
</tr>
<tr>
<td>pre</td>
<td>不允许</td>
<td>否</td>
<td>正常换行</td>
</tr>
<tr>
<td>pre-line</td>
<td>允许</td>
<td>是</td>
<td>正常换行</td>
</tr>
<tr>
<td>pre-warp</td>
<td>允许</td>
<td>否</td>
<td>正常换行</td>
</tr>
</tbody>
</table>
<p><strong>两栏布局与三栏布局</strong><br>
两栏布局使用左边固定，右边自适应的布局，有四种方法：</p>
<ol>
<li>浮动：左边元素设置固定宽度并向左浮动，右边元素 margin-left 设置为左边元素的宽度</li>
<li>flex 布局：左边元素 flex-grow 和 flex-shrink 设置 0，flex-basis 设置固定长度，右边元素 flex 设置为 auto</li>
<li>绝对定位：父元素相对定位，左边元素设置为 absolute 定位并且设置固定宽度，右边元素 margin-left 设为左边元素宽度</li>
<li>绝对定位：左边元素同上，右边元素设置 left 为左边元素宽度，top、right、bottom 为 0</li>
</ol>
<p>三栏布局左右两栏固定，中间自适应布局，有五种方法：</p>
<ol>
<li>flex 布局：左右元素 flex-grow 和 flex-shrink 设置 0，flex-basis 设置固定长度，中间元素 flex 设置为 auto</li>
<li>绝对定位：父元素相对定位，左右元素设置为 absolute 定位并设置固定宽度，中间元素设置对应方向的 margin</li>
<li>浮动：左右元素固定宽度并设置对应方向的浮动，中间栏设置左右两个方向的 margin，注意 html 中中间元素需要放在<strong>最后</strong>，否则右边元素会沉在中间元素下面</li>
<li>圣杯布局：利用浮动和负边距实现，父元素设置左右 padding，三个元素均设置左浮动，中间一列放在<strong>最前</strong>，宽度 100%，将下面两列挤到下一行，再通过 margin 负值移动到上一行，再定位到两边占据 padding 的部分，缺点是<strong>中间元素的宽度不能小于左边元素的宽度</strong></li>
<li>双飞翼布局：相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的，圣杯布局和双飞翼布局的有点是可以优先渲染中间元素，也就是主要部分</li>
</ol>
<pre><code class="language-css">/*圣杯布局*/
.outer {
  height: 100px;
  padding-left: 100px;
  padding-right: 200px;
}
.center {
  float: left;
  width: 100%;
  height: 100px;
  background: lightgreen;
}
.left {
  position: relative;
  /* 向左平移将 left 的内容定位到合适位置 */
  left: -100px;
  float: left;
  /* 向左平移父元素的宽度，使 left 排到 center 前面*/
  margin-left: -100%;
  width: 100px;
  height: 100px;
  background: tomato;
}
.right {
  position: relative;
  /* 向左平移将 right 的内容定位到合适位置 */
  left: 200px;
  float: left;
  /* 向左平移自身宽度，使 right 与 center 同行*/
  margin-left: -200px;
  width: 200px;
  height: 100px;
  background: gold;
}

/*双飞翼布局*/
.outer {
  height: 100px;
}
/* 双飞翼布局的中间元素需要多一个容器包裹 */
.wrapper {
  float: left;
  width: 100%;
  height: 100px;
  background: lightgreen;
}
.center {
  margin-left: 100px;
  margin-right: 200px;
  height: 100px;
}
.left {
  float: left;
  margin-left: -100%;
  width: 100px;
  height: 100px;
  background: tomato;
}
.right {
  float: left;
  margin-left: -200px;
  width: 200px;
  height: 100px;
  background: gold;
}
</code></pre>
<h3 id="javascript">JavaScript</h3>
<p><strong>字面量</strong><br>
字面量，和常量差不多，其表达的信息如字面所示</p>
<p><strong>Object.assign(target, ...sources)</strong><br>
将 source 中的可枚举属性复制给 target，重名属性后面的覆盖前面的<br>
复制的是属性值，如果属性值是引用类型则复制引用地址，会出现引用共享的问题（修改其中的一个会影响到别的）</p>
<p><strong>constructor</strong><br>
constructor 属性是专门为 function 设计的，存在于每一个 function 函数的 prototype 原型属性中，是指向 prototype 所在函数的指针<br>
当我们调用该函数作为构造函数创建一个新实例后，该实例中将包含一个指向构造函数中的 prototype 的指针 proto<br>
如果以等于一个以<strong>对象字面量</strong>形式创建的新对象，constructor 不再指向该构造函数，比如</p>
<pre><code class="language-js">var person={ 
    name:&quot;Jack&quot;, 
    age:10
};
</code></pre>
<p><strong>map 和 forEach</strong></p>
<pre><code class="language-js">const arr = [1,2,3];
// map 遍历数组并给每个数翻倍
const arr1 = arr.map(x=&gt;x*2); //[2,4,6]
// forEach 遍历数组，有三个参数，分别是：当前遍历的数组元素 item、当前的元素下标 index、数组本身 arr
let sum = 0;
arr.forEach(function(item, index, arr) {
    if (arr[index] &gt; 0) sum += item;
})
</code></pre>
<p>相同点：</p>
<ol>
<li>均循环遍历数组每一项</li>
<li>只能遍历数组</li>
<li>匿名函数都支持三个参数 item、index、arr</li>
<li>匿名函数中的 this 指向 window</li>
</ol>
<p>不同点：</p>
<ol>
<li>map 创建新数组并返回，forEach 无返回</li>
<li>forEach 可以修改原数组，map 不会</li>
</ol>
<p><strong>for of</strong><br>
es6 的新增方法，只限于迭代器(iterator)，也就是<strong>可迭代</strong>对象，比如 Array、Map、Set、String、arguments、TyoedArray 等</p>
<p><strong>js 静态类型检查</strong><br>
静态类型语言：变量在定义的时候有类型声明，类型的检查发生在编译时，在运行的时候无法修改变量类型，编译器可以确定运行时需要的内存总量<br>
动态类型语言：变量在定义的时候无类型声明，类型的检查发生在运行时，在运行的时候可以修改变量类型<br>
对比：静态类型可以尽早发现错误，减少了复杂的错误处理，将数据和行为分离，也有利于代码重构；动态类型的代码比较精简，并且不需要花时间掌握类型<br>
js 的静态类型检查方法：<strong>Flow</strong>是 Facebook 的 js 静态类型检查工具，能够找出类型错误；<strong>TypeScript</strong> 在 js 的基础上添加静态类型定义，并且会被编译成 js</p>
<p><strong>indexOf</strong><br>
<code>str.indexOf(searchValue[, fromIndex])</code> 找到返回第一个匹配字串的起始下标，未找到返回 0<br>
searchValue 不设置会查找字符串 'undefined'<br>
fromIndex 是可选的，不填默认 0，负数等同 0，大于字符串长度等同于字符串长度<br>
<strong>严格区分大小写</strong></p>
<p><strong>变量提升</strong><br>
js 是单线程语言，是按顺序执行，但是一段一段地分析执行，代码执行前的编译阶段会检测到所有的变量和函数声明，添加到叫做 Lexical Environment 的 js 数据结构的内存中，所以能够在真正被声明前使用</p>
<p><strong>HashMap 和 Array</strong><br>
HashMap 散列表 是 数组 + 链表</p>
<ul>
<li>查找效率：HashMap 根据 hashcode 直接算出 index，在数组每个下标的链表只有一个元素的时候，能达到 O(1)；Array 二分查找，受数组长度影响较大</li>
<li>扩容数量：HashMap 初始长度 16，每次扩容申请双倍，扩容次数少；Array 小于 4 申请 4，小于 8 申请 8，大于 8 申请 size * 1.5，申请空间少</li>
<li>扩容效率：HashMap 扩容重新计算每个元素的位置，然后放到新的位置；Array 直接赋值数组，效率更高</li>
<li>内存消耗：Array 使用了独特的方式重复利用因为数组扩容遗留的数组空间，HashMap 没有</li>
</ul>
<p>总的来说，数据量小且使用频繁使用 Array，数据量大使用 HashMap</p>
<p><strong>HashMap 和 Object</strong><br>
两者累次允许按键存取值，删除键，检测键是否有值，不过 Map 有些优势：</p>
<ul>
<li>意外的键：Map 默认不包含任何键；Object 有原型，可能与插入的键名冲突</li>
<li>键的类型：Map 键可以是任意值；Object 只能是 String 或 Symbol</li>
<li>键的顺序：Map 键是有序的，迭代时以<strong>插入顺序</strong>返回；Object 无序</li>
<li>Size：Map 通过 size 容易获取键值对个数；Object 手动计算</li>
<li>迭代：Map 可直接迭代；获取 Object 的键值后才能迭代</li>
<li>性能：Map 在频繁增删时性能更优；Object 无优化</li>
</ul>
<p><strong>原型与原型链</strong><br>
js 每个构造函数都有 prototype 属性指向它的原型对象（实例原型），原型对象派生的子对象叫构造函数<br>
每个构造函数的实例都包含一个指向原型对象的内部指针 __proto__，该属性可以访问原型，但不存在于 Person.prototype 中，而是来自 Object.prototype，使用了 getter 方法<br>
每个原型对象有一个 constructor 指针指向其关联的构造函数<br>
如果原型对象是另一个类型的实例，则该原型对象包含着指向另一个原型的指针，层层递进就会形成实例与原型的链条，称为原型链，是图中蓝色的箭头<br>
<img src="https://AriesSK.github.io/post-images/1658986531078.png" alt="" loading="lazy"><br>
根据原型链，就可以实现 instanceOf，其原理就是判断右边变量的 prototype 是否在左边变量的原型链上即可：</p>
<pre><code class="language-js">funcion instance_of(left, right) {
    let rightProto = right.prototype;
    left = left._proto_;
    while (true) {
        if (left === null) return false;
        if (left === rightProto) return true;
        left = left._proto_;
    }
}
</code></pre>
<p><strong>强弱引用</strong><br>
对象的引用就是强引用，WeakMaps 和 WeakSets 是 js 弱引用的唯一途径，弱引用不能防止对象被垃圾回收</p>
<p><strong>垃圾回收</strong><br>
内存是临时存储变量等数据的位置，内存也有生命周期，从内存创建分配到内存读写再到内存销毁，当内存不再使用，则会被垃圾回收，防止内存泄露（在执行垃圾回收时，遗漏一些内存没有回收）<br>
所以垃圾回收机制的<strong>核心</strong>就是判断内存是否不再使用，有两种方法：</p>
<ul>
<li>引用计数：早期浏览器方法，计算内存被引用的次数，被引用一次计数 +1，不被引用一次计数 -1，计数为 0 就将内存释放回收，该方法简单有效，但循环引用会导致内存泄漏</li>
<li>标记清除：目前浏览器方法，标记所有从根节点开始能够访问到的对象，未被标记的对象就是未被强据引用的垃圾对象，被清除</li>
</ul>
<p><strong>内存泄漏</strong></p>
<ul>
<li>意外的全局变量：全局变量内存不会回收，若全局变量使用不当又没有手动回收（赋值 null），就发生内存泄漏</li>
<li>未被清空的定时器：定时器的生命周期有专门的线程维护，不挂靠在页面上，所以在某个页面使用定时器，页面销毁而没有手动清空定时器，就发生内存泄漏</li>
<li>使用不当的闭包：在一个函数内部定义一个子函数，并且子函数调用了在父函数内定义的变量，并且在父函数外部被调用，这就形成了闭包；通常函数使用完后申请的内存会被回收，但闭包会导致父函数执行完内存仍无法被回收，造成内存泄漏</li>
<li>遗漏的 DOM 引用：DOM 元素的生命周期正常取决与是否挂载在 DOM 树上，但被 js 引用时，还由 js 决定，若未清理则发生内存泄露</li>
<li>未被销毁的事件监听：垃圾回收机制不能判断事件是否需要被解除，需要手动解除，否则出现内存泄漏</li>
</ul>
<p><strong><code>||</code>和<code>&amp;&amp;</code></strong><br>
返回的是其中一个操作数的值，而不是条件判断的结果<br>
对于<code>||</code>，只要前面的表达式为值<code>false</code>，就返回后面表达式的值；只要前面的表达式为值<code>true</code>，就返回前面表达式的值<br>
对于<code>&amp;&amp;</code>，只要前面的表达式为值<code>false</code>，就返回前面表达式的值；只要前面的表达式为值<code>true</code>，就返回后面表达式的值<br>
js 中只有 undefined、null、0、-0、NaN、&quot;&quot; 这六个转换为布尔值时会被转换为 false，<code>[]</code>是对象，为 true</p>
<pre><code class="language-js">console.log(null || undefined); // undefined
console.log(true || undefined); // true
console.log(null &amp;&amp; undefined); // null
console.log(true &amp;&amp; undefined); // undefined
</code></pre>
<p><strong>构造函数</strong><br>
对于构造函数，必定返回一个对象，若<code>return</code>不是对象，则返回空对象</p>
<pre><code class="language-js">'foo' == new function(){ return String('foo'); }; // false，构造函数返回空对象
'foo' == new function(){ return new String('foo'); }; // true，构造函数返回 String 对象
</code></pre>
<p><strong>字符串和数字转化</strong><br>
字符串到数字：</p>
<ul>
<li>Number() 字符串中有非数字即返回 NaN</li>
<li>parseInt()、parseFloat() 提取<strong>首字母</strong>为数字的任意字符串，后面可以包含其他字符</li>
</ul>
<p>数字到字符串：</p>
<ul>
<li>与空字符串相加</li>
<li>toString()</li>
</ul>
<p><strong>节流和防抖</strong><br>
节流（throttle）：</p>
<ol>
<li>设置一个变量，限定为 true 时才允许进入函数，进入函数后该变量置为 false</li>
<li>设置定时器 setTimeout 在规定时间后才能再次触发并执行函数</li>
<li>使用闭包存储变量</li>
</ol>
<pre><code class="language-js">function throttle(fn, time) {
    let flag = true;
    return function() {
        if (!flag) return;
        flag = false;
        // arguments 替代 fn 中的所有传入参数
        fn.apply(this, arguments);
        setTimeout(() =&gt; {
            flag = true;
        }, time);
    }
}
const input = () =&gt; console.log(&quot;throttle&quot;);
div.addEventListener(&quot;click&quot;, throttle(input, 1000));
</code></pre>
<p>防抖（debounce）：</p>
<ol>
<li>触发事件时设置定时器 setTimeout  延迟触发</li>
<li>每次触发都会清除并重置定时器</li>
<li>使用闭包存储定时器</li>
</ol>
<pre><code class="language-js">function debounce(fn, time) {
    let timeout = null;
    return function() {
        clearTimeout(timeout);
        timeout = setTimeout(() =&gt; {
            fn.apply(this, arguments);
        })
    }
}
const input = () =&gt; console.log(&quot;debounce&quot;);
div.addEventListener(&quot;click&quot;, debounce(input, 1000));
</code></pre>
<p><strong>this 指向</strong></p>
<ol>
<li>在全局作用域下，this 始终指向全局对象 window</li>
<li>函数中的 this 指向调用函数的对象，严格模式下必须写出调用函数的对象，非严格模式可以省略</li>
<li>对象中的 this 指向 window，对象内部的方法的 this 同样指向调用的对象</li>
<li>构造函数中的 this 指向创建的实例</li>
<li>箭头函数中的 this 指向比较特殊，因为箭头函数<strong>没有 this</strong>，所以其 this 指向继承自父级的 this，并且在定义时被确定，之后不会改变，call()、apply()、bind() 均无法改变</li>
</ol>
<p><strong>箭头函数</strong></p>
<ul>
<li>是匿名函数</li>
<li>不能作为构造函数，不能使用 new 关键字</li>
<li>没有原型，没有 prototype</li>
<li>没有 this，继承自父级，无法通过 call()、apply()、bind() 改变 this 指向</li>
<li>没有 arguments 对象，若有外层函数则继承，否则报错，使用 rest 参数（形式为<code>…变量名</code>）替代 arguments</li>
<li>没有 Generator，不能使用 yeild</li>
</ul>
<p><strong>Generator yeild</strong><br>
Generator 函数就是一个封装的异步的任务，是一个异步容器，在 function 和函数名之间存在星号</p>
<ul>
<li>需要使用 .next() 方法进行启动，分阶段执行 Generator 函数</li>
<li>每次调用 .next() 会返回一个对象表示当前阶段的信息</li>
</ul>
<pre><code class="language-js">function* foo(){
    for(let i = 0;i&lt;2;i++){
        yield i
    }
}
let f = foo()
// f.next() 返回yeild后面的表达式
console.log(f.next()) // {value:0,done:false}
console.log(f.next()) // {value:1,done:false}
console.log(f.next()) // {value:undefind,done:true}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[84. 柱状图中最大的矩形]]></title>
        <id>https://AriesSK.github.io/post/top_84/</id>
        <link href="https://AriesSK.github.io/post/top_84/">
        </link>
        <updated>2022-08-12T03:20:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="单调栈的应用">单调栈的应用</h3>
<p>单调栈分为单调递增栈和单调递减栈。<br>
以单调递增栈为例：如果新元素比栈顶元素大，则将该元素入栈；如果新元素比栈顶元素小，则重复将栈内元素出栈直至栈顶元素比新元素小。<br>
单调栈的作用是：以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的时间复杂度一次遍历找到数组中每个元素左右最近的比其小/大的元素。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="单调栈">单调栈</h3>
<p>本题使用单调递增序列，当元素出栈时，新入栈的元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 是出栈元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>o</mi><mi>p</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">stack.pop()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> 右侧第一个比它小的元素；新的栈顶元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo>[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">stack[stack.length - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 是出栈元素左侧第一个比它小的元素。此时出栈元素的高度下的最大面积为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo>[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mn>1</mn><mo>)</mo><mo>∗</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>s</mi><mo>[</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi mathvariant="normal">.</mi><mi>p</mi><mi>o</mi><mi>p</mi><mo>(</mo><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">i - stack[stack.length - 1] - 1) * heights[stack.pop()]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">.</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>。<br>
数组中的每个元素均会入栈出栈一次，就能够遍历每个高度的最大面积，最终得出真正的最大面积。<br>
至于每种情况下的面积公式比较难想到的话，可以画出<strong>示意图</strong>来寻找正确的公式。</p>
<pre><code class="language-js">var largestRectangleArea = function(heights) {
    const stack = [];
    let res = 0;
    // 因为只有在出栈的时候才会计算并尝试更新最大的矩形，为了防止数组为递增序列而导致一直未更新，在数组末尾加入小于数组中元素的 0，确保更新
    heights.push(0);
    for (let i = 0; i &lt; heights.length; ++i) {
        // 栈非空并且栈顶元素不小于新元素时出栈
        while (stack.length &amp;&amp; heights[stack[stack.length - 1]] &gt;= heights[i]) {
            // i 是 h 右侧第一个比它小的元素，栈顶元素 stack[stack.length - 1] 是 h 左侧第一个比它小的元素
            let h = heights[stack.pop()];
            // 空栈说明到目前均为递减序列，最大面积为 i * h
            // 非空栈说明前面有过递增序列，持续出栈并计算面积
            res = stack.length ? Math.max(res, (i - stack[stack.length - 1] - 1) * h) : Math.max(res, i * h);
        }
        stack.push(i);
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[EX01. 优惠券问题]]></title>
        <id>https://AriesSK.github.io/post/algo_ex01/</id>
        <link href="https://AriesSK.github.io/post/algo_ex01/">
        </link>
        <updated>2022-08-09T01:36:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="题目">题目</h2>
<p>近期某商场由于周年庆，开启了“0元购”活动。活动中，消费者可以通过组合手中的代金券，实现0元购买指定商品。消费券有不同的面额，对于指定价格的商品，使用代金券凑出其价格，但所使用的代金券总面额不可超过商品价格。请用算法来快速计算最少需要使用几张优惠券。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="贪心算法-动态规划">贪心算法 动态规划</h3>
<pre><code class="language-js">function cal(amount, type) {
    const dp = new Array(amount + 1).fill(0);
    for (let i = 1; i &lt;= amount; ++i) {
        dp[i] = Number.POSITIVE_INFINITY;
        for (let j = 0; j &lt; type.length; ++j) {
            // 状态转移方程
            if (i &gt;= type[j]) dp[i] = Math.min(dp[i], dp[i - type[j]] + 1);
        }
    }
    return dp[amount] === Infinity ? &quot;Impossible&quot; : dp[amount];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[79. 单词搜索]]></title>
        <id>https://AriesSK.github.io/post/top_79/</id>
        <link href="https://AriesSK.github.io/post/top_79/">
        </link>
        <updated>2022-08-08T05:37:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题与剑指offer<a href="https://ariessk.github.io/post/jianzhi_12/">12. 矩阵中的路径</a>相同，使用<strong>深度优先搜索 + 回溯</strong> 的方法，第二遍做成功做出来了，不错。</p>
<h3 id="javascript-数组特点">JavaScript 数组特点</h3>
<p>相对于 Java 等语言，js 的数组中可以存放不同类型的数据。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索-回溯">深度优先搜索 + 回溯</h3>
<p>通常需要使用与原数组相同大小的数组来表示该元素的访问情况，但是在 js 中因为一个数组可以存放不同类型的数据，所以可以直接在原数组内修改为原数组中不可能出现的值，比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，然后在回溯的时候再将数组恢复为原数组即可，不影响后续遍历：</p>
<pre><code class="language-js">var exist = function(board, word) {
    const m = board.length, n = board[0].length;
    // 设置二维数组记录访问的情况
    const flag = new Array(m).fill().map(() =&gt; new Array(n).fill(0));
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (dfs(i ,j, 0)) return true;
        }
    }
    return false;

    function dfs(i, j, x) {
        if (x === word.length) return true; // 未判断字符是否是所求字符，需到 word.length 才能返回
        if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || flag[i][j] || board[i][j] !== word.charAt(x)) return false;
        // if (x === word.length - 1) return true; 未在在上一行返回说明字符是所求的，因此可以提前返回
        flag[i][j] = 1;
        const res =  dfs(i - 1, j, x + 1) || dfs(i, j + 1, x + 1) || dfs(i + 1, j, x + 1) || dfs(i, j - 1, x + 1);
        flag[i][j] = 0; // 回溯后恢复原状，不影响后续遍历
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[78. 子集]]></title>
        <id>https://AriesSK.github.io/post/top_78/</id>
        <link href="https://AriesSK.github.io/post/top_78/">
        </link>
        <updated>2022-08-07T03:26:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-浅拷贝和深拷贝">JavaScript 浅拷贝和深拷贝</h3>
<p>浅拷贝和深拷贝是针对<strong>引用数据类型</strong>的，浅拷贝复制对象的第一层，深拷贝递归复制每一层。<br>
<strong>注意：</strong> 如果浅拷贝复制的第一层是基本数据类型，那就是直接复制，原数组修改<strong>不影响</strong>新数组，如果第一次是引用数据类型，则拷贝地址，原数组修改<strong>影响</strong>新数组。<br>
对于本道题中的<code>tmp.slice()</code>实现的就是浅拷贝，但是由于<code>tmp</code>的第一层是基本数据类型，所以直接复制。</p>
<h3 id="slice和扩展运算符"><code>slice()</code>和扩展运算符<code>...</code></h3>
<p><code>slice()</code>实现的是浅拷贝，当不传参数时实现浅拷贝<strong>整个</strong>数组。<br>
扩展运算符对于<strong>第一层是深拷贝</strong>，对于<strong>更深层是浅拷贝</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一递归回溯">法一：递归回溯</h3>
<p>与<a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a>的方法相似，不过对于这道题，每一位可以选择加入或不加入<strong>两种</strong>情况：</p>
<pre><code class="language-js">var subsets = function(nums) {
    const tmp = [], res = [];
    dfs(0);
    return res;

    function dfs(x) {
        if (x === nums.length) {
            res.push(tmp.slice());
            return;
        }
        // 将当前位元素加入结果中，注意回溯时复原
        tmp.push(nums[x]);
        dfs(x + 1);
        tmp.pop();
        // 不将当前元素加入结果中
        dfs(x + 1);
    }
};
</code></pre>
<h3 id="法二位运算">法二：位运算</h3>
<p>因为长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数组有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 个子集，所以刚好可以使用二进制数来替代，二进制数中的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 代表不将该位加入结果中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 则表示加入：</p>
<pre><code class="language-js">var subsets = function(nums) {
    const res = [];
    const n = nums.length;
    // 1 左移 n 位(2^n)作为遍历上限，比如 n 为 3，则从 000 遍历到 111，也就是从 0 遍历到 7
    for (let x = 0; x &lt; (1 &lt;&lt; n); ++x) {
        const tmp = [];
        for (let i = 0; i &lt; n; ++i) {
            // 位与运算，判断该位值，为 1 加入结果，为 0 不加入
            if (x &amp; (1 &lt;&lt; i)) {
                tmp.push(nums[i]);
            }
        }
        res.push(tmp);
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[76. 最小覆盖子串]]></title>
        <id>https://AriesSK.github.io/post/top_76/</id>
        <link href="https://AriesSK.github.io/post/top_76/">
        </link>
        <updated>2022-08-05T02:55:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="复杂的滑动窗口移动">复杂的滑动窗口移动</h3>
<p>滑动窗口的题需要想清楚左右边界的移动条件，保证不会漏过可能是答案的区间，再转化为代码。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="滑动窗口">滑动窗口</h3>
<p>这道题算是一道经典的滑动窗口题，看到时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 还是比较容易想到要用滑动窗口的。<br>
这道题的难点在于如何判断滑动窗口中包含了字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 中的所有字符。<br>
方法是使用两个哈希表，一个记录滑动窗口中字符和次数，一个记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 中的字符和次数，在滑动窗口扩张时，使用变量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 记录满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 中字符和个数的字符数，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 的长度时，就说明滑动窗口中包含了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 中的所有字符。<br>
具体算法流程：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 右移，同时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 右移，直到遇到第一个属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 的字符，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 停下；</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 继续右移，直到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 的长度时，更新最小子串；</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 继续右移，直到遇见与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 相同的字符，此时可以收缩滑动窗口，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 右移至下一个属于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span> 的字符停下，此时滑动窗口又是一个满足条件的子串，判断是否更新最小字串；</li>
<li>重复第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 步至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 遍历完 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>。</li>
</ol>
<pre><code class="language-js">var minWindow = function(s, t) {
    // smap 维护滑动窗口中各字符的出现次数，tmap 维护 t 中各字符出现的次数
    const smap = new Map(), tmap = new Map();
    for (let i = 0; i &lt; t.length; ++i) {
        const c = t.charAt(i);
        if (tmap.has(c)) tmap.set(c, tmap.get(c) + 1);
        else tmap.set(c, 1);
    }
    // cnt 记录滑动窗口中属于 t 的字符总数
    let res = &quot;&quot;, len = Number.MAX_SAFE_INTEGER, cnt = 0;
    // 扩张滑动窗口
    for (let l = 0, r = 0; r &lt; s.length; ++r) {
        const c = s.charAt(r);
        if (smap.has(c)) smap.set(c, smap.get(c) + 1);
        else smap.set(c, 1);
        // 如果该字符属于 t 并且未超过 t 拥有的个数，计数增加
        if (smap.get(c) &lt;= tmap.get(c)) ++cnt;
        // 收缩滑动窗口，保证窗口不为空
        while (l &lt; r &amp;&amp; (!tmap.has(s.charAt(l)) || smap.get(s.charAt(l)) &gt; tmap.get(s.charAt(l)))) {
            // l 在遇见属于 t 的字符并且该字符在滑动窗口中出现的次数未超过 t 中次数时停止右移
            smap.set(s.charAt(l), smap.get(s.charAt(l)) - 1);
            ++l;
        }
        // 滑动窗口内包含 t 全部字符，更新最短区间
        if (cnt === t.length &amp;&amp; r - l + 1 &lt; len) {
            len = r - l + 1;
            res = s.slice(l, r + 1);
        }
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[75. 颜色分类]]></title>
        <id>https://AriesSK.github.io/post/top_75/</id>
        <link href="https://AriesSK.github.io/post/top_75/">
        </link>
        <updated>2022-08-04T02:59:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中">JavaScript 中</h3>
<p>方法如下：</p>
<pre><code class="language-js">
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一计数排序">法一：计数排序</h3>
<p>很简单的思路，需要遍历两次数组：</p>
<pre><code class="language-js">var sortColors = function(nums) {
    let a = 0, b = 0, c = 0;
    for (const num of nums) {
        if (num === 0) ++a;
        if (num === 1) ++b;
        if (num === 2) ++c;
    }
    let i = 0;
    while(a--) nums[i++] = 0;
    while(b--) nums[i++] = 1;
    while(c--) nums[i++] = 2;
}; 
</code></pre>
<h3 id="法二单指针">法二：单指针</h3>
<p>同样两次遍历，第一次将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 换到数组头部，第二次遍历将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 之后：</p>
<pre><code class="language-js">var sortColors = function(nums) {
    let ptr = 0;
    for (let i = 0; i &lt; nums.length; ++i) {
        if (nums[i] === 0) swap(i, ptr++);
    }
    for (let i = ptr; i &lt; nums.length; ++i) {
        if (nums[i] === 1) swap(i, ptr++);
    }

    function swap(a, b) {
        const tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}; 
</code></pre>
<h3 id="法三双指针">法三：双指针</h3>
<p>使用两个指针分别交换 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，只需要遍历<strong>一次</strong>。<br>
需要注意的是，要保证 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针始终指向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 区间的下一位，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针始终指向 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 区间的下一位，所以当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 区间变长一位，两个指针都需要右移一位，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 区间变长一位，只需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针右移一位即可。<br>
而当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针之前时，说明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针指的位置是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这时候若要将后面的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 指针位置，则需要将换出去的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 再换到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 指针的位置：</p>
<pre><code class="language-js">var sortColors = function(nums) {
    let p0 = 0, p1 = 0;
    for (let i = 0; i &lt; nums.length; ++i) {
        if (nums[i] === 0) {
            swap(i, p0);
            if (p0 &lt; p1) swap(i, p1);
            ++p0;
            ++p1;
        }
        else if (nums[i] === 1) {
            swap(i, p1);
            ++p1;
        }
    }

    function swap(a, b) {
        const tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
}; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[73. 矩阵置零]]></title>
        <id>https://AriesSK.github.io/post/top_73/</id>
        <link href="https://AriesSK.github.io/post/top_73/">
        </link>
        <updated>2022-08-04T01:27:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="数组的原地算法">数组的原地算法</h3>
<p>要实现数组的原地算法，则只能尝试通过原数组中的空间来替代额外的标记空间，然而这样会导致原数组的这部分空间被修改，在本题中，因为只需要记录该部分被修改的空间中是否有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，因此额外的标记就与数组大小无关，就可以实现原地算法。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一额外数组">法一：额外数组</h3>
<p>最简单的方法就是使用一个同样的小的二维数组记录原数组中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 出现的位置，然后实现置零，空间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m * n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>
然后又想了想，发现用来记录的二维数组可以使用两个一维数组替代，空间复杂度降至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var setZeroes = function(matrix) {
    const m = matrix.length, n = matrix[0].length;
    const x = new Array(m).fill(0), y = new Array(n).fill(0);
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (!matrix[i][j]) {
                x[i] = 1;
                y[j] = 1;
            }
        }
    }
    for (let i = 0; i &lt; m; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            if (x[i] || y[j]) matrix[i][j] = 0;
        }
    }
};
</code></pre>
<h3 id="法二原地算法">法二：原地算法</h3>
<p>使用矩阵的第一行和第一列替代法一的两个额外数组，先使用两个标记记录第一行和第一列是否有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，然后使用第一行和第一列进行标记，若矩阵剩余部分出现 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则将其对于的行列标记为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，其余则保持原值以保证第一行和第一列的正确性，最后再通过两个标记置零第一行和第一列：</p>
<pre><code class="language-js">var setZeroes = function(matrix) {
    const m = matrix.length, n = matrix[0].length;
    let x = false, y = false;
    for (let i = 0; i &lt; m; ++i) {
        if (!matrix[i][0]) {
            x = true;
            break;
        }
    }
    for (let j = 0; j &lt; n; ++j) {
        if (!matrix[0][j]) {
            y = true;
            break;
        }
    }
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][j]) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;
        }
    }
    if (x) {
        for (let i = 0; i &lt; m; i++) matrix[i][0] = 0;
    }
    if (y) {
        for (let j = 0; j &lt; n; j++) matrix[0][j] = 0;
    }
};
</code></pre>
<p>还可以优化至只用一个变量标记第一列原本是否存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，再使用第一列的第一个元素元素记录第一行是否存在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，要注意这种情况下要从最后一行向上处理矩阵，因为第一行作为标记数组需要最后被处理：</p>
<pre><code class="language-js">var setZeroes = function(matrix) {
    const m = matrix.length, n = matrix[0].length;
    let x = false;
    for (let i = 0; i &lt; m; ++i) {
        if (!matrix[i][0]) x = true;
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][j]) {
                matrix[i][0] = 0;
                matrix[0][j] = 0;
            }
        }
    }
    for (let i = m - 1; i &gt;= 0; --i) {
        for (let j = 1; j &lt; n; ++j) {
            if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;
        }
        if (x) matrix[i][0] = 0;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[70. 爬楼梯]]></title>
        <id>https://AriesSK.github.io/post/top_70/</id>
        <link href="https://AriesSK.github.io/post/top_70/">
        </link>
        <updated>2022-08-03T03:27:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>与剑指offer的<a href="https://ariessk.github.io/post/jianzhi_10_ii/">10 - II. 青蛙跳台阶问题</a>相同。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="动态规划">动态规划</h3>
<p>类似斐波那契数列，当前状态只与前两个状态相关，使用滚动数组替代 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 数组：</p>
<pre><code class="language-js">var climbStairs = function(n) {
    let p = 0, q = 0, r = 1;
    while (n--) {
        p = q;
        q = r;
        r = p + q;
    }
    return r;
};
</code></pre>
]]></content>
    </entry>
</feed>