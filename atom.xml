<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-06-23T09:04:49.458Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[54. 二叉搜索树的第k大节点]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_54/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_54/">
        </link>
        <updated>2022-06-23T08:30:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="运算符优先级">运算符优先级</h3>
<p>关于运算符的优先级，见<a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a><br>
下面两种的运算结果是一样的，这题中都可以：</p>
<pre><code class="language-js">let k = 1;
console.log(!--k); // true
k = 1;
console.log(!(--k)); // true
</code></pre>
<p>不过这样写容易出错，还是老实写：</p>
<pre><code class="language-js">let k = 1;
console.log(--k == 0); // true
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>二叉搜索树的中序遍历就是升序数组，本题进行逆向的中序遍历，并且设置<code>isFound</code>标志找到了目标，提前结束递归（题目规定不会有空树的情况）：</p>
<pre><code class="language-js">var kthLargest = function(root, k) {
	let isFound = false, res;
	dfs(root);
    return res;

    function dfs(root) {
        if (!root) return;
        dfs(root.right);
		if (isFound) return;
        if (k - 1) --k;
        else {
			res = root.val;
			isFound = true;
		}
        dfs(root.left);
    }
};
</code></pre>
<p>后来发现<code>isFound</code>可以省略，当<code>k</code>减到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时即代表找到了目标：</p>
<pre><code class="language-js">var kthLargest = function(root, k) {
	let res;
	dfs(root);
    return res;

    function dfs(root) {
        if (!root) return;
        dfs(root.right);
		if (!k) return;
        // 先自减再判断是否为 0
        if (!--k) res = root.val;
        dfs(root.left);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. 二叉搜索树与双向链表]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_36/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_36/">
        </link>
        <updated>2022-06-23T06:12:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二叉搜索树二叉查找树二叉排序树">二叉搜索树（二叉查找树，二叉排序树）</h3>
<p><strong>定义：</strong> 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。<br>
二叉搜索树（Binary Search Tree, BST）的<strong>中序遍历</strong>是<strong>升序序列</strong>。</p>
<h3 id="三种深度优先搜索">三种深度优先搜索</h3>
<p>前中后指的是<code>root</code>节点在三个节点中的位置</p>
<h4 id="前序遍历">前序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    console.log(root.val); // 操作 root 节点，比如打印其值
    dfs(root.left);
    dfs(root.right);
}
</code></pre>
<h4 id="中序遍历">中序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    dfs(root.left);
    console.log(root.val); // 操作 root 节点，比如打印其值
    dfs(root.right);
}
</code></pre>
<h4 id="后序遍历">后序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    dfs(root.left);
    dfs(root.right);
    console.log(root.val); // 操作 root 节点，比如打印其值
}
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一使用队列">法一：使用队列</h3>
<p>我一开始想到的方法，在中序遍历的同时使用一个队列按顺序保存每一个节点，再按顺序输出节点并连接：</p>
<pre><code class="language-js">var treeToDoublyList = function(root) {
    if (!root) return root;
    const list = [];
    dfs(root);
    const head = list.shift();
    let ptr = head;
    while(list.length) {
        ptr.right = list.shift();
        ptr.right.left = ptr;
        ptr = ptr.right;
    }
    ptr.right = head;
    head.left = ptr;
    return head;

    function dfs(root) {
        if (!root) return;
        dfs(root.left);
        list.push(root);
	    dfs(root.right);
    }
};
</code></pre>
<h3 id="法二原地算法">法二：原地算法</h3>
<p>事实上并不需要使用队列保存节点，使用一个``pre<code>和一个</code>curr`指针分别保存上一个节点和当前节点即可：</p>
<pre><code class="language-js">var treeToDoublyList = function(root) {
    let pre, curr;
    // 空树
    if (!root) return root;
    dfs(root);
    // 完成中序遍历后还需将头节点和尾节点连接起来成环
    head.left = pre;
    pre.right = head;
    return head;

    function dfs(curr) {
        if (!curr) return;
        // 先找到最左侧的叶子节点，是链表的头节点
        dfs(curr.left);
        if (pre) pre.right = curr;
        else head = curr;
        curr.left = pre;
        // 更新 curr
        pre = curr;
	    dfs(curr.right);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. 二叉树中和为某一值的路径]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_34/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_34/">
        </link>
        <updated>2022-06-23T03:08:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的坑">JavaScript 的坑</h3>
<p>做这道题的过程中遇到了两个坑，记录一下。</p>
<h4 id="声明全局变量">声明全局变量</h4>
<p>这道题中我需要在<code>dfs(root, target)</code>中使用<code>path</code>和<code>res</code>，所以一开始在最外层声明了变量，即全局变量，像下面这样：</p>
<pre><code class="language-js">const path = [], res = [];
var pathSum = function(root, target) {}
var dfs = function(root, target) {}
</code></pre>
<p>这样写能够通过 Leetcode 的测试用例，但同样的用例在正式提交时却会报错，这是因为上一次用例运行留下的全局变量并没有被销毁，会使之后的用例运行出错，所以应当将<code>dfs(root, target)</code>设置为局部函数：</p>
<pre><code class="language-js">var pathSum = function(root, target) {
    const path = [], res = [];
    function dfs(root, target) {}
}
</code></pre>
<h4 id="引用值">引用值</h4>
<p>这道题里的<code>path</code>是引用对象，使用<code>res.push([path])</code>是将这个引用对象放入了<code>res</code>中，而后续<code>path</code>对象改变时，<code>res</code>中的<code>path</code>的会随之改变，输出错误结果，正确处理需要深拷贝<code>path</code>存入<code>res</code>中，需要用到展开<strong>运算符</strong><code>...</code>。</p>
<pre><code class="language-js">res.push([...path]);
</code></pre>
<ul>
<li>对于一级基础数据，展开运算符实现<strong>深拷贝</strong>；</li>
<li>对于二级及以上的复杂数据，展开运算符实现<strong>浅拷贝</strong>。</li>
</ul>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>这道题需要遍历到叶子节点并且输出所有可能，因此无法剪枝。<br>
使用<code>path</code>保存当前遍历的路径，<code>res</code>保存符合要求的路径，需要注意的是在返回上一层递归的时候需要通过<code>path.pop()</code>将<code>path</code>恢复至上一层节点：</p>
<pre><code class="language-js">var pathSum = function(root, target) {
    const path = [], res = [];
    dfs(root, target);
    return res;

    // 声明函数
    function dfs(root, target) {
        if (!root) return;
        path.push(root.val);
        target -= root.val;
        // 深拷贝 path 并存入 res
        if (!root.left &amp;&amp; !root.right &amp;&amp; !target) res.push([...path]);
        dfs(root.left, target);
        dfs(root.right, target);
        // 恢复 path
        path.pop();
    };
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[13. 机器人的运动范围]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_13/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_13/">
        </link>
        <updated>2022-06-22T05:30:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的函数传值">JavaScript 中的函数传值</h3>
<p>js 中的所有函数的参数都是按值传递的，这意味着函数外的值会被复制到函数内部的参数中，如果是原始值，就跟原始值变量的复制一样，如果是引用值，就和引用值变量的复制一样。</p>
<ul>
<li><strong>按值传递参数：</strong> 外部的值被复制到函数的一个局部变量中，这两个值相互独立，互不干扰；</li>
<li><strong>按引用传递参数：</strong> 外部的值在内存中的位置会被保存到函数的一个局部变量中，意味着对局部变量的修改会反应到函数外部，这在 js 中是<strong>不可能的</strong>。<br>
<img src="https://AriesSK.github.io/post-images/1655878734447.png" alt="" loading="lazy"><br>
原始值的按值传递举例，可以看到传入参数与外部值相互独立，互不干扰：</li>
</ul>
<pre><code class="language-js">function addOne (num) {
    num += 1;
    return num;
}
let count = 20;
let res = addOne(count); // count === 20, res === 30
</code></pre>
<p>引用值的按值传递举例，如果是按引用传递，那么在新建<code>obj</code>对象的时候，<code>person</code>应该自动将指针改为指向&quot;Aries&quot;的对象，但事实上并没有。这证明了是按值传递的，传递了引用值，而引用的对象是保存在全局作用域，因此可以通过<code>obj</code>访问引用对象修改属性：</p>
<pre><code class="language-js">function setName(obj) {
    obj.name = &quot;AriesSK&quot;;
    obj = new Object();
    obj.name = &quot;Aries&quot;
    return num;
}
let person = new Object();
setName(person); // person.name === &quot;AriesSK&quot;
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一深度优先搜索">法一：深度优先搜索</h3>
<p>我的解法：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    let res = 0;
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    return dfs(visit, 0, 0, k, res);
};

var dfs = function(visit, i, j, k, res) {
    let s = &quot;&quot; + i + j, sum = 0;
    for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
    if (i &lt; 0 || i &gt;= visit.length || j &lt; 0 || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return res;
    visit[i][j] = 1;
    res = dfs(visit, i + 1, j, k, res);
    res = dfs(visit, i - 1, j, k, res);
    res = dfs(visit, i, j + 1, k, res);
    res = dfs(visit, i, j - 1, k, res);
    return ++res;
}
</code></pre>
<p><img src="https://AriesSK.github.io/post-images/1655879902391.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655879907533.png" alt="" loading="lazy"><br>
dfs 解法的优化，省略了不必要的<code>res</code>，并且由于从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 开始，由图可以看出仅通过向右和向下两个方向即可访问所有可达解：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    return dfs(visit, 0, 0, k);
};

var dfs = function(visit, i, j, k) {
    let s = &quot;&quot; + i + j, sum = 0;
    for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
    if ( i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return 0;
    visit[i][j] = 1;
    return 1 + dfs(visit, i + 1, j, k) + dfs(visit, i, j + 1, k);
}
</code></pre>
<h3 id="法二广度优先搜索">法二：广度优先搜索</h3>
<p>bfs 需要用到队列和循环，无需递归：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    let res = 0;
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    const queue = [];
    queue.unshift([0, 0]);
    while(queue.length &gt; 0) {
        let temp = queue.pop();
        let i = temp[0], j = temp[1], s = &quot;&quot; + i + j, sum = 0;
        for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
        if (i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) continue;
        visit[i][j] = 1;
        ++res;
        queue.unshift([i + 1, j]);
        queue.unshift([i, j + 1]);
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[12. 矩阵中的路径]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_12/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_12/">
        </link>
        <updated>2022-06-22T02:25:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>通过递归的方式，先朝一个方向搜索到底，再回溯至上个节点，沿另一个方向搜索，一次类推。</p>
<h3 id="剪枝">剪枝</h3>
<p>在搜索过程中遇到<strong>该路径不可能与目标匹配成功</strong>的情况时，应当立即返回，这叫<strong>可行性剪枝</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索-剪枝">深度优先搜索 + 剪枝</h3>
<ul>
<li>
<p><strong>递归终止条件：</strong></p>
<ul>
<li>返回 <code>false</code>：索引越界 || 当前矩阵元素与目标不匹配（包括已访问）；</li>
<li>返回<code>true</code>：<code>k === word.length - 1</code>，即<code>word</code>已完全匹配。</li>
</ul>
</li>
<li>
<p><strong>递推工作：</strong></p>
<ol>
<li>标记已访问：将<code>board[i][j]</code>修改为 <code>0</code>，防止重复搜索；</li>
<li>搜索下一元素：朝当前元素上、下、左、右四个方向进行下一层递归，使用<code>||</code>连接代表只需找到一条可行路径，记录结果至<code>res</code>；</li>
<li>还原：将<code>board[i][j]</code>还原至初始值<code>word[k]</code>。<br>
<img src="https://AriesSK.github.io/post-images/1655866202557.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655866209347.png" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
<pre><code class="language-js">var exist = function(board, word) {
    for (let i = 0; i &lt; board.length; ++i) {
        for (let j = 0; j &lt; board[0].length; ++j) {
            if (dfs(board, word, i, j, 0)) return true;
        }
    }
    return false;
};

var dfs = function(board, word, i, j, k) {
    if (i &gt;= board.length || i &lt; 0 || j &gt; board[0].length || j &lt; 0 || board[i][j] !== word[k]) return false;
    if (k === word.length - 1) return true;
    // 标记已访问
    board[i][j] = 0;
    const res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1);
    // 恢复原数组
    board[i][j] = word[k];
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[58 - I. 翻转字符单词顺序]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_58_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_58_i/">
        </link>
        <updated>2022-06-21T12:29:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的正则表达式">JavaScript 的正则表达式</h3>
<p>语法：<br>
<code>/正则表达式主体/修饰符(可选)</code><br>
修饰符不区分大小写：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td>g</td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配</td>
</tr>
</tbody>
</table>
<p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>查找方括号之间的任何字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找任何以 | 分隔的选项</td>
</tr>
</tbody>
</table>
<p>元字符是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>查找数字</td>
</tr>
<tr>
<td>\s</td>
<td>查找空白字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>查找以十六进制数 xxxx 规定的 Unicode 字符</td>
</tr>
</tbody>
</table>
<p>量词:</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>n+</td>
<td>匹配任何包含至少一个 n 的字符串</td>
</tr>
<tr>
<td>n*</td>
<td>匹配任何包含零个或多个 n 的字符串</td>
</tr>
<tr>
<td>n?</td>
<td>匹配任何包含零个或一个 n 的字符串</td>
</tr>
</tbody>
</table>
<h3 id="javascript-的字符串函数">JavaScript 的字符串函数</h3>
<p>本题中使用的一些字符串函数及它们的时间复杂度：</p>
<pre><code class="language-js">trim() // 去除字符串头尾的空格 O(n)
split() // 拆分成数组 O(n)
reverse() // 反转数组 O(n)
join() // 使用特定分隔符将数组连接成字符串 O(n)
</code></pre>
<p>其中需要重点说明<code>split()</code>举例如下：</p>
<pre><code class="language-js">let s = &quot;a  b c&quot;
s.split() // [&quot;a  b c&quot;] // 直接返回数组
s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开
s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素
s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一字符串函数">法一：字符串函数</h3>
<p>首先想到使用<code>tirm()</code>删除头尾空格，<code>split(&quot; &quot;)</code>拆分成数组，从数组末尾开始拼接：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    const arr = s.trim().split(&quot; &quot;);
    let res = &quot;&quot;;
    for (let i = arr.length - 1; i &gt;= 0; --i) {
        if (arr[i] === &quot;&quot;) continue;
        res += i ? arr[i] + &quot; &quot; : arr[i];
    }
    return res;
};
</code></pre>
<p>事实上使用字符串函数代码可以更加简洁：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
};
</code></pre>
<h3 id="法二双指针">法二：双指针</h3>
<pre><code class="language-js">var reverseWords = function(s) {
    s = s.trim();
    let left = s.length - 1, right = left;
    let res = &quot;&quot;;
    // 保证 left 能够取到 0
    while (left &gt;= 0) {
        // 找到第一个空格
        while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left;
        res += s.substring(left + 1, right + 1) + &quot; &quot;;
        // 忽略空格找到第一个字符
        while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left;
        right = left;
    }
    // 删去最后末尾多余的一个空格
    return res.trim();
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[57. 和为s的两个数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_57/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_57/">
        </link>
        <updated>2022-06-21T11:46:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的const">JavaScript 的<code>const</code></h3>
<p>在允许的情况下，推荐使用<code>const</code>进行声明，<code>const</code>声明后无法重新赋值，但可以修改其属性值。</p>
<hr>
<h2 id="题解">题解</h2>
<p>双指针的简单应用：</p>
<pre><code class="language-js">var twoSum = function(nums, target) {
    let left = 0, right = nums.length - 1;
    const res = [];
    // 若允许同一个数自己加自己则取 =
    while (left &lt; right) {
        // 在值是正数的情况下，改加为减能够有效防止值溢出
        if (nums[left] &gt; target - nums[right]) --right;
        else if (nums[left] &lt; target - nums[right]) ++left;
        else {
            res.push(nums[left]);
            res.push(nums[right]);
            // 不适用 break 会导致无限循环入栈至溢出
            break;
        }
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[21. 调整数组顺序使奇数位于偶数前面]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_21/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_21/">
        </link>
        <updated>2022-06-21T10:56:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的运算符优先级">JavaScript 中的运算符优先级</h3>
<p><img src="https://AriesSK.github.io/post-images/1655902411960.png" alt="" loading="lazy"><br>
在写代码时需要注意运算符的优先级，如下由于<code>!</code>的运算优先级高于<code>%</code>，因此加不加<code>()</code>是两种结果：</p>
<pre><code class="language-js">let num = 2;
console.log(!num % 2); // 0
console.log(!(num % 2)); // true
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<p>简单的双指针运用：</p>
<pre><code class="language-js">var exchange = function(nums) {
    let left = 0, right = nums.length - 1;
    // while 中是否取等号均可
    while (left &lt; right) {
        if (nums[left] % 2) ++left;
        else if (!(nums[right] % 2)) --right;
        else {
            let temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
        } 
    }
    return nums;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[22. 链表中的倒数第k个节点]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_22/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_22/">
        </link>
        <updated>2022-06-19T13:10:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中">JavaScript 中</h3>
<p>此类题目对头节点并不需要特殊的处理 因此可以不另设头指针。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="双指针">双指针</h3>
<p>两指针减保持 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 距离，直到右指针为空时，左指针即为目标节点：</p>
<pre><code class="language-js">var getKthFromEnd = function(head, k) {
    let left = head, right = left;
    while (k &gt; 0) {
        right = right.next;
        --k;
    }
    while (right) {
        left = left.next;
        right = right.next;
    }
    return left;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[18. 删除链表的节点]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_18/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_18/">
        </link>
        <updated>2022-06-19T11:10:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>在链表前设置一个指向头节点的头指针能够使算法不用单独考虑头节点的处理。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="双指针">双指针</h3>
<p>使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>e</mi><mi>x</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">next</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span></span></span></span> 遍历目标节点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">curr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 记录目标节点的前一节点，以实现断链<br>
推荐设置一个值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">null</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 的头节点（头指针）<code>newHead</code>，能够有效避免删除头节点或链表为空的情况：</p>
<pre><code class="language-js">var deleteNode = function(head, val) {
    const newHead = new ListNode();
    newHead.next = head;
    let curr = newHead, next = curr.next;
    while (next) {
        if (next.val === val) {
            curr.next = next.next;
            next.next = null;
            break;
        }
        curr = curr.next;
        next = next.next;
    }
    return newHead.next;
};
</code></pre>
]]></content>
    </entry>
</feed>