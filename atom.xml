<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-07-27T12:57:10.675Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[#每日更新# 知识点导航]]></title>
        <id>https://AriesSK.github.io/post/zhishidian/</id>
        <link href="https://AriesSK.github.io/post/zhishidian/">
        </link>
        <updated>2022-12-31T15:59:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="javascript-知识点">JavaScript 知识点</h3>
<p><strong>变量</strong></p>
<ul>
<li>const 声明变量 —— <a href="https://ariessk.github.io/post/jianzhi_57/">57. 和为s的两个数字</a></li>
<li>全局变量的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
</ul>
<p><strong>函数与方法</strong></p>
<ul>
<li>函数与方法 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>赋值与传值</strong></p>
<ul>
<li>原始值与引用值 —— <a href="https://ariessk.github.io/post/jianzhi_25/">25. 合并两个排序的链表</a></li>
<li>函数传值 —— <a href="https://ariessk.github.io/post/jianzhi_13/">13. 机器人的运动范围</a></li>
<li>引用对象的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>赋值运算顺序 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
</ul>
<p><strong>prototype</strong></p>
<ul>
<li>通过构造函数的 prototype 原型属性给对象添加新的方法 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>this 关键字</strong></p>
<ul>
<li>this 的指向 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>数值</strong></p>
<ul>
<li>Number 最值 —— <a href="https://ariessk.github.io/post/jianzhi_59_i/">59 - I.滑动窗口的最大值</a></li>
<li>安全整数 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>判空</strong></p>
<ul>
<li>通过数组长度判空 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>运算符</strong></p>
<ul>
<li>运算符优先级 —— <a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a></li>
<li>展开运算符 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>逻辑运算符的短路 —— <a href="https://ariessk.github.io/post/jianzhi_64/">64. 求1+2+...+n</a></li>
<li>右移运算符向下取整 按位与取余运算 —— <a href="https://ariessk.github.io/post/jianzhi_16/">16. 数组的整数次方</a></li>
<li>位运算 按位与消去最右的 0 —— <a href="https://ariessk.github.io/post/jianzhi_15/">15. 二进制中1的个数</a></li>
<li>位运算替代加法 —— <a href="https://ariessk.github.io/post/jianzhi_65/">65. 不用加减乘除做加法</a></li>
<li>按位异或找只出现一次的数字 —— <a href="https://ariessk.github.io/post/jianzhi_56_i/">56 - I. 数组中数字出现的次数 I</a></li>
<li>位运算获取每一位 为每一位赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>幂运算 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>正则表达式 —— <a href="https://ariessk.github.io/post/jianzhi_19/">19. 正则表达式匹配</a></li>
<li>位运算替代加减乘除运算 —— <a href="https://ariessk.github.io/post/top_33/">29. 两数相除</a></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>二维数组创建 赋值 —— <a href="https://ariessk.github.io/post/jianzhi_32_ii/">32 - II. 从上到下打印二叉树 II</a></li>
<li>创建指定大小的二维数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>数字数组赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>创建二维数组的问题 —— <a href="https://ariessk.github.io/post/jianzhi_29/">29. 顺时针打印矩阵</a></li>
<li>字符数组的 join —— <a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a></li>
<li>判断数组是否包含某元素 —— <a href="https://ariessk.github.io/post/top_2/">2. 两数相加</a></li>
<li>使用 map 创建二维数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
</ul>
<p><strong>栈</strong></p>
<ul>
<li>数组模拟栈 —— <a href="https://ariessk.github.io/post/jianzhi_30/">30. 包含min函数的栈</a></li>
<li>栈相关的数组操作 —— <a href="https://ariessk.github.io/post/jianzhi_06/">06. 从头到尾打印链表</a></li>
<li>快速判断出栈序列合法 —— <a href="https://ariessk.github.io/post/jianzhi_31/">31. 栈的压入、弹出序列</a></li>
<li>括号匹配 —— <a href="https://ariessk.github.io/post/top_20/">20. 有效的括号</a></li>
</ul>
<p><strong>队列</strong></p>
<ul>
<li>数组模拟队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>双端队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_iii/">32 - III. 从上到下打印二叉树 III</a></li>
</ul>
<p><strong>堆</strong></p>
<ul>
<li>封装堆的数据结构 —— <a href="https://ariessk.github.io/post/jianzhi_41/">41. 数据流中的中位数</a></li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>对象模拟链表 —— <a href="https://ariessk.github.io/post/jianzhi_35/">35. 复杂链表的复制</a></li>
<li>链表删除 —— <a href="https://ariessk.github.io/post/top_19/">19. 删除链表的倒数第 N 个节点</a></li>
</ul>
<p><strong>树</strong></p>
<ul>
<li>对象模拟树 树的比较 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>二叉搜索树 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>最近公共祖先 —— <a href="https://ariessk.github.io/post/jianzhi_68_ii/">68 - II. 二叉树的最近公共祖先</a></li>
</ul>
<p><strong>字符串</strong></p>
<ul>
<li>字符串中的字符赋值 —— <a href="https://ariessk.github.io/post/jianzhi_05/">05. 替换空格</a></li>
<li>字符串操作函数 —— <a href="https://ariessk.github.io/post/jianzhi_58_ii/">58 - II. 左旋字符串</a></li>
<li>转化为字符数组 获取 ASCII 值 —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>substr slice 与 substring —— <a href="https://ariessk.github.io/post/jianzhi_46/">46. 把数字翻译成字符串</a></li>
<li>slice substr 补充说明 字符 ASCII 范围 —— <a href="https://ariessk.github.io/post/jianzhi_48/">48. 最长不含重复字符的子字符串</a></li>
<li>操作函数的时间复杂度 split 说明 —— <a href="https://ariessk.github.io/post/jianzhi_58_i/">58 - I. 翻转字符单词顺序</a></li>
<li>判断数字字符 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>charAt 越界 —— <a href="https://ariessk.github.io/post/top_14/">14. 最长公共前缀</a></li>
</ul>
<p><strong>哈希表</strong></p>
<ul>
<li>Map 和 Set —— <a href="https://ariessk.github.io/post/jianzhi_03/">03. 数组中重复的数字</a></li>
<li>Map 的 key 和 value —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
<li>哈希表与数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>原地哈希表 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>排序函数</strong></p>
<ul>
<li>sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
<li>自定义 sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_61/">61. 扑克牌中的顺子</a></li>
</ul>
<p><strong>箭头函数</strong></p>
<ul>
<li>箭头函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
</ul>
<p><strong>循环遍历</strong></p>
<ul>
<li>for in 与 for of —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>for in 与 for of 遍历未赋值数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>for in 遍历的属性是字符串 —— <a href="https://ariessk.github.io/post/jianzhi_07/">07. 重建二叉树</a></li>
<li>for in 和 for of 遍历的坑 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>判断语句</strong></p>
<ul>
<li>if 判空 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
</ul>
<hr>
<h3 id="算法知识点">算法知识点</h3>
<p><strong>递归与迭代</strong></p>
<ul>
<li>递归总结 —— <a href="https://ariessk.github.io/post/jianzhi_24/">24. 反转链表</a></li>
<li>迭代与递归的空间复杂度 —— <a href="https://ariessk.github.io/post/jianzhi_68_i/">68 - I. 二叉搜索树的最近公共祖先</a></li>
<li>归并的递归与迭代 —— <a href="https://ariessk.github.io/post/top_23/">23. 合并K个升序链表</a></li>
</ul>
<p><strong>双指针</strong></p>
<ul>
<li>双指针 剪枝 —— <a href="https://ariessk.github.io/post/top_11/">11. 盛水最多的容器</a></li>
<li>双指针 去重 —— <a href="https://ariessk.github.io/post/top_15/">15. 三数之和</a></li>
</ul>
<p><strong>二分法</strong></p>
<ul>
<li>二分法总结 —— <a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a></li>
<li>二分法核心思想 —— <a href="https://ariessk.github.io/post/top_33/">33. 搜索旋转排序数组</a></li>
<li>二分法的问题转化 —— <a href="https://ariessk.github.io/post/top_34/">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
</ul>
<p><strong>广度优先搜索</strong></p>
<ul>
<li>BFS —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>层序遍历 保存完整信息 —— <a href="https://ariessk.github.io/post/jianzhi_37/">37. 序列化二叉树</a></li>
</ul>
<p><strong>深度优先搜索</strong></p>
<ul>
<li>DFS —— <a href="https://ariessk.github.io/post/jianzhi_26/">26. 树的子结构</a></li>
<li>递归转迭代 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>剪枝 —— <a href="https://ariessk.github.io/post/jianzhi_12/">12. 矩阵中的路径</a></li>
<li>前序 中序 后序遍历 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>自顶向下与自底向上 —— <a href="https://ariessk.github.io/post/jianzhi_55_ii/">55 - II. 平衡二叉树</a></li>
<li>前序 中序 后序遍历序列 —— <a href="https://ariessk.github.io/post/jianzhi_33/">33. 二叉搜索树的后序遍历序列</a></li>
<li>字符串排列 —— <a href="https://ariessk.github.io/post/top_17/">17. 电话号码的字母组合</a></li>
<li>深度优先搜索代码优化 —— <a href="https://ariessk.github.io/post/top_22/">22. 括号生成</a></li>
</ul>
<p><strong>动态规划</strong></p>
<ul>
<li>动态规划总结 —— <a href="https://ariessk.github.io/post/jianzhi_10_i/">10 - I. 斐波那契数列</a></li>
<li>二维数组的动态规划 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
</ul>
<p><strong>排序</strong></p>
<ul>
<li>快速排序 —— <a href="https://ariessk.github.io/post/jianzhi_45/">45. 把数组排成最小的数</a></li>
<li>快速选择 计数排序 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
<li>归并排序 —— <a href="https://ariessk.github.io/post/jianzhi_51/">51. 数组中的逆序对</a></li>
</ul>
<p><strong>TopK 问题</strong></p>
<ul>
<li>TopK 问题两种解法及比较 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
</ul>
<p><strong>超过一半的数</strong></p>
<ul>
<li>摩尔投票法 —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
</ul>
<p><strong>剪绳子</strong></p>
<ul>
<li>两个推论 —— <a href="https://ariessk.github.io/post/jianzhi_14_i/">14 - I.剪绳子 I</a></li>
</ul>
<p><strong>滑动窗口</strong></p>
<ul>
<li>重要性质 —— <a href="https://ariessk.github.io/post/jianzhi_57_ii/">57 - II. 和为s的连续正数序列</a></li>
</ul>
<p><strong>约瑟夫环</strong></p>
<ul>
<li>推导 —— <a href="https://ariessk.github.io/post/jianzhi_62/">62. 圆圈中最后剩下的数字</a></li>
</ul>
<p><strong>有限状态自动机</strong></p>
<ul>
<li>步骤 —— <a href="https://ariessk.github.io/post/jianzhi_20/">20. 表示数值的字符串</a></li>
<li>思路 —— <a href="https://ariessk.github.io/post/top_8/">8. 字符串转换整数</a></li>
</ul>
<p><strong>质数</strong></p>
<ul>
<li>找质数 丑数 —— <a href="https://ariessk.github.io/post/jianzhi_49/">49. 丑数</a></li>
</ul>
<p><strong>正推与逆推</strong></p>
<ul>
<li>两种思路 —— <a href="https://ariessk.github.io/post/jianzhi_60/">60. n个骰子的点数</a></li>
</ul>
<p><strong>大数</strong></p>
<ul>
<li>大数处理 —— <a href="https://ariessk.github.io/post/jianzhi_17/">17. 打印从1到最大的n位数</a></li>
<li>大数越界的求余 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>中位数</strong></p>
<ul>
<li>中位数小技巧 —— <a href="https://ariessk.github.io/post/top_4/">4. 寻找两个正序数组的中位数</a></li>
</ul>
<p><strong>回文串</strong></p>
<ul>
<li>中心扩散法 —— <a href="https://ariessk.github.io/post/top_5/">5. 最长回文子串</a></li>
</ul>
<p><strong>模拟</strong></p>
<ul>
<li>模拟概念 —— <a href="https://ariessk.github.io/post/top_13/">13. 罗马数字转整数</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue]]></title>
        <id>https://AriesSK.github.io/post/vue/</id>
        <link href="https://AriesSK.github.io/post/vue/">
        </link>
        <updated>2022-12-31T07:01:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="vue-知识">Vue 知识</h2>
<p><strong>单向绑定 与 双向绑定</strong></p>
<ul>
<li>单向绑定：数据改变，页面元素会跟着改变；而页面元素改变，数据不会改变（v-text, v-html, 插值表达式{{}}, v-bind）</li>
<li>双向绑定：页面元素与数据的双向绑定，一方改变另一方也改变（v-model）</li>
</ul>
<p><strong>Vue 的响应式原理</strong><br>
把一个 JS 对象传给 Vue 实例的 data 属性时，Vue 将遍历此对象的所有属性，并且使用 <strong>Object.defineProperty</strong> 将这些属性转换为 getter/setter</p>
<p><strong>Vue 的异步渲染</strong><br>
Vue 实现响应式<strong>不是在数据变化后 DOM 立即变化</strong>，是按异步策略更新的：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li>
<li>主线程之外，还存在一个&quot;任务队列&quot;（task queue），只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件</li>
<li>一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
<p><strong>Vue 的渲染过程</strong><br>
Vue 加载时文件的执行顺序：</p>
<ol>
<li>执行 index.html 文件</li>
<li>执行 main.js 文件</li>
<li>main.js 挂载 app.vue，用 app.vue 的 templete 替换 index.html 中的<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></li>
<li>main.js 注入路由文件<code>router/index.js</code>，通过路由文件路由到相关组件并将其渲染到 router-view 中</li>
<li>router-view 加载 Layout 文件<br>
Vue 内部页面的执行顺序：</li>
<li>将模板编译为 render 函数</li>
<li>实例挂载，根据根节点 render 函数调用，递归生成虚拟 DOM</li>
<li>将虚拟 DOM 转化为真实 DOM</li>
<li>组件内 data 发生变化，组件重新调用 render 函数生成虚拟 DOM，返回步骤 3</li>
</ol>
<p><strong>render</strong><br>
渲染函数，返回值是 VNode 虚拟节点，使用 render 函数允许使用 js 构建 DOM<br>
createElement 是 render 的参数，也是一个函数，用于构建虚拟 DOM，该函数简写 h</p>
<p><strong>$ 的作用</strong><br>
用于区分 Vue 中自带的实例和用户自定义的属性，有 $ 前缀的是自带的</p>
<p><strong>this</strong><br>
Vue 中会定义很多函数或变量，往往需要在 template 或 script 标签中使用：</p>
<ul>
<li>在 template 中不需要 this</li>
<li>在 script 标签中需要 this（除了在 watch 监听中）</li>
</ul>
<h2 id="vue-指令">Vue 指令</h2>
<p>** v-text 与 v-html**<br>
相同点：均能够展示数据，单向绑定<br>
不同点：</p>
<ul>
<li>v-text 渲染纯文本，浏览器不对其进行 html 解析</li>
<li>v-html 输出 html，浏览器对其进行 html 解析</li>
</ul>
<p><strong>v-if 与 v-show</strong><br>
相同点：通过变量控制标签内容的显示或隐藏<br>
不同点：</p>
<ul>
<li>v-if 是动态地往 DOM 树中添加或删除元素，在初始条件为假则直接不渲染 DOM（惰性的），在条件切换时会对标签进行适当的创建和销毁</li>
<li>v-show 的本质是给 DOM 节点设置 display: none; 来控制隐藏，不论初始条件真假均会渲染DOM，只在初始化时加载一次</li>
</ul>
<p>可以看出 v-if 的开销要大于 v-show，因此前者适用于不频繁切换状态的情况，后者则适用于频繁切换的场景</p>
<p><strong>v-for</strong><br>
用于解决模板循环渲染的问题，还可以渲染 Object 对象</p>
<pre><code class="language-html">&lt;div v-for=&quot;(item, index) in list&quot;&gt;{{index}}{{item}}&lt;/div&gt;
&lt;div v-for=&quot;(val, key, index) in listObj&quot;&gt;{{index}}{{item}}&lt;/div&gt;
</code></pre>
<p>*注意：*v-for 和 v-if 不推荐一起使用，因为处于同一节点时 v-for 的优先级高于 v-if，就会在每一个 v-for 循环中重复运行 v-if，也就意味着即使渲染小部分也要遍历整个数组，造成不必要的计算，影响性能；在 vue3 中 v-if 的优先级高于 v-for 但会导致 v-if 无法访问 v-for 刚定义的变量，因此仍不推荐一起使用<br>
解决方法：使用 computed 属性将需要渲染的列表提前过滤后再给 v-for 渲染</p>
<pre><code class="language-js">computed: {
	activeUsers: function () {
		return this.users.filter( (user)=&gt; {
			return user.isShow;//返回isShow=true的项，添加到activeUsers数组
		})
	}
}
</code></pre>
<p><strong>v-on</strong><br>
监听事件，用来监听 DOM 事件来触发一些方法函数，简写 @</p>
<pre><code class="language-html">&lt;div id='app'&gt;
    &lt;!-- 鼠标点击事件 --&gt;
    &lt;button v-on:click=&quot;add&quot;&gt;加&lt;/button&gt;
    &lt;!-- 键盘输入enter --&gt;
    &lt;input v-model=&quot;username&quot; v-on:keyup.enter=&quot;login&quot; /&gt;
  &lt;/div&gt;
</code></pre>
<p><strong>v-bind</strong><br>
用于属性与变量的绑定</p>
<pre><code class="language-html">&lt;!-- src 属性 imageSrc 变量 --&gt;
&lt;img v-bind:src=&quot;imageSrc&quot;&gt;
&lt;!-- 简写 --&gt;
&lt;img :src=&quot;imageSrc&quot;&gt;
</code></pre>
<p><strong>v-model</strong><br>
语法糖：计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用<br>
双向绑定，可以结合输入框、复选框、单选框等实现动态地修改数据<br>
v-model 是一个语法糖，本质上包含两个操作：</p>
<ul>
<li>v-bind 绑定一个 value 属性</li>
<li>v-on 给当前元素绑定 input 事件</li>
</ul>
<p>v-model 的修饰符：</p>
<ul>
<li>v-model.lazy 接管 input 的事件监听事件，在用户输入时不会马上响应在展示层，只有确认改变时才显示</li>
<li>v-model.trim 去除首尾空格</li>
<li>v-model.trim 输入的字符串转化为数字</li>
</ul>
<p><strong>v-cloak</strong><br>
使用 v-cloak 设置的样式会在 vvue 实例编译完成后从绑定的 html 标签上移除<br>
可以有效防止页面加载的时候出现 vue 的变量名</p>
<pre><code class="language-css">[v-cloak] {
    display: none;
}
</code></pre>
<pre><code class="language-html">&lt;div id=&quot;app&quot; v-cloak&gt;
    {{msg}}
&lt;/div&gt;
</code></pre>
<p><strong>v-pre</strong><br>
跳过 vue 的编译，直接输出原始值</p>
<pre><code class="language-html">&lt;!-- 输出 {{msg}} --&gt;
&lt;div v-pre&gt;{{msg}}&lt;/div&gt;
</code></pre>
<h2 id="vue-全局-api">Vue 全局 API</h2>
<p><strong>Vue.extend</strong><br>
扩展实例构造器，往往和 $mount 配合使用，创建实例并挂载到元素上</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Vue.extend-扩展实例构造器&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- 实现了自定义纯标签的效果 --&gt;
    &lt;official&gt;&lt;/official&gt;
    &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        // 定义构造器
        var official = Vue.extend({
            template:&quot;&lt;p&gt;&lt;a target='_blank' :href='url'&gt;{{name}}&lt;/a&gt;&lt;/p&gt;&quot;,
            data:function(){
                return{
                    name:'AriesSK的博客',
                    url:'https://ariessk.github.io/'
                }
            }
        });
        // 生成实例并挂载到 official DOM 上
        new official().$mount('official');
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.directive</strong><br>
自定义指令，回调函数有三个参数：</p>
<ul>
<li>el 被绑定的 node 节点</li>
<li>binding 一个对象包含指令的信息</li>
<li>vnode Vue 编译生成的虚拟节点</li>
</ul>
<p>自定义指令的生命周期函数（钩子函数）：</p>
<ul>
<li>bind 只调用一次，第一次绑定元素被调用，初始化操作</li>
<li>inserted 被绑定元素插入了父节点</li>
<li>update 被绑定的元素模板更新时调用</li>
<li>componentUpdated 被绑定的元素模板完成一次生命周期</li>
<li>unbind 指令和被绑定元素解绑时调用</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.directive 自定义标签&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p v-color=&quot;setRed&quot;&gt;我要红&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
window.onload = function () {
    Vue.directive('color', function(el, binding, vnode){ // 这里的 color 指的是 v-color 的 color，表示指令名
      console.log('el', el) // &lt;p style=&quot;color: red;&quot;&gt;我要红&lt;/p&gt;
      el.style = &quot;color:&quot; + binding.value // binding.value 表示指令绑定的值，这里指 setRed
    });

    new Vue({
      el: '#app', // 根据属性绑定
      data:{
        setRed: 'red'
      }
    })
  }
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.set</strong><br>
全局操作，Vue 不允许在已创建的实例上动态添加新的根级响应式属性，但可以用 Vue.set 方法将响应式属性添加到嵌套的对象上<br>
下面的例子可以发现，data 的数据是数组或对象时，调用 change 虽然修改了 fruit 的值，但视图并不会更新（失去了getter/setter），而调用 Vue.set(target, key, value) 则会更新视图，说明它能够向响应式对象中添加属性，并确保这个新属性同样是响应式的，且触发视图更新</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.set 全局操作&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p v-for=&quot;item in fruit&quot;&gt;{{ item }}&lt;/p&gt;
    &lt;!-- v-on 的事件处理方法在 Vue 实例内的 methods 声明，也可以在实例外声明函数，前者不用加括号，后者需要 --&gt;
    &lt;button v-on:click=&quot;change&quot;&gt;变&lt;/button&gt;
    {{ fruit }}
  &lt;/div&gt;
  &lt;!-- onclick 事件不能调用 Vue 实例内的 methods --&gt;
  &lt;button onclick=&quot;add()&quot;&gt;外部添加&lt;/button&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  function add(){
    Vue.set(app.fruit, 1, 'melon');
  }
  var app = new Vue({
    el: '#app',
    data: {
      fruit: ['apple', 'banana', 'pear', 'grape']
    },
    methods: {
      change: function () {
        this.fruit[1] = 'melon'
        console.log(this.fruit) // ['apple', 'melon', 'pear', 'grape']
      }
    }
  })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.filter</strong><br>
全局过滤器，注意声明过滤器必须放在<strong>声明实例 app 之前</strong>，否则不被注入实例中<br>
过滤器可用在插值表达式 {{ message | filter}} 和 v-bind 中 v-bind:msg=&quot;message | filter&quot;</p>
<pre><code class="language-js">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Vue.filter 过滤器&lt;/title&gt;
  &lt;style&gt;
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id='app'&gt;
    &lt;p&gt;{{ count | sum }}&lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.10/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  Vue.filter(&quot;sum&quot;, function(value) { //声明 sum 过滤器
    return value + 4;
  });

  var app = new Vue({
    el: '#app',
    data: {
      count: 20
    },
  })
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Vue.nextTick</strong><br>
在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM<br>
应用场景：需要在视图更新之后，基于新的视图进行操作</p>
<h2 id="vue-生命周期函数">Vue 生命周期函数</h2>
<p>对于单页面开发模式，每个页面都可以理解为一个 Vue 组件，在它们的生命周期中，都有对应的钩子函数：</p>
<ul>
<li>beforeCreate 在组件创建之前</li>
<li>created 在组件创建之后，一般用于初始化一些固定数据</li>
<li>beforeMount 在 DOM 节点渲染之前</li>
<li>mounted 在 DOM 节点渲染完后除法，常通过 ajax 获取服务端的数据</li>
<li>beforeUpdate 数据更新时调用，适用于在更新之前访问现有的 DOM</li>
<li>updated DOM 已经更新，执行依赖于 DOM 的操作</li>
<li>activated 被 keep-alive 缓存的组件激活时调用</li>
<li>deactivated 被 keep-alive 缓存的组件停用时调用</li>
<li>beforeDestroy 实例销毁之前调用，这一步实例仍完全可用</li>
<li>destroyed 实例销毁后调用，一般用于销毁页面内创建的 setTimeout 等变量，防止内存泄漏</li>
</ul>
<h2 id="vue-router">Vue-Router</h2>
<p>Vue 官方提供的路由插件</p>
<p><strong>传统页面与单页面跳转的区别</strong></p>
<ul>
<li>传统页面：传统的开发模式，路由一般是由超链接（a 标签）来控制页面的跳转与切换，每次跳转需要刷新整个页面，体验上不如单页模式</li>
<li>单页面：Vue 的单页面是基于组件和路由的配合，所有的页面都可以视为组件，路由控制访问路径，每一个路径映射一个组件。单页模式中无法使用 a 标签进行路由跳转，因为单页模式本质上就只有一个 index.html 页面。所有的页面组件都放在打包好的 js 文件中，所以要使用 Vue-Router 的路由组件实现跳转</li>
</ul>
<p><strong>路由模式</strong><br>
Vue-Router 提供了三种路由模式：</p>
<ul>
<li>Hash 模式</li>
<li>History 模式</li>
<li>abstract 模式</li>
</ul>
<p><strong>Hash 模式</strong><br>
Vue-Router 的默认模式，特点是 URL 始终带着 #，它不会发起对服务端的请求，也不会重加载页面。浏览器的原生方法提供了一个监听事件 hashchange，它能监听到下面的改变：</p>
<ul>
<li>点击 a 标签改变 URL 地址</li>
<li>浏览器的前进后退行为</li>
<li>通过 window.location 方法改变地址栏</li>
</ul>
<p>当初始的 html 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架完成加载。由于 hashchange 不会被默认触发，因此需要在 DOMContentLoaded 被触发时执行一次 hashchange 监听方法要执行的函数 HashChange。之后在点击 a 标签改变 URL 地址时会触发 hashchange 事件，获取到 location.hash，执行的 HashChange 函数通过判断 location.hash 的值来匹配相应的组件，简易的实现如下：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Hash 模式&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    // 这两个事件名是确定的，函数名可以改
    window.addEventListener('DOMContentLoaded', Load);
    window.addEventListener('hashchange', HashChange);
    var routeView = null;
    function Load() {
        routeView = document.getElementById('route-view');
        HashChange();
    }
    function HashChange() {
        switch(location.hash) {
            case '#/page1':
                routeView.innerHTML = '我是page1';
                return;
            case '#/page2':
                routeView.innerHTML = '我是page2';
                return;
            default:
                routeView.innerHTML = '我是page1';
                return;
        }
    }
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>History 模式</strong><br>
使用 History 模式是使用 html5 的 history API实现路由的模式，表现是去除了 Hash 模式中 URL 的 #，使 URL 比较好看。控制路由会有一些麻烦，根本原因是使用 History 模式，popstate 监听事件无法监听到 pushState、replaceState(前者新建记录，后者修改记录)、a 标签三种形式的变化，可以监听到浏览器的前进和后退。<br>
为了实现路由，可以如下做：</p>
<ol>
<li>遍历页面上的所有 a 标签，阻止其默认事件，同时加上点击事件的回调函数，在回调函数中获取 a 标签的 href 属性值</li>
<li>通过 pushState 改变浏览器的 location.pathname 属性值为 a 标签的 href 属性值</li>
<li>手动执行 popstate 事件的回调函数，匹配相应的路由</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;History 模式&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;/page1&quot;&gt;page1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;/page2&quot;&gt;page2&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div id=&quot;route-view&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        window.addEventListener('DOMContentLoaded', Load);
        window.addEventListener('popstate', PopChange);
        var routeView = null;
        function Load() {
            routeView = document.getElementById('route-view');
            PopChange();
            // 获取所有带有 href 属性的 a 标签
            var aList = document.querySelectorAll('a[href]')
            // 遍历标签，添加点击事件的回调函数，参数 e 代表当前事件
            aList.forEach(aNode =&gt; aNode.addEventListener('click', function(e) {
                // 阻止默认事件
                e.preventDefault();
                // 获取 href 属性值
                var href = aNode.getAttribute('href');
                // pushState(state, title. url)，state 对象不需要可填 null，title 表示新页面的标题，url 是新页面的网址
                //这个方法的作用就是在 history 对象中添加记录，同时改变地址栏为新的 url
                history.pushState(null, &quot;&quot;, href);
                // 因为 popstate 监听不到地址栏的变化，所以需要手动执行 PopChange
                PopChange();
            }));
        }
        function PopChange() {
            switch(location.pathname) {
                case '/page1' :
                    routeView.innerHTML = '我是page1';
                    return;
                case '/page2' :
                    routeView.innerHTML = '我是page2';
                    return;
                default :
                    routeView.innerHTML = '我是page1';
                    return;
            }
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>history 模式相对于 hash 模式没有 #，比较符合开发习惯，也比较好看，但由于是 html5 新出的 api，所以不想 hash 模式可以兼容低版本。并且 history 在访问二级页面的时候刷新网页会出现 404 错误，这是因为刷新网页相当于向服务端发送了一次 GET 请求，而服务端并没有定义这样的接口，所以 history 模式需要服务端配合进行路由处理，比如重定向回首页路由</p>
<p><strong>abstract 模式</strong><br>
针对没有浏览器环境的情况，没有浏览器的 API，就会强制切换到 abstract 模式（比如 Weex）<br>
如果在 Vue-Router 的配置项中不填写 mode 的值，则在浏览器环境下默认 Hash 模式，移动客户端环境下使用 abstract 模式</p>
<p><strong>引入与使用</strong></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;!-- 引入静态资源 --&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.1.3/vue-router.min.js&quot;&gt;&lt;/script&gt;
  &lt;title&gt;Vue Router&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;ul&gt;
      &lt;!-- 使用 router-link 组件来导航. --&gt;
      &lt;!-- 通过传入 to 属性指定链接. --&gt;
      &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 &lt;a&gt; 标签 --&gt;
      &lt;router-link to=&quot;/page1&quot;&gt;Go to Page1&lt;/router-link&gt;
      &lt;br/&gt;
      &lt;router-link to=&quot;/page2&quot;&gt;Go to Page2&lt;/router-link&gt;
    &lt;/ul&gt;
    &lt;!-- 路由匹配到的组件将渲染在&lt;router-view&gt; --&gt;
    &lt;router-view&gt;&lt;/router-view&gt;
  &lt;/div&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    // 1. 定义 (路由) 组件
    // 可以从其他文件 import 进来，这里简单写
    const Page1 = { template: '&lt;div&gt;Page1&lt;/div&gt;' }
    const Page2 = { template: '&lt;div&gt;Page2&lt;/div&gt;' }
    // 2. 定义路由
    // 每个路由应该映射一个组件，其中 component 可以是通过 Vue.extend() 创建的组件构造器，或者只是一个组件配置对象
    const routes = [
      { path: '/page1', component: Page1 },
      { path: '/page2', component: Page2 }
    ]
    // 3. 创建 router 实例，然后传 routes 配置
    const router = new VueRouter({
      routes: routes
    })
    // 4. 创建和挂载根实例
    // 要通过 router 配置参数注入路由，从而让整个应用都有路由功能
    const app = new Vue({
      router: router
    }).$mount('#app')
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>获取全局路由跳转参数的变化</strong><br>
同一在入口页面通过 watch $route 对象实现，在上面代码的基础上修改，可以拿到 to 和 from 两个参数，to 代表跳转后的页面参数，from 代表从那个页面跳转来的，通过这两个参数就能够设置一级二级页面，制作过场动画</p>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot;&gt;
const app = new Vue({
      router: router,
      watch: {
          // $ 前缀是让让系统的属性与用户定义的属性区分开来
        $route(to, from) {
            console.log('to', to);
            console.log('form', from);
        }
      }
    }).$mount('#app')
&lt;/script&gt;
</code></pre>
<p><strong>路由传参</strong><br>
Page1 跳转到 Page2，Page1通过 <router-link> 传参：</p>
<pre><code class="language-html">&lt;!-- 注意 to 前面需要加 : 即使用了 v-bind --&gt;
&lt;router-link :to=&quot;{path: '/page1', query: { id: 123 }}&quot;&gt;Go to Page1&lt;/router-link&gt;
</code></pre>
<p>接收参数：</p>
<pre><code class="language-js">const Page1 = { template: '&lt;div&gt;Page1 {{ $route.query.id }}&lt;/div&gt;'}
</code></pre>
<p>还有另一种方式：</p>
<pre><code class="language-html">&lt;!-- 注意 to 前面需要加 : 即使用了 v-bind --&gt;
&lt;router-link :to=&quot;{path: '/page1/123'}&quot;&gt;Go to Page1&lt;/router-link&gt;
</code></pre>
<pre><code class="language-js">// 这里不是 query 而是 params
const Page1 = { template: '&lt;div&gt;Page1 {{ $route.params.id }}&lt;/div&gt;'}
// 还需要修改 routes
const routes = [
    { path: 'page1/:id', component: Page1 },
    { path: '/page2', component: Page2 }
]
</code></pre>
<p><strong>重定向页面</strong><br>
输入一个不存在的路由，Vue-Router 就会无法匹配到，这时候应当默认返回首页，就需要用到重定向匹配，在 * 上面的路径都没被匹配到时，重定向至 /page1 对应的组件</p>
<pre><code class="language-js">const routes = [
    { path: '/page1', component: Page1 },
    { path: '/page2', component: Page2 },
    {path: '*', redirect: '/page1'}
]
</code></pre>
<h2 id="vuex">Vuex</h2>
<p>Vuex 是一个专门为 Vue 开发的状态管理模式，集中式存储管理应用的所有组件的状态<br>
是用于管理 Vue 应用跨组件数据的工具</p>
<p><strong>Vuex 与 localStorage、sessionStorage</strong><br>
虽然 localStorage 存储时限长，但比较适合存一些不怎么变化的数据，在 Vue 中不同组件共用的数据，组件需要响应另一个组件对数据的修改，就需要 Vuex</p>
<ul>
<li>Vuex：存储在浏览器内存，集中式存储管理应用的所有组件的状态，不刷新页面则状态会一直保持，刷新网页则状态重置</li>
<li>sessionStorage：会话型存储，用于保存同一窗口或标签页的数据，数据保存在浏览器本地，关闭窗口或标签页后删除数据，就像人之间的会话，人走了会话就结束了</li>
<li>localStorage：持久性存储，与 sessionStorage 类似，不过可以一直存储数据在浏览器本地，直到主动清除或重装浏览器</li>
</ul>
<p><strong>单向数据流</strong><br>
根据一定规则改变数据，数据触发视图的更新，通过视图中的方法触发数据的更新的闭环<br>
<img src="https://AriesSK.github.io/post-images/1657809170855.png" alt="" loading="lazy"><br>
但实际应用中往往有多组件共享状态，这样不同视图的行为需要变更同一个状态，这就破坏了单向数据流<br>
这些复杂的应用场景就需要依靠 Vuex 来解决<br>
<img src="https://AriesSK.github.io/post-images/1657809816279.png" alt="" loading="lazy"><br>
虚线框中的部分就是 Vuex 生效的部分，Vue 组件通过 Dispatch 关键字触发 Actions，再通过 Commit 调用 Mutation 里的方法修改 State 数据，组件中如果有依赖 Store 里的数据，就触发 Render 重绘，形成了一个闭环</p>
<p><strong>State</strong><br>
所有状态都被存放在 State 中，类似 Vue 组件中的 data 属性，State 面向整个应用，data 针对单个组件。在 Vue 入口页构造 Vue 实例的时候引入 store，就可以在组件中通过 this.$store.state 拿到</p>
<p><strong>Getter</strong><br>
类似于 Vue 组件中的 computed 属性，计算一些需要二次改造的数据，比如使用 filter 过滤，可以在 store 中定义 getter 属性，state 数据作为参数传入：</p>
<pre><code class="language-js">const store = new Vuex.Store({
    state: {
        todos: [
            { id: 1, text: '...', done: true },
            { id: 2, text: '...', done: false }
        ]
    },
    getters: {
        doneTodos: state =&gt; {
            return state.todos.filter(todo =&gt; todo.done);
        },
        // 还可以接收其他 getters 作为参数
        doneTodesCount: (state, getters) =&gt; {
            return getters.doneTodos.length; // 1
        }
    }
})
</code></pre>
<p>在组件中通过如下访问：</p>
<pre><code class="language-js">this.$store.getters.doneTodos; // [{ id: 1, text: '...', done: true }]
</code></pre>
<p><strong>Mutation</strong><br>
修改 State 状态需要触发一些方法，这些方法放在 mutations 属性中，mutations 属性中的方法能够接收两个参数，第一个是 state，包含所有的状态值；第二个是提交载荷 Payload，在外部通过 store.commit 方法触发 mutations 时额外带入的值：</p>
<pre><code class="language-js">const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment (state) {
            state.count++;
        }
    }
})
store.commit('increment'); // 无载荷触发

const store = new Vuex.Store({
    state: {
        count: 1
    },
    mutations: {
        increment (state, n) {
            state.count += n;
        }
    }
})
store.commit('increment', 10); // 带载荷触发
</code></pre>
<p><strong>Action</strong><br>
与 Mutation 类似，不过 Action 是提交 mutation 而不是直接修改 State。Action 有异步的能力，能够在请求异步数据后再触发状态的更新：</p>
<pre><code class="language-js">const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state, data) {
      state.count += data.length;
    }
  },
  actions: {
    // 定义一个异步函数，等待 getData 获值后继续执行 commit
    async increment (ctx) {
      const data = await getData();
      ctx.commit('increment', data);
    }
  }
})
store.dispatch('increment'); // 分发 Action
</code></pre>
<p><strong>Module</strong><br>
给状态分模块管理：</p>
<pre><code class="language-js">// 模块 A 的状态及触发更新的方法
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}           
// 模块 B 的状态及触发更新的方法
const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}
// modules 方法可以将 store 分割成模块，每个模块可以定义自己的 state、getter、mutation、action
const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})
store.state.a // moduleA 的状态
store.state.b // moduleB 的状态
</code></pre>
<p><strong>实例</strong><br>
引入静态资源时，Vuex 要在 Vue 的<strong>后面</strong>，否则会报错，这是因为 Vuex 内部依赖 Vue<br>
通过 Vuex.Store 生成实例建议使用<code>strict: true</code>严格模式，减少代码紊乱<br>
使用 Mutation 直接修改状态：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.3/vuex.min.js&quot;&gt;&lt;/script&gt;
  &lt;title&gt;Vuex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;div&gt;{{ $store.state.count }}&lt;/div&gt;
    &lt;button @click=&quot;add&quot;&gt;加1&lt;/button&gt;
    &lt;button @click=&quot;dec&quot;&gt;减1&lt;/button&gt;
  &lt;div&gt;
  &lt;script&gt;
    const store = new Vuex.Store({
      state: {
        count: 0
      },
      // 开启严格模式，开启严格模式后，必须通过 mutation 来修改状态。
      strict: true,
      // 触发 state 中的 count 加减运算的方法
      mutations: {
        add(state) {
          state.count += 1
        },
        dec(state) {
          state.count -= 1
        }
      },
      getters: {
        // 过滤偶数的 getter，没用到
        filterEven: state =&gt; {
          return !(state.count % 2)
        }
      }
    })
    const app = new Vue({
      el: '#app',
      store, // 将 Vuex 生成的实例作为 Vue 生成实例的参数
      data: {
        message: 'Hello Vue!'
      },
      methods: {
        add() {
          this.$store.commit('add')
        },
        dec() {
          this.$store.commit('dec')
        }
      }
    }).$mount('#app');
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>使用 Action 异步改变状态：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vue/2.6.11/vue.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.bootcss.com/vuex/3.1.3/vuex.min.js&quot;&gt;&lt;/script&gt;
  &lt;title&gt;Vuex&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;div&gt;{{ $store.state.count }}&lt;/div&gt;
    &lt;button @click=&quot;asyncAdd&quot;&gt;异步加1&lt;/button&gt;
    &lt;button @click=&quot;asyncDec&quot;&gt;异步减1&lt;/button&gt;
  &lt;div&gt;
  &lt;script&gt;
    // 模拟请求数据，延迟 2 秒返回数据
    function AsyncData() {
        // Promise.resolve(x) 用于将字面量或对象封装成 Promise 实例
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          resolve(1)
        }, 2000)
      })
    }

    const store = new Vuex.Store({
      state: {
        count: 0
      },
      // 开启严格模式，开启严格模式后,必须通过 mutation 来修改状态
      strict: true,
      mutations: {
        add(state, num) {
          state.count += num
        },
        dec(state, num) {
          state.count -= num
        }
      },
      actions: {
        // async await 异步获取
        // async 函数返回一个 Promise 对象
        // 参数 ctx 是 context 的缩写，代表着上下文
        async add(ctx) {
            // await 是个运算符，await 表达式的结果取决于后面的内容
            // 如果后面不是 Promise 对象，则表达式结果就是后面的内容
            // 如果后面是 Promise 对象，则阻塞后面的代码，等待 Promise 对象 resolve，得到其值作为表达式的结果
            // AsyncData() 返回一个 Promise 对象，因此 await 会等待
          const num = await AsyncData()
          ctx.commit('add', num)
        },
        async dec(ctx) {
          const num = await AsyncData()
          ctx.commit('dec', num)
        }
      },
      getters: {
        filterOdd: state =&gt; {
          return !(state.count % 2)
        }
      }
    })
    const app = new Vue({
      el: '#app',
      store,
      data: {
        message: 'Hello Vue!'
      },
      methods: {
        asyncAdd() {
            // 注意使用 Action 调用的是 dispatch
          this.$store.dispatch('add')
        },
        asyncDec() {
          this.$store.dispatch('dec')
        }
      }
    }).$mount('#app');
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>不是所有项目都要用 Vuex，对于小型的项目反而会使项目变得繁琐</p>
<h2 id="前端鉴权">前端鉴权</h2>
<p>前端鉴权，处理用户的鉴权信息的两种方式：<br>
<strong>cookie</strong><br>
cookie 用于存储变量，在前端请求网络资源或者后端接口时，请求头 Header 里都会带上当前域下的 cookie 信息，服务端通过检测请求头内的 cookie 判断当前用户的登录状态是否过期（或者 cookie是否错误），来判断当前用户能否成功地返回响应<br>
<strong>token</strong><br>
token 是服务器生成的一串随机字符串或 json 串，作为客户端进行资源请求的令牌。调用登录接口后，服务端返回给前端一个 token，之后将 token 存储到本地环境，每次前端请求接口的时候，都需要在请求头里带上 token 信息，并且 token 还可以在服务端设置过期时间，过期后返回前后端商量好的错误码，跳转到登录节点重新鉴权</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Less]]></title>
        <id>https://AriesSK.github.io/post/less/</id>
        <link href="https://AriesSK.github.io/post/less/">
        </link>
        <updated>2022-12-31T05:02:58.000Z</updated>
        <content type="html"><![CDATA[<p>Less 是一门 CSS 预处理语言，扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展，简单来说就是能够提取大量的重复代码，使 CSS 更加规范。</p>
<p><strong>注释</strong><br>
单行 //<br>
多行 /**/</p>
<p><strong>变量</strong><br>
使用 @ 声明变量，同名变量后面的会覆盖前面的</p>
<pre><code class="language-less">@primary: red;

.box {
    color: @primary;
}
</code></pre>
<p><strong>嵌套</strong><br>
CSS 的预编译器嵌套规则大同小异：</p>
<pre><code class="language-less">.a {
    color: #fff;
    .b {
        width: 20px;
    }
}
</code></pre>
<p>编译后如下：</p>
<pre><code class="language-css">.a {
    color: #fff;
}
.a .b {
    width: 20px;
}
</code></pre>
<p>同级场景使用 &amp; 的情况，&amp; 表示当前节点的 CSS 样式，一般用于处理 CSS 样式的状态 hover、focus、active、link、visited等：</p>
<pre><code class="language-less">.a {
    color: blue;
    &amp;:hover {
        color: red;
    }
}
</code></pre>
<p><strong>混合（Mixin）</strong><br>
Less 的混合有三种情况：</p>
<ul>
<li>不带参数，调用时可以不加括号，直接使用</li>
</ul>
<pre><code class="language-less">.center {
    text-align: center;
}
.red {
    color: red;
}

.box {
    .one {
        .center;
        .red;
    }
}
</code></pre>
<ul>
<li>带参数，没有默认值，调用需要加括号，并且括号中必须要传值</li>
</ul>
<pre><code class="language-less">.center {
    text-align: center;
}
.color(@c) {
    color: @c;
}

.box {
    .one {
        .center;
        .color(green);
    }
}
</code></pre>
<ul>
<li>带参数，有设置默认值，调用时要加括号，可以不传参数</li>
</ul>
<pre><code class="language-less">.center {
    text-align: center;
}
.color(@c: red) {
    color: @c;
}

.box {
    .one {
        .center;
        .color;
    }
}
</code></pre>
<p><strong>运算</strong><br>
+ - * / 可以对任何数字、颜色或变量运算，运算前会进行单位的换算，计算结果以最左侧的单位为准，如果单位无效或失去意义则忽略单位</p>
<p><strong>转义字符</strong><br>
Less 的转义字符为 ~&quot;&quot; 比如<code>~&quot;\&quot;</code></p>
<p><strong>作用域</strong><br>
现在当前作用域内查询，找不到则继续向上一级查询，类似 js</p>
<p><strong>导入</strong><br>
Less 文件可以使用 @import 引入另一个 Less 文件，并且还可以使用里面的变量，比如<code>@import './style.less'</code></p>
<p><strong>应用实例</strong><br>
实例一：画四种方向的三角形<br>
可以使用通用匹配模式 @_ 无论同名的哪一个混合被匹配到，都要先执行通用匹配模式的代码</p>
<pre><code class="language-less">// 通用匹配模式 下面四种方向的三角形都会先执行该代码
.triangle(@_, @width, @color) {
    width: 0;
    height: 0;
    border-style: solid;
}
.triangle(Bottom, @width, @color) {
    border-width: @width;
    border-color: @color transparent transparent transparent;
}
.triangle(Left, @width, @color) {
    border-width: @width;
    border-color: transparent @color transparent transparent;
}
.triangle(Top, @width, @color) {
    border-width: @width;
    border-color: transparent transparent @color transparent;
}
.triangle(Right, @width, @color) {
    border-width: @width;
    border-color: transparent transparent transparent @color;
}
// 使用左箭头
.box {
    .triangle(Left, 100px, red);
}
</code></pre>
<p>这种方式画三角形是利用了 border 可以分别设置四边的属性，当 width 和 height 为 0，整个可见区就由 broder 填满，调整 border-width 可以改变三角形的大小，设置一边的颜色并将另外三边设为透明则可以出现三角形的效果（四分之一的矩形）<br>
<strong>@arguments</strong> 能够替代 mixin 的所有参数</p>
<pre><code class="language-less">.border(@width, @mode, @color) {
    border: @arguments;
}
.one{
    .border(1px, solid, red)
}
</code></pre>
<p>实例二：文字垂直居中<br>
由于将行高 line-height 和 height 设置成相同就能够让标签内的文字垂直居中，因此比较常用，就可以把它封装起来</p>
<pre><code class="language-less">.line-text-h (@h: 0) {
    height: @h;
    line-height: @h;
}

.box {
    .text {
        .line-height-h(100px);
        background: grey;
        width: 200px;
    }
}
</code></pre>
<p>实例三：定位上下左右居中<br>
绝对定位相对于已定位的父元素，相对定位相对于元素在文档中的初始位置</p>
<pre><code class="language-less">.center {
    // 设置绝对定位
    position: absolute;
    // 设置使元素左上顶点位于中心位置
    top: 50%;
    left: 50%;
    // 向上和向左平移自身一半的高和宽，使元素中心点位于中心位置
    transform: translate(-50%, -50%);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML + CSS]]></title>
        <id>https://AriesSK.github.io/post/html-css/</id>
        <link href="https://AriesSK.github.io/post/html-css/">
        </link>
        <updated>2022-12-24T07:00:39.000Z</updated>
        <content type="html"><![CDATA[<p><strong>操作快捷键</strong><br>
Ctrl + Enter 换行，不改变光标后面代码<br>
Alt + Shift + up/down 在上一行/下一行复制该行<br>
选中词后 Ctrl + D，向下一次选择相同的词</p>
<h2 id="网页">网页</h2>
<p><strong>C/S和B/S</strong><br>
C/S：Client/Sever<br>
B/S：Browser/Sever</p>
<p><strong>网页三要素：结构、表现、行为</strong><br>
结构：HTML用于描述页面的结构<br>
表现：CSS用于控制页面中元素的样式<br>
行为：JavaScript用于响应用户操作</p>
<hr>
<h2 id="html">HTML</h2>
<p><strong>超文本标记语言（Hypertext Markup Language, HTML)</strong><br>
超文本指的是使用超链接的方法，将不同空间的文字信息组织在一起的网状文本</p>
<pre><code class="language-html">&lt;!--HTML的注释--&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>标签一般成对出现，单个出现的称为<strong>自结束标签</strong></p>
<p><strong>标签的属性</strong><br>
在开始标签或字节数标签中可以设置标签的属性，属性是一个名值对，属性应当根据文档中的规定编写，有些属性没有属性值</p>
<pre><code class="language-html">&lt;font color=&quot;red&quot;&gt;红色&lt;/font&gt;
</code></pre>
<p><strong>文档声明（DOCTYPE）</strong><br>
html5的文档声明：</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
</code></pre>
<p><strong>二进制与十六进制</strong><br>
二进制作为计算机底层的进制使用，而一般显示二进制数使，会转换为十六进制</p>
<p><strong>字符编码</strong><br>
字符集（charset）是编码和解码所从用的规则<br>
若编码和解码使用的字符集不同，则会出现乱码问题<br>
UTF-8 万国码 开发时使用</p>
<pre><code class="language-html">&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>实体</strong><br>
在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格<br>
使用实体（转义字符） <code>&amp;实体的名字;</code><br>
空格<code>&amp;nbsp;</code> 大于<code>&amp;gt;</code> 小于<code>&amp;lt;</code> 版权符<code>&amp;copy;</code></p>
<p><strong>meta标签</strong><br>
charset 指定网页的字符集<br>
name 指定的数据的名称<br>
content 指定的数据的内容</p>
<pre><code class="language-html">&lt;!-- title 标签的内容会作为搜索引擎超链接上的文字显示 --&gt;
&lt;!-- keywords 表示网站的关键字 搜索时的关键词 --&gt;
&lt;meta name=&quot;keywords&quot; content=&quot;HTML5,CSS3&quot;&gt;
&lt;!-- description 表示网站的描述 会显示在搜索引擎的搜索结果中 --&gt;
&lt;meta name=&quot;description&quot; content=&quot;这是一个网站&quot;&gt;
&lt;!-- refresh 将网页重定向到另一个网站 --&gt;
&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3;url=https://ariessk.github.io&quot;&gt;
</code></pre>
<p>###语义化标签<br>
<strong>HTML负责网页的结构</strong><br>
在使用html标签时，应该关注的是标签的语义，而不是样式</p>
<p><strong>块元素</strong><br>
在页面中独占一行的元素称为块元素（block element） 网页布局主要用块元素 块元素内能放块元素和行内元素 但<code>&lt;p&gt;</code>元素内能放块元素<br>
<code>&lt;h1&gt;</code> h1~h6 h1最重要 仅次于title 一般一个页面只有一个h1 一般只会用h1~h3<br>
相关的标题可以放标题组里</p>
<pre><code class="language-html">&lt;hgroup&gt;
    &lt;h1&gt;&lt;/h1&gt;
    &lt;h2&gt;&lt;/h2&gt;
&lt;/hgroup&gt;
</code></pre>
<p><code>&lt;p&gt;&lt;/p&gt;</code>段落<br>
<code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>表长引用<br>
<code>&lt;br&gt;</code>换行</p>
<p><strong>行内元素</strong><br>
在页面中不会独占一行的元素称为行内元素（inline element） 主要用于包裹元素<br>
<code>&lt;em&gt;&lt;/em&gt;</code>表示语音语调的加重<br>
<code>&lt;strong&gt;&lt;/strong&gt;</code>表强调<br>
<code>&lt;q&gt;&lt;/q&gt;</code>短引用<br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code> 超链接</p>
<p><strong>浏览器修正</strong><br>
浏览器在解析网页时，会对网页中不符合规范的内容进行修正 标签卸载了根元素<code>&lt;html&gt;</code>外面</p>
<p><strong>网页主体</strong></p>
<pre><code class="language-html">&lt;body&gt;
    &lt;header&gt;&lt;/header&gt;
    &lt;main&gt;&lt;/main&gt;
    &lt;footer&gt;&lt;/footer&gt;
    &lt;!-- 导航 --&gt;
    &lt;nav&gt;&lt;/nav&gt;
    &lt;!-- 与主体相关的内容（侧边栏） --&gt;
    &lt;aside&gt;&lt;/aside&gt;
    &lt;!-- 文章--&gt;
    &lt;article&gt;&lt;/article&gt;

&lt;/body&gt;
</code></pre>
<p><strong>列表</strong><br>
列表之间可以互相嵌套<br>
无序列表</p>
<pre><code class="language-html">&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>有序列表</p>
<pre><code class="language-html">&lt;ol&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</code></pre>
<p>定义列表，dt表示定义的内容，dd对内容进行解释说明</p>
<pre><code class="language-html">&lt;dl&gt;
    &lt;dt&gt;&lt;/dt&gt;
    &lt;dd&gt;&lt;/dd&gt;
&lt;/dl&gt;
</code></pre>
<p><strong>超链接</strong><br>
<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>能够嵌套除它自身的任何元素<br>
目标路径可以是<strong>外部网站</strong>或<strong>内部页面</strong><br>
内部页面通常使用<strong>相对路径</strong>：<code>./</code>表示当前文件所在的目录（可省略），<code>../</code>表示上一级目录</p>
<pre><code class="language-html">&lt;!-- 当前页面打开与新的页面打开 --&gt;
&lt;a href=&quot;&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;
&lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;
</code></pre>
<p><strong>id 属性</strong><br>
通过超链接到页面中的特定位置，要使用 id 属性<br>
id 属性是唯一不重复的，每个标签可以添加一个 id 属性</p>
<pre><code class="language-html">&lt;!-- 回到顶部 --&gt;
&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;
&lt;!-- 回到 id 为bottom的标签处 --&gt;
&lt;a href=&quot;#bottom&quot;&gt;&lt;/a&gt;
&lt;!--未设置是可以用 javascript:; 占位 点击无反应 --&gt;
&lt;a href=&quot;javascript:;&quot;&gt;1&lt;/a&gt;
</code></pre>
<p><strong>图片标签</strong><br>
用于引入外部图片<br>
<code>&lt;img width=&quot;&quot; height=&quot;&quot; src=&quot;&quot; alt=&quot;&quot;&gt;</code> 自结束标签 替换元素<br>
alt 是图片的描述，有些浏览器会在图片无法加载时显示，搜索引擎会根据 alt 中的内容来识别图片<br>
width height 只修改其中一个会等比例缩小<br>
一般在 pc 端不建议修改图片的大小，而在移动端经常需要缩放图片（主要是大图缩小确保清晰度）<br>
<strong>图片格式</strong><br>
jpeg(jpg) 支持颜色比较丰富，不支持透明效果，不支持动图，一般显示照片<br>
gif 支持颜色比较少，支持简单透明，支持动图，一般显示动图<br>
png 支持颜色丰富，支持复杂透明，不支持动图，专为网页而生<br>
webp 谷歌推出的专门用来表示网页中的图片的一种格式，具备其他图片的所有优点，并且文件特别小，但<strong>兼容性不好</strong><br>
base64 将图片使用base64编码，将土拍你转换为字符，通过字符的形式来引入图片，一般用于需要和网页一起加载的图片</p>
<p><strong>内联框架</strong><br>
用于向当前页面中引入一个其他页面<br>
<code>&lt;iframe src=&quot;&quot; width=&quot;&quot; height=&quot;&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</code><br>
frameborder 指定内联框架的边框，0无1有</p>
<p><strong>音视频</strong><br>
<code>&lt;audio src=&quot;&quot; controls autoplay loop&gt;&lt;/audio&gt;</code>controls 是否允许用户控制播放，autoplay 自动播放，但大部分浏览器不会自动播放，loop循环播放，都是无值的属性<br>
下面这种写法能够解决<strong>浏览器不兼容</strong>的问题，不支持<code>&lt;audio&gt;</code>则显示文字，第一个音频无法播放则播放第二个<code>&lt;emobed&gt;</code>支持比较低的浏览器版本，需要设置文件类型以及宽和高，且比较丑。</p>
<pre><code class="language-html">&lt;audio controls&gt;
        &lt;!-- 文字和 embed 二选一即可 --&gt;
        对不起，您的浏览器不支持播放音频，请升级浏览器！
        &lt;source src=&quot;audio.mp3&quot;&gt;
        &lt;source src=&quot;audio.ogg&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;audio/mp3&quot; width=&quot;&quot; height=&quot;&quot;&gt;
    &lt;/audio&gt;
</code></pre>
<p>video 与 audio 使用方法基本相同</p>
<pre><code class="language-html">&lt;video controls&gt;
        &lt;source src=&quot;video.webm&quot;&gt;
        &lt;source src=&quot;video.mp4&quot;&gt;
        &lt;embed src=&quot;&quot; type=&quot;video/mp4&quot; width=&quot;&quot; height=&quot;&quot;&gt;
&lt;/video&gt;
</code></pre>
<h2 id="css">CSS</h2>
<p>层叠样式表<br>
网页实际上是一个多层的结构，通过css可以分别为网页的每一层来设置样式，而最终我们能看到的是最上边的一层</p>
<p><strong>使用 css 修改元素样式</strong><br>
法一：内联样式、行内样式<br>
在标签内部通过 style 属性来设置元素的样式，只能对一个标签生效，修改很麻烦（不推荐使用）<br>
<code>&lt;p style=&quot;color: red; font-size: 60px;&quot;&gt;</code><br>
法二：内部样式表<br>
将样式编写到 head 中的 style 标签里，同时设置多个标签，方便修改和复用，但只能对一个网页使用</p>
<pre><code class="language-html">&lt;style&gt;
    p{
        color: red;
        font-size: 60px
    }
&lt;/style&gt;
</code></pre>
<p>法三：外部样式表<br>
将样式编写到外部的 css 文件中，然后在页面中通过 link 标签引入外部的 css 文件，方便多网页复用（最佳），多个网页引用同一个 css 时能够使用到浏览器的缓存机制，加块网站加载速度，提高用户体验</p>
<pre><code class="language-css">p{
    color: red;
    font-size: 60px;
}
</code></pre>
<pre><code class="language-html">&lt;head&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;
&lt;/head&gt;
</code></pre>
<p><strong>css 语法</strong><br>
选择器，选择页面中的指定元素<br>
声明块，为指定元素设置样式，声明是名值对结构，名和值以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 连接，以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mpunct">;</span></span></span></span> 结尾</p>
<h3 id="选择器">选择器</h3>
<p>常用选择器：</p>
<ul>
<li>元素选择器，根据标签名选定元素，<code>标签名{}</code></li>
<li>id 选择器，根据元素 id 选中元素，<code>#id属性值{}</code></li>
<li>类选择器，根据元素 class 选中元素，<code>.class值{}</code>，class 和 id 类似，但 class 可重复使用，可以为一个元素指定多个 class，多个 class 之间使用<strong>空格</strong>分隔</li>
<li>通配选择器，选中页面中的所有元素，<code>*{}</code></li>
</ul>
<p>复合选择器：</p>
<ul>
<li>交集选择器，选中同时复合多个条件的元素，<code>选择器1选择2选择器3{}</code>，有元素选择器则必须以<strong>元素选择器开头</strong></li>
<li>选择器分组（并集选择器），同时选择多个选择器对于的元素，<code>选择器1,选择2,选择器3{}</code></li>
</ul>
<p>关系选择器：<br>
父元素：直接包含子元素的元素<br>
祖先元素：直接或间接包含后代元素的元素，父元素也是祖先元素<br>
兄弟元素：拥有相同父元素的元素</p>
<ul>
<li>子元素选择器，选中父元素的指定子元素，<code>父元素 &gt; 子元素{}</code></li>
<li>后代元素选择器，选中祖先元素内的指定后代元素，<code>祖先元素 后代元素{}</code></li>
<li>兄弟选择器，选择下一个兄弟，<code>前一个 + 后一个{}</code>，需要<strong>直接相邻</strong>；选择下边所有兄弟，<code>兄 ~ 弟{}</code></li>
</ul>
<p>属性选择器：</p>
<ul>
<li>选择含有指定属性的元素，<code>[属性名]{}</code>，<code>*[属性名]{}</code>表示所有拥有该属性的标签(* 可省略)，<code>标签名[属性名]{}</code>表示拥有该属性的指定标签，比如<code>a[href]{}</code></li>
<li>选择含有指定属性和属性值的元素，<code>[属性名=属性值]{}</code></li>
<li>选择属性值以指定值开头的元素，<code>[属性名^=属性值]{}</code></li>
<li>选择属性值以指定值结尾的元素，<code>[属性名$=属性值]{}</code></li>
<li>选择属性值中含有指定值的元素，<code>[属性名*=属性值]{}</code></li>
</ul>
<p>伪类选择器：<br>
伪类，特殊的类，用来描述一个元素的特殊状态，比如：第一个元素、被点击的元素、鼠标移入的元素<br>
伪类一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo></mrow><annotation encoding="application/x-tex">:</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>:first-child</code>，第一个子元素</li>
<li><code>:last-child</code>，最后一个子元素</li>
<li><code>:nth-child()</code>，第 n 个子元素，括号内可填值表示第几个，其中有特殊值：n 表示选中所有（0~正无穷）；2n 或 even 表示选中偶数位的元素；2n+1 或 odd 表示奇数位的元素</li>
</ul>
<p>上述的伪类均根据<strong>所有的子元素</strong>进行排序</p>
<ul>
<li><code>:first-of-type</code></li>
<li><code>:last-of-type</code></li>
<li><code>:nth-of-type()</code></li>
</ul>
<p>上述这三个与前面的功能类似，但是是在<strong>相同元素</strong>中进行排序</p>
<ul>
<li><code>:not()</code>，否定选择器，将复合条件的元素从选择器中去除，比如``ul &gt; li:not(:nth-of-type(1)){}`是排除第一个</li>
</ul>
<p>超链接的伪类：<br>
其执行顺序是 <strong>LoVeHAte</strong>，原因如下：</p>
<ul>
<li>未访问的链接（正常的链接），<code>a:link</code>，专属于超链接标签，无操作便具有<code>:link</code>状态</li>
<li>访问过的链接，<code>a:visited</code>，由于隐私的原因，这个伪类只能修改颜色，专属于超链接标签，访问后具备<code>:link</code>和<code>:visited</code>两种状态</li>
<li>鼠标移入的状态，<code>:hover</code>，鼠标移入访问过的链接，同时具备<code>:link</code>、<code>:visited</code>和<code>:hover</code>三种状态</li>
<li>鼠标点击的状态，<code>:active</code>，点击已访问链接未松开，同时具备<code>:link</code>、<code>:visited</code>、<code>:hover</code>和<code>:active</code>四种状态</li>
</ul>
<p>伪元素选择器：<br>
伪元素，表示页面中一些特殊的不真实存在的元素（特殊的位置），一般用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>:</mo><mo>:</mo></mrow><annotation encoding="application/x-tex">::</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mrel">:</span></span></span></span> 开头：</p>
<ul>
<li><code>::first-letter</code>，第一个字母</li>
<li><code>::first-line</code>，第一行</li>
<li><code>::selection</code>，选中的内容</li>
<li><code>::before</code>，表示元素的开始，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
<li><code>::after</code>，表示元素的结束，插入的内容是<strong>无法选中</strong>的，<strong>重要且常用</strong></li>
</ul>
<pre><code class="language-css">/* before 和 after 需要结合 content 属性使用才能看出效果 */
/* 下面的例子是在元素的开头插入红色字符串 'abc' */
div::before{
    content: 'abc';
    color: red;
}
</code></pre>
<p><strong>选择器的权重</strong><br>
样式的冲突，通过不同的选择器选中了相同的元素，并且为相同的样式设置了不同的值时，就发生了冲突<br>
此时应用哪个样式有选择器的权重（优先级）决定，选择器越具体优先级越高<br>
选择器的权重（数字仅是为了说明数量级）：</p>
<ul>
<li>内联样式 1,0,0,0</li>
<li>id 选择器 0,1,0,0</li>
<li>类和伪类选择器 0,0,1,0</li>
<li>元素选择器 0,0,0,1</li>
<li>通配选择器 0,0,0,0</li>
<li>继承的样式 没有优先级，即优先级低于通配</li>
</ul>
<p>比较优先级是，需要将所有选择器的优先级相加后再比较优先级（除了<strong>分组选择器</strong>是单独计算的），而选择器的累加不会超过其最大的<strong>数量级</strong>，类选择器再多也不会超过 id 选择器<br>
相同优先级，后面的会覆盖前面的<br>
可以在某一个样式后边添加<code>!important</code>则会获取到最高的优先级（超过内联样式），需要<strong>慎用</strong></p>
<pre><code class="language-css">.class{
    background-color: red !important;
}
</code></pre>
<p><strong>样式的继承</strong><br>
继承发生在<strong>祖先与后代</strong>之间，为一个元素设置样式同时也会应用到它的<strong>后代元素</strong><br>
继承的设计是为了方便开发，利用继承可以将一些通用的样式设置到共同的祖先元素上，这样只需设置一次<br>
并不是<strong>所有</strong>的样式都会被继承，比如背景相关的，布局相关的样式等</p>
<p><strong>长度单位</strong><br>
像素（px）：不同屏幕的像素大小是不同的<br>
百分比：能够将属性值设置为相对于其父元素属性的百分比，能够使子元素跟随父元素的改变而改变<br>
em：相对于元素的字体大小来计算的，1em = 1font-size，会随着字体的大小改变<br>
rem：相对于根元素的字体大小来计算</p>
<p><strong>颜色单位</strong><br>
颜色名：在 css 中可以直接使用颜色名来设置颜色，但不常用<br>
RGB：通过三种颜色的不同浓度来调配出不同的颜色，每一种范围在 0 - 255(0% - 100%) 之间，是光的三原色，均为 0 则黑，均为 255 则黑</p>
<pre><code class="language-css">.box{
    background-color: rgb(0, 0, 0);
    background-color: rgb(255, 255, 255);
}
</code></pre>
<p>RGBA：在 RGB 的基础上多了一个透明度 A，1 表示不透明，0 表示全透明，.5 半透明<br>
十六进制的 RGB 值：语法 #RGB，每种颜色用两位十六进制数表示，00 - ff<br>
HSL：H 色相(0 - 360)，S 饱和度(0% - 100%)，L 亮度(0% - 100%)<br>
HSLA：多一个透明度</p>
<h3 id="布局">布局</h3>
<p><strong>文档流</strong><br>
网页是多层结构，最底下的一层称为文档流，是网页的基础，创建的元素默认都在文档流中进行排列<br>
元素主要有两个状态：<strong>在文档流中</strong>和<strong>不在文档流中（脱离文档流）</strong><br>
元素在文档流中的特点：</p>
<ul>
<li>块元素：在页面中独占一行（自上向下垂直排列）；默认宽度是父元素的全部（把父元素撑满）；默认高度是被内容（子元素）撑开</li>
<li>行内元素：不会独占页面的一行，只占自身的大小；在页面中从左向右排列，如果在一行中不能容纳，则换到第二行；默认宽度和高度都被内容撑开</li>
</ul>
<p><strong>盒模型</strong><br>
css 将页面中的所有元素都设置为了一个矩形的盒子，盒子的可见框大小由内容区、内边距和边框共同决定<br>
每一个盒子都由以下击鼓部分组成：</p>
<ul>
<li>内容区(content)： 元素中的所有子元素和文本内容都在内容区中排列，内容区的大小由 width 和 height 两个属性来设置</li>
<li>内边距(padding)，内容区和边框之间的距离，可以用 padding 简写，也可以用 padding-xxx (xxx 可以是 top right bottom left)，内边距的大小会影响到盒子的大小，背景颜色会延伸到内边距上</li>
<li>边框(border)：属于盒子的边缘，需要设置三个样式
<ol>
<li>边框的宽度(border-width)，可以用来指定四个方向边框的宽度，四个值（上 右 下 左、顺时针），三个值（上 左右 下），两个值（上下 左右），一个值（上下左右）；或者使用 boder-xxx-width 单独指定某一个边框，默认 3px，边框的大小会直接影响盒子的大小</li>
<li>边框的颜色(border-color)，同样可分别以指定四个边的颜色，规则同上，默认黑</li>
<li>边框的样式(border-style)，实线(solid)，点状虚线(dotted)，虚线(dashed)，双线(double)，默认 none 表示没有边框<br>
boder 还有简写属性，同时设置边框的所有相关样式，并且<strong>没有</strong>顺序要求<code>border: 10px red solid</code>，也可以使用<code>border-xxx</code>分别设置四个边</li>
</ol>
</li>
<li>外边距(margin)，不影响可见框大小，但影响盒子的位置，有四个方向的外边距，可以用 margin 简写，也可以用 margin-xxx 设置（默认情况下设置 margin-right 不会产生效果，一般由浏览器调整），由于元素默认自左向右排列，因此设置左、上外边距会移动元素自身，而设置右、下外边距会移动其他元素。margin 设置负值则反向移动。margin 会影响盒子实际占用空间</li>
</ul>
<p><strong>盒模型的水平布局</strong><br>
元素在其父元素中水平方向的位置由以下几个属性共同决定：margin-left，border-left，padding-left，width，padding-right，border-right，margin-right<br>
它们的总和<strong>必须等于</strong>父元素内容区的宽度<br>
如果等式不成立，称为过度约束，等式自动调整：</p>
<ul>
<li>若七个值没有 auto 的情况，则自动调整 margin-right 使等式成立；</li>
<li>而 width，margin-left，margin-right能够设置 auto，设置后会自动调整该属性，其中 width 的默认值就是 auto；</li>
<li>宽度和一个外边距设置为 auto，宽度会调整到最大值，外边距为 0</li>
<li>三个都设置为 auto，则外边距都是 0，宽度最大</li>
<li>外边距为 auto，宽度固定，则将外边距设计为相同值（常用于在父元素中水平居中）</li>
</ul>
<p><strong>盒模型的垂直布局</strong><br>
子元素在父元素的内容区中排列，若子元素的大小超过了父元素，则子元素会从父元素中溢出<br>
使用 overflow 属性来设置父元素如何处理溢出的子元素（在父元素中设置），可选值：</p>
<ul>
<li>visible，默认值，使子元素溢出，在父元素外显示</li>
<li>hidden，溢出内容将被裁剪不会显示</li>
<li>scroll，生成两个滚动条，通过滚动条来查看完整的内容</li>
<li>auto，根据需要生成滚动条<br>
overflow-x 和 overflow-y 可以分别设置横向和纵向的溢出</li>
</ul>
<p><strong>垂直外边距的重叠(折叠)</strong><br>
相邻的垂直方向的外边距会发生重叠现象：</p>
<ul>
<li>兄弟元素间的相邻垂直外边距会取两者之间的绝对值较大的（都是正或负值），如果一正一副取两者和，对开发有利，不需要处理</li>
<li>父子元素间的相邻垂直外边距，子元素的会传递给父元素（上外边距），会影响到页面的布局，需要进行处理</li>
</ul>
<p><strong>行内元素的盒模型</strong><br>
行内元素不支持设置宽度和高度<br>
行内元素可以设置 padding，但不会影响页面的布局<br>
行内元素可以设置 border，垂直方向的 border 不会影响页面的布局<br>
行内元素可以设置 margin，垂直方向的 margin 不会影响页面的布局</p>
<p>display 用来设置元素的显示类型，可选值：</p>
<ul>
<li>inline 将元素设置为行元素</li>
<li>block 将元素设置为块元素</li>
<li>inline-block 将元素设置为行内块元素，可以设置宽高又不会独占一行</li>
<li>table 将元素设置为一个表格</li>
<li>none 元素不在页面中显示</li>
</ul>
<p>visibility 用来设置元素的显示状态，可选值：</p>
<ul>
<li>visible 默认值，元素在页面中正常显示</li>
<li>hidden 元素在也页面中隐藏不显示，但依然占据页面的位置</li>
</ul>
<p><strong>默认样式</strong><br>
通常情况浏览器都会为元素设置一些默认样式，会影响到页面的布局，因此需要去除浏览器的默认样式（PC端），可以使用别人的<strong>重置样式表</strong>，引入 css 文件</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试]]></title>
        <id>https://AriesSK.github.io/post/qian-duan-mian-shi/</id>
        <link href="https://AriesSK.github.io/post/qian-duan-mian-shi/">
        </link>
        <updated>2022-07-31T09:29:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端基础">前端基础</h2>
<h3 id="html">HTML</h3>
<p><strong>h5 新特性</strong></p>
<ul>
<li>媒体播放 video 和 audio</li>
<li>本地存储 localStorge 和 sessionStorage</li>
<li>语义化标签 header、nav、article、section、footer</li>
<li>历史管理 history API</li>
<li>新增选择器 document.querySelector()、document.querySelectorAll()，可以方便地获取 DOM 元素，前者返回第一个，后者返回所有，参数为字符串类型的 &quot;选择器语法&quot;</li>
<li>拖拽释放 Drag and drop API</li>
</ul>
<p><strong>iframe</strong><br>
内联框架，往网页中引入另一个网页<br>
优点：</p>
<ul>
<li>把嵌入的网页原封不动展现</li>
<li>可以将网页公用的部分携程一个页面使用 iframe 来嵌套，有利于网页统一风格，增加代码可重用</li>
<li>多网页引用时只需修改 iframe 内容就可以更改调用它的每一个页面</li>
<li>可以解决加载缓慢的第三方内容</li>
</ul>
<p>缺点：</p>
<ul>
<li>阻塞主页面的 onload 事件</li>
<li>与主页面共享连接池，会影响页面的并行加载，并且产生的多个页面不容易管理</li>
<li>可能出现上下左右滚动条，用户体验差</li>
<li>不利于 SEO 搜索引擎优化，爬虫难处理 iframe 中的内容</li>
<li>许多移动端设备不兼容</li>
<li>增加服务器的 http 请求，大型网站不可取</li>
</ul>
<p><strong>Web Components</strong><br>
提供一套完善的封装机制使 Web 组件化能够标准化，每种框架的组件都统一标准，推动组件的复用<br>
包含四部分：</p>
<ul>
<li>Custom Elements：让开发者自定义 HTML 元素，包括组成、样式和行为</li>
<li>HTML Imports：在 HTML 中引用和复用其他 HTML 文档的方式</li>
<li>HTML Templates：模板</li>
<li>Shadow DOM：提供更好的组织页面元素的方式，类似 DOM 中的 DOM，其元素和样式独立于原始 DOM</li>
</ul>
<h3 id="javascript">JavaScript</h3>
<p><strong>字面量</strong><br>
字面量，和常量差不多，其表达的信息如字面所示</p>
<p><strong>Object.assign(target, ...sources)</strong><br>
将 source 中的可枚举属性复制给 target，重名属性后面的覆盖前面的<br>
复制的是属性值，如果属性值是引用类型则复制引用地址，会出现引用共享的问题（修改其中的一个会影响到别的）</p>
<p><strong>constructor</strong><br>
constructor 属性是专门为 function 设计的，存在于每一个 function 函数的 prototype 原型属性中，是指向 prototype 所在函数的指针<br>
当我们调用该函数作为构造函数创建一个新实例后，该实例中将包含一个指向构造函数中的 prototype 的指针 proto<br>
如果以等于一个以<strong>对象字面量</strong>形式创建的新对象，constructor 不再指向该构造函数，比如</p>
<pre><code class="language-js">var person={ 
    name:&quot;Jack&quot;, 
    age:10
};
</code></pre>
<p><strong>map 和 forEach</strong></p>
<pre><code class="language-js">const arr = [1,2,3];
// map 遍历数组并给每个数翻倍
const arr1 = arr.map(x=&gt;x*2); //[2,4,6]
// forEach 遍历数组，有三个参数，分别是：当前遍历的数组元素 item、当前的元素下标 index、数组本身 arr
let sum = 0;
arr.forEach(function(item, index, arr) {
    if (arr[index] &gt; 0) sum += item;
})
</code></pre>
<p>相同点：</p>
<ol>
<li>均循环遍历数组每一项</li>
<li>只能遍历数组</li>
<li>匿名函数都支持三个参数 item、index、arr</li>
<li>匿名函数中的 this 指向 window</li>
</ol>
<p>不同点：</p>
<ol>
<li>map 创建新数组并返回，forEach 无返回</li>
<li>forEach 可以修改原数组，map 不会</li>
</ol>
<p><strong>for of</strong><br>
es6 的新增方法，只限于迭代器(iterator)，也就是<strong>可迭代</strong>对象，比如 Array、Map、Set、String、arguments、TyoedArray 等</p>
<p><strong>js 静态类型检查</strong><br>
静态类型语言：变量在定义的时候有类型声明，类型的检查发生在编译时，在运行的时候无法修改变量类型，编译器可以确定运行时需要的内存总量<br>
动态类型语言：变量在定义的时候无类型声明，类型的检查发生在运行时，在运行的时候可以修改变量类型<br>
对比：静态类型可以尽早发现错误，减少了复杂的错误处理，将数据和行为分离，也有利于代码重构；动态类型的代码比较精简，并且不需要花时间掌握类型<br>
js 的静态类型检查方法：<strong>Flow</strong>是 Facebook 的 js 静态类型检查工具，能够找出类型错误；<strong>TypeScript</strong> 在 js 的基础上添加静态类型定义，并且会被编译成 js</p>
<p><strong>indexOf</strong><br>
<code>str.indexOf(searchValue[, fromIndex])</code> 找到返回第一个匹配字串的起始下标，未找到返回 0<br>
searchValue 不设置会查找字符串 'undefined'<br>
fromIndex 是可选的，不填默认 0，负数等同 0，大于字符串长度等同于字符串长度<br>
<strong>严格区分大小写</strong></p>
<p><strong>变量提升</strong><br>
js 是单线程语言，是按顺序执行，但是一段一段地分析执行，代码执行前的编译阶段会检测到所有的变量和函数声明，添加到叫做 Lexical Environment 的 js 数据结构的内存中，所以能够在真正被声明前使用</p>
<p><strong>HashMap 和 Array</strong><br>
HashMap 散列表 是 数组 + 链表</p>
<ul>
<li>查找效率：HashMap 根据 hashcode 直接算出 index，在数组每个下标的链表只有一个元素的时候，能达到 O(1)；Array 二分查找，受数组长度影响较大</li>
<li>扩容数量：HashMap 初始长度 16，每次扩容申请双倍，扩容次数少；Array 小于 4 申请 4，小于 8 申请 8，大于 8 申请 size * 1.5，申请空间少</li>
<li>扩容效率：HashMap 扩容重新计算每个元素的位置，然后放到新的位置；Array 直接赋值数组，效率更高</li>
<li>内存消耗：Array 使用了独特的方式重复利用因为数组扩容遗留的数组空间，HashMap 没有</li>
</ul>
<p>总的来说，数据量小且使用频繁使用 Array，数据量大使用 HashMap</p>
<p><strong>HashMap 和 Object</strong><br>
两者累次允许按键存取值，删除键，检测键是否有值，不过 Map 有些优势：</p>
<ul>
<li>意外的键：Map 默认不包含任何键；Object 有原型，可能与插入的键名冲突</li>
<li>键的类型：Map 键可以是任意值；Object 只能是 String 或 Symbol</li>
<li>键的顺序：Map 键是有序的，迭代时以<strong>插入顺序</strong>返回；Object 无序</li>
<li>Size：Map 通过 size 容易获取键值对个数；Object 手动计算</li>
<li>迭代：Map 可直接迭代；获取 Object 的键值后才能迭代</li>
<li>性能：Map 在频繁增删时性能更优；Object 无优化</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[41. 缺失的第一个正数]]></title>
        <id>https://AriesSK.github.io/post/top_41/</id>
        <link href="https://AriesSK.github.io/post/top_41/">
        </link>
        <updated>2022-07-27T02:27:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="for-in与for-of遍历的坑"><code>for in</code>与<code>for of</code>遍历的坑</h3>
<p>之前踩过的坑今天居然又踩了一遍，以后还是老老实实用<strong>常规</strong>的遍历方法吧！<br>
<code>for of</code>遍历不提供索引，是<strong>不能修改原数组</strong>的！</p>
<pre><code class="language-js">const nums = [0,1,2];
for (let num of nums) {
    num = num + 1;
}
console.log(nums); // [0,1,2]
</code></pre>
<p><code>for in</code>遍历提供的索引是<strong>字符串</strong>形式的！</p>
<pre><code class="language-js">const nums = [0,1,2];
for (const i in nums) {
    console.log(i + 1); // &quot;01&quot;,&quot;11&quot;,&quot;21&quot;
}
</code></pre>
<h3 id="原地哈希表">原地哈希表</h3>
<p>原地哈希表的方法往往是修改原数组实现的，原理就是将数组的下标作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，数组的值作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">value</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，然后以特定关系将两者关联起来（通常需要保证一一对应，最简单的是将值直接作为键），最终起到哈希表的作用。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="原地哈希表-2">原地哈希表</h3>
<p>本题在允许修改原数组的前提下可以做到原地算法，将原数组进行改造起到哈希表的作用：<br>
首先要清楚对于长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数组，缺失的第一个正数的范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, n + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，因为如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 都出现了，那么答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，否则答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 中没有出现的最小正整数。<br>
所以只需要记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[1, n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span> 内的所有数即可获得答案，而原数组长度正好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，因此可以改造数组为哈希表，对于出现过的数可以标记其对应下标的数来表示其出现过。<br>
这时候又遇到一个问题，标记会修改数组影响后续的遍历，要保证又能记录又不影响数组的原值，设计标记为<strong>负号</strong>，且不允许重复标记，流程如下：</p>
<ol>
<li>遍历数组，先将所有非正数修改为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，保证不影响实验结果；</li>
<li>再次遍历数组每个数 num，因为可能已经被标记成为负数，因此需要取绝对值，然后将数组下标为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">| num| - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的数进行标记（不重复标记）；</li>
<li>第三次遍历数组，找到第一个整数，返回其下标 + 1，均为负数则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</li>
</ol>
<pre><code class="language-js">var firstMissingPositive = function(nums) {
    const n = nums.length;
    for (let i = 0; i &lt; n; ++i) {
        if (nums[i] &lt;= 0) nums[i] = n + 1;
    }
    for (let num of nums) {
        num = Math.abs(num);
        if (num &lt;= n &amp;&amp; nums[num - 1] &gt; 0) nums[num - 1] *= -1;
    }
    for (let i = 0; i &lt; n; ++i) {
        if (nums[i] &gt; 0) return i + 1;
    }
    return n + 1;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. 有效的数独]]></title>
        <id>https://AriesSK.github.io/post/top_36/</id>
        <link href="https://AriesSK.github.io/post/top_36/">
        </link>
        <updated>2022-07-26T02:23:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="哈希表与数组">哈希表与数组</h3>
<p>大多数哈希表的计数问题都能使用数组解决，而哈希表更新和查询的时间复杂度为平均 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>（考虑到哈希冲突的情况，最坏退化为链表），而数组的更新和查询时间复杂度为严格 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，所以使用数组的执行效率更高。</p>
<h3 id="使用map二维数组创建">使用<code>map</code>二维数组创建</h3>
<pre><code class="language-js">// 需要注意的是前后两个 fill 可以不赋值但一定要有，否则无法正确创建
const arr = new Array(3).fill(0).map(() =&gt; new Array(3).fill(0));
</code></pre>
<h3 id="赋值运算顺序">赋值运算顺序</h3>
<pre><code class="language-js">// 赋值运算符，先看右边的值
let a = b = 0;
// 等价于下面
b = 0;
let a = b;

// . 成员访问运算符，优先级比赋值运算符高
var a = {n: 1};
var b = a;
a.x = a = {n: 2}; // 执行步骤：获取旧 a.x 的地址准备计算，等待赋值符右侧的返回值；a 指向新的地址成为新 a 并返回值 {n:2}；旧 a.x 的地址获得返回值，赋值
console.log(a); // {n: 2}
console.log(b);// {n: 1, x: {n : 2}}
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一哈希表-三次遍历">法一：哈希表 + 三次遍历</h3>
<p>针对三个判断条件遍历数组三次，返回结果：</p>
<pre><code class="language-js">var isValidSudoku = function(board) {
    for (let i = 0; i &lt; 9; ++i) {
        let set = new Set();
        for (let j = 0; j &lt; 9; ++j) {
            if (board[i][j] === &quot;.&quot;) continue;
            if (set.has(board[i][j])) return false;
            set.add(board[i][j]);
        }
        set = new Set();
        for (let k = 0; k &lt; 9; ++k) {
            if (board[k][i] === &quot;.&quot;) continue;
            if (set.has(board[k][i])) return false;
            set.add(board[k][i]);
        }
        if (i % 3) continue;
        for (let l = 0; l &lt; 9; l += 3) {
            if (!helper(i, l)) return false;
        }        
    }
    return true;

    function helper(a, b) {
        const set = new Set();
        for (let i = a; i &lt; a + 3; ++i) {
            for (let j = b; j &lt; b + 3; ++j) {
                if (board[i][j] === &quot;.&quot;) continue;
                if (set.has(board[i][j])) return false;
                set.add(board[i][j]);
            }
        }
        return true;
    }
};
</code></pre>
<h3 id="法二三个二维数组-一次遍历">法二：三个二维数组 + 一次遍历</h3>
<p>分别使用三个二维数组对行、列、九宫格内出现的数字进行计数，就可以做到一次遍历实现判断。<br>
其中对于九宫格需要进行编号（不编号则使用三维数组），从左向右再从上至下编号，则编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">index</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span></span></span></span> 与数字的下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的关系是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo>=</mo><mo>⌊</mo><mi>i</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo>⌋</mo><mo>×</mo><mn>3</mn><mo>+</mo><mo>⌊</mo><mi>j</mi><mi mathvariant="normal">/</mi><mn>3</mn><mo>⌋</mo></mrow><annotation encoding="application/x-tex">index = \lfloor i / 3\rfloor \times 3 + \lfloor j / 3\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault">i</span><span class="mord">/</span><span class="mord">3</span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">/</span><span class="mord">3</span><span class="mclose">⌋</span></span></span></span>：</p>
<pre><code class="language-js">var isValidSudoku = function(board) {
    const row = new Array(9).fill(0).map(() =&gt; new Array(9).fill(0));
    const column = new Array(9).fill(0).map(() =&gt; new Array(9).fill(0));
    const area = new Array(9).fill(0).map(() =&gt; new Array(9).fill(0));
    for (let i = 0; i &lt; 9; ++i) {
        for (let j = 0; j &lt; 9; ++j) {
            const val = board[i][j];
            if (val === &quot;.&quot;) continue;
            if (row[i][+val] || column[j][+val] || area[Math.floor(i / 3) * 3 + Math.floor(j / 3)][+val]) return false;
            row[i][+val] = column[j][+val] = area[Math.floor(i / 3) * 3 + Math.floor(j / 3)][+val] = 1;
        }
    }
    return true;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. 在排序数组中查找元素的第一个和最后一个位置]]></title>
        <id>https://AriesSK.github.io/post/top_34/</id>
        <link href="https://AriesSK.github.io/post/top_34/">
        </link>
        <updated>2022-07-25T03:00:35.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二分法的问题转化">二分法的问题转化</h3>
<p>查找位置的问题实际上可以转化为找目标元素在排序数组中的插入位置的问题，这种问题的解法模板请移步<a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="二分法">二分法</h3>
<p>最后一个位置转化为<strong>目标元素在数组中的最右插入位置 - 1</strong>，第一个位置转化为<strong>比目标元素小 1 的数在数组中的最右插入位置</strong>。<br>
需要注意的是找插入位置的问题中目标元素不存在于数组中同样能返回位置，而查找问题找不到应当返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，故使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">flag</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 记录是否找到该元素。</p>
<pre><code class="language-js">var searchRange = function(nums, target) {
    return search(target) ? [search(target - 1), search(target) - 1] : [-1, -1];

    function search(tar) {
        let l = 0, r = nums.length - 1, flag = false; 
        while (l &lt;= r) {
            const m = l + r &gt;&gt; 1;
            if (nums[m] === tar) {
                l = m + 1;
                flag = true;
            }
            else if (nums[m] &lt; tar) l = m + 1;
            else r = m - 1;
        }
        if (tar === target &amp;&amp; !flag) return false;
        return l;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[33. 搜索旋转排序数组]]></title>
        <id>https://AriesSK.github.io/post/top_33/</id>
        <link href="https://AriesSK.github.io/post/top_33/">
        </link>
        <updated>2022-07-25T02:41:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二分法核心思想">二分法核心思想</h3>
<p>二分法的核心就是缩小查找的空间，每次排除部分不可能的空间，直到查找到目标元素。<br>
对于这道题，缩小空间的方法是判断目标元素是否在有序部分中，在则排除无序部分，不在则排除有序部分。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="二分法">二分法</h3>
<p>每次根据二分中点能够将数组划分为有序和无序两个部分，有序部分可以通过最小值和最大值判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span> 是否在该部分当中，从而进行查找空间的缩小，直到查找到目标元素。<br>
对于无序部分，中点能够将其划分为一个有序部分和一个可能有序也可能无序的部分；对于有序部分，中点能够将其划分为两个有序部分，缩小空间的方式相同。</p>
<pre><code class="language-js">var search = function(nums, target) {
    let l = 0, r = nums.length - 1;
    while (l &lt;= r) {
        const m = l + r &gt;&gt; 1;
        if (nums[m] === target) return m;
        // 如果 m 左侧有序，右侧无序
        if (nums[0] &lt;= nums[m]) {
            // 因为 m 左侧是有序的，所以可以判断 target 在不在该区间内
            if (nums[0] &lt;= target &amp;&amp; target &lt; nums[m]) r = m - 1;
            else l = m  + 1;
        } else {
            if (nums[m] &lt; target &amp;&amp; target &lt;= nums[nums.length - 1]) l = m + 1;
            else r = m - 1;
        }
    }
    return -1;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[29. 两数相除]]></title>
        <id>https://AriesSK.github.io/post/top_29/</id>
        <link href="https://AriesSK.github.io/post/top_29/">
        </link>
        <updated>2022-07-24T02:39:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="位运算替代加减乘除运算">位运算替代加减乘除运算</h3>
<p><strong>加减：</strong> 使用按位异或和按位与运算能够替代，具体见<a href="https://ariessk.github.io/post/jianzhi_65">65. 不用加减乘除做加法</a>；<br>
<strong>乘：</strong> 可以用加法和二分法（位移运算）进行快速乘；<br>
<strong>除：</strong> 可以使用加减法和二分法（位移运算）替代。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="位运算-二分法">位运算 + 二分法</h3>
<p>位运算可以替代 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\times2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">2</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>÷</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\div2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">÷</span><span class="mord">2</span></span></span></span>，因此本题思路就是将 dividend 拆分成多个 divisor 的 二次幂倍，而二次幂倍的乘法可以用位移运算替代。<br>
<strong>精髓</strong>是找到第一个最大的二次幂倍后，将 dividend 和其的差作为新的 dividend，就转化为了相同的问题，可以用同一段代码解决。</p>
<pre><code class="language-js">var divide = function(dividend, divisor) {
    // 排除特殊情况，并且均变为正数方便计算，用 flag 记录结果的符号
    if (!dividend) return 0;
    if (dividend === -(2 ** 31) &amp;&amp; divisor === -1) return 2 ** 31 - 1;
    let res = 0, flag = 1;
    if (dividend &lt; 0 &amp;&amp; divisor &gt; 0 || dividend &gt; 0 &amp;&amp; divisor &lt; 0) flag = -1;
    dividend = Math.abs(dividend);
    divisor = Math.abs(divisor);
    while (dividend &gt;= divisor) {
        let tmp = divisor, m = 1;
        // tmp 是小于 dividend 的 divisor 的最大二次幂倍，m 记录倍数
        while (tmp &lt;= dividend &gt;&gt; 1) {
            tmp &lt;&lt;= 1;
            m &lt;&lt;= 1;
        }
        // 更新 dividend，进入下一次循环，重置 tmp 和 m，重复上面步骤至 divisor 超过 dividend
        dividend -= tmp;
        res += m;
    }
    return flag * res;
};
</code></pre>
<p>上面这种方法每次循环都重置 tmp，会有许多重复计算，可以在第一次循环时将 divisor 的每个二次幂倍数都记录到数组中，然后倒序遍历数组也可以实现，用空间换时间。</p>
]]></content>
    </entry>
</feed>