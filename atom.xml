<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-06-22T12:54:10.597Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[13. 机器人的运动范围]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_13/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_13/">
        </link>
        <updated>2022-06-22T05:30:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的函数传值">JavaScript 中的函数传值</h3>
<p>js 中的所有函数的参数都是按值传递的，这意味着函数外的值会被复制到函数内部的参数中，如果是原始值，就跟原始值变量的复制一样，如果是引用值，就和引用值变量的复制一样。</p>
<ul>
<li><strong>按值传递参数：</strong> 外部的值被复制到函数的一个局部变量中，这两个值相互独立，互不干扰；</li>
<li><strong>按引用传递参数：</strong> 外部的值在内存中的位置会被保存到函数的一个局部变量中，意味着对局部变量的修改会反应到函数外部，这在 js 中是<strong>不可能的</strong>。<br>
<img src="https://AriesSK.github.io/post-images/1655878734447.png" alt="" loading="lazy"><br>
原始值的按值传递举例，可以看到传入参数与外部值相互独立，互不干扰：</li>
</ul>
<pre><code class="language-js">function addOne (num) {
    num += 1;
    return num;
}
let count = 20;
let res = addOne(count); // count === 20, res === 30
</code></pre>
<p>引用值的按值传递举例，如果是按引用传递，那么在新建<code>obj</code>对象的时候，<code>person</code>应该自动将指针改为指向&quot;Aries&quot;的对象，但事实上并没有。这证明了是按值传递的，传递了引用值，而引用的对象是保存在全局作用域，因此可以通过<code>obj</code>访问引用对象修改属性：</p>
<pre><code class="language-js">function setName(obj) {
    obj.name = &quot;AriesSK&quot;;
    obj = new Object();
    obj.name = &quot;Aries&quot;
    return num;
}
let person = new Object();
setName(person); // person.name === &quot;AriesSK&quot;
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一深度优先搜索">法一：深度优先搜索</h3>
<p>我的解法：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    let res = 0;
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    return dfs(visit, 0, 0, k, res);
};

var dfs = function(visit, i, j, k, res) {
    let s = &quot;&quot; + i + j, sum = 0;
    for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
    if (i &lt; 0 || i &gt;= visit.length || j &lt; 0 || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return res;
    visit[i][j] = 1;
    res = dfs(visit, i + 1, j, k, res);
    res = dfs(visit, i - 1, j, k, res);
    res = dfs(visit, i, j + 1, k, res);
    res = dfs(visit, i, j - 1, k, res);
    return ++res;
}
</code></pre>
<p><img src="https://AriesSK.github.io/post-images/1655879902391.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655879907533.png" alt="" loading="lazy"><br>
dfs 解法的优化，省略了不必要的<code>res</code>，并且由于从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 开始，由图可以看出仅通过向右和向下两个方向即可访问所有可达解：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    return dfs(visit, 0, 0, k);
};

var dfs = function(visit, i, j, k) {
    let s = &quot;&quot; + i + j, sum = 0;
    for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
    if ( i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return 0;
    visit[i][j] = 1;
    return 1 + dfs(visit, i + 1, j, k) + dfs(visit, i, j + 1, k);
}
</code></pre>
<h3 id="法二广度优先搜索">法二：广度优先搜索</h3>
<p>bfs 需要用到队列和循环，无需递归：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    let res = 0;
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    const queue = [];
    queue.unshift([0, 0]);
    while(queue.length &gt; 0) {
        let temp = queue.pop();
        let i = temp[0], j = temp[1], s = &quot;&quot; + i + j, sum = 0;
        for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
        if (i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) continue;
        visit[i][j] = 1;
        ++res;
        queue.unshift([i + 1, j]);
        queue.unshift([i, j + 1]);
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[12. 矩阵中的路径]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_12/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_12/">
        </link>
        <updated>2022-06-22T02:25:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>通过递归的方式，先朝一个方向搜索到底，再回溯至上个节点，沿另一个方向搜索，一次类推。</p>
<h3 id="剪枝">剪枝</h3>
<p>在搜索过程中遇到<strong>该路径不可能与目标匹配成功</strong>的情况时，应当立即返回，这叫<strong>可行性剪枝</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索-剪枝">深度优先搜索 + 剪枝</h3>
<ul>
<li>
<p><strong>递归终止条件：</strong></p>
<ul>
<li>返回 <code>false</code>：索引越界 || 当前矩阵元素与目标不匹配（包括已访问）；</li>
<li>返回<code>true</code>：<code>k === word.length - 1</code>，即<code>word</code>已完全匹配。</li>
</ul>
</li>
<li>
<p><strong>递推工作：</strong></p>
<ol>
<li>标记已访问：将<code>board[i][j]</code>修改为 <code>0</code>，防止重复搜索；</li>
<li>搜索下一元素：朝当前元素上、下、左、右四个方向进行下一层递归，使用<code>||</code>连接代表只需找到一条可行路径，记录结果至<code>res</code>；</li>
<li>还原：将<code>board[i][j]</code>还原至初始值<code>word[k]</code>。<br>
<img src="https://AriesSK.github.io/post-images/1655866202557.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655866209347.png" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
<pre><code class="language-js">var exist = function(board, word) {
    for (let i = 0; i &lt; board.length; ++i) {
        for (let j = 0; j &lt; board[0].length; ++j) {
            if (dfs(board, word, i, j, 0)) return true;
        }
    }
    return false;
};

var dfs = function(board, word, i, j, k) {
    if (i &gt;= board.length || i &lt; 0 || j &gt; board[0].length || j &lt; 0 || board[i][j] !== word[k]) return false;
    if (k === word.length - 1) return true;
    // 标记已访问
    board[i][j] = 0;
    const res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1);
    // 恢复原数组
    board[i][j] = word[k];
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[58 - I. 翻转字符单词顺序]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_58_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_58_i/">
        </link>
        <updated>2022-06-21T12:29:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的正则表达式">JavaScript 的正则表达式</h3>
<p>语法：<br>
<code>/正则表达式主体/修饰符(可选)</code><br>
修饰符不区分大小写：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td>g</td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配</td>
</tr>
</tbody>
</table>
<p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>查找方括号之间的任何字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找任何以 | 分隔的选项</td>
</tr>
</tbody>
</table>
<p>元字符是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>查找数字</td>
</tr>
<tr>
<td>\s</td>
<td>查找空白字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>查找以十六进制数 xxxx 规定的 Unicode 字符</td>
</tr>
</tbody>
</table>
<p>量词:</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>n+</td>
<td>匹配任何包含至少一个 n 的字符串</td>
</tr>
<tr>
<td>n*</td>
<td>匹配任何包含零个或多个 n 的字符串</td>
</tr>
<tr>
<td>n?</td>
<td>匹配任何包含零个或一个 n 的字符串</td>
</tr>
</tbody>
</table>
<h3 id="javascript-的字符串函数">JavaScript 的字符串函数</h3>
<p>本题中使用的一些字符串函数及它们的时间复杂度：</p>
<pre><code class="language-js">trim() // 去除字符串头尾的空格 O(n)
split() // 拆分成数组 O(n)
reverse() // 反转数组 O(n)
join() // 使用特定分隔符将数组连接成字符串 O(n)
</code></pre>
<p>其中需要重点说明<code>split()</code>举例如下：</p>
<pre><code class="language-js">let s = &quot;a  b c&quot;
s.split() // [&quot;a  b c&quot;] // 直接返回数组
s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开
s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素
s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一字符串函数">法一：字符串函数</h3>
<p>首先想到使用<code>tirm()</code>删除头尾空格，<code>split(&quot; &quot;)</code>拆分成数组，从数组末尾开始拼接：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    const arr = s.trim().split(&quot; &quot;);
    let res = &quot;&quot;;
    for (let i = arr.length - 1; i &gt;= 0; --i) {
        if (arr[i] === &quot;&quot;) continue;
        res += i ? arr[i] + &quot; &quot; : arr[i];
    }
    return res;
};
</code></pre>
<p>事实上使用字符串函数代码可以更加简洁：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
};
</code></pre>
<h3 id="法二双指针">法二：双指针</h3>
<pre><code class="language-js">var reverseWords = function(s) {
    s = s.trim();
    let left = s.length - 1, right = left;
    let res = &quot;&quot;;
    // 保证 left 能够取到 0
    while (left &gt;= 0) {
        // 找到第一个空格
        while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left;
        res += s.substring(left + 1, right + 1) + &quot; &quot;;
        // 忽略空格找到第一个字符
        while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left;
        right = left;
    }
    // 删去最后末尾多余的一个空格
    return res.trim();
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[57. 和为s的两个数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_57/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_57/">
        </link>
        <updated>2022-06-21T11:46:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的const">JavaScript 的<code>const</code></h3>
<p>在允许的情况下，推荐使用<code>const</code>进行声明，<code>const</code>声明后无法重新赋值，但可以修改其属性值。</p>
<hr>
<h2 id="题解">题解</h2>
<p>双指针的简单应用：</p>
<pre><code class="language-js">var twoSum = function(nums, target) {
    let left = 0, right = nums.length - 1;
    const res = [];
    // 若允许同一个数自己加自己则取 =
    while (left &lt; right) {
        // 在值是正数的情况下，改加为减能够有效防止值溢出
        if (nums[left] &gt; target - nums[right]) --right;
        else if (nums[left] &lt; target - nums[right]) ++left;
        else {
            res.push(nums[left]);
            res.push(nums[right]);
            // 不适用 break 会导致无限循环入栈至溢出
            break;
        }
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[21. 调整数组顺序使奇数位于偶数前面]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_21/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_21/">
        </link>
        <updated>2022-06-21T10:56:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的运算符优先级">JavaScript 中的运算符优先级</h3>
<p><img src="https://AriesSK.github.io/post-images/1655902411960.png" alt="" loading="lazy"><br>
在写代码时需要注意运算符的优先级，如下由于<code>!</code>的运算优先级高于<code>%</code>，因此加不加<code>()</code>是两种结果：</p>
<pre><code class="language-js">let num = 2;
console.log(!num % 2); // 0
console.log(!(num % 2)); // true
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<p>简单的双指针运用：</p>
<pre><code class="language-js">var exchange = function(nums) {
    let left = 0, right = nums.length - 1;
    // while 中是否取等号均可
    while (left &lt; right) {
        if (nums[left] % 2) ++left;
        else if (!(nums[right] % 2)) --right;
        else {
            let temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
        } 
    }
    return nums;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[18. 删除链表的节点]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_18/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_18/">
        </link>
        <updated>2022-06-19T11:10:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中">JavaScript 中</h3>
<p>方法如下：</p>
<pre><code class="language-js">
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一">法一：</h3>
<p>法一：</p>
<pre><code class="language-js">
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 - I. 斐波那契数列]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_10_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_10_i/">
        </link>
        <updated>2022-06-16T14:47:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="动态规划总结">动态规划总结</h3>
<p><em>Those who cannot remember the past are condemned to repeat it.</em><br>
<em>那些不记得过去的人注定要重蹈覆辙。</em></p>
<p>动态规划(Dynamic Programming, DP)通过记住求过的解来节省时间，对每一个子问题只求解一次，并将结果存下来。</p>
<ul>
<li>无后效性：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响</li>
<li>最优子结构性质：大的问题的最优解可以由小问题的最优解推出</li>
</ul>
<p>判断能否使用 DP 解决：是否能够将大问题拆成几个小问题，且满足无后效性、最优子结构性质。<br>
步骤：</p>
<ol>
<li>状态定义：定义一个状态，这是一个最优解的结构特征；</li>
<li>转移方程：进行状态递推，得到递推公式；</li>
<li>初始状态：进行初始化；</li>
<li>返回结果。</li>
</ol>
<p>其中最重要的是<strong>状态转移方程</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一递归">法一：递归</h3>
<p>我第一时间想到的思路，且代码简单，但递归过程中重复的计算过多，导致超出了时间限制，无法通过：</p>
<pre><code class="language-js">var fib = function(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    return (fib(n - 1) + fib(n - 2)) % (1e9+7);
};
</code></pre>
<h3 id="法二递归-哈希表">法二：递归 + 哈希表</h3>
<p>法一的优化，将每次计算后的结果存在哈希表中，即可避免重复计算，但需要额外<code>O(n)</code>的空间：</p>
<pre><code class="language-js">var fib = function(n, hash = new Map()) {
    if (n &lt;= 1) return n;
    if (hash.has(n)) return hash.get(n);
    // 注意给 1e9+7 加括号 否则会出错
    else hash.set(n, (fib(n - 1, hash) + fib(n - 2, hash)) % (1e9+7));
    return hash.get(n);
};
</code></pre>
<h3 id="法三动态规划">法三：动态规划</h3>
<p>状态转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n) = F(n - 1) + F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span><br>
由于只涉及到三个值，因此可以用滚动数组法使得空间复杂度为<code>O(1)</code>：</p>
<ol>
<li>状态定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 表示第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个斐波那契数；</li>
<li>转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n) = F(n - 1) + F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>；</li>
<li>初始状态：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(0) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(1) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(2) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li>
<li>返回结果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<p><img src="https://AriesSK.github.io/post-images/1655808465832.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655808471264.png" alt="" loading="lazy"></p>
<pre><code class="language-js">var fib = function(n) {
    const MOD = 1e9+7;
    if (n &lt; 2) return n;
    let p = 0, q = 0, r = 1;
    for (let i = 2; i &lt;= n; ++i) {
        p = q; 
        q = r; 
        r = (p + q) % MOD;
    }
    return r;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10 - II. 青蛙跳台阶问题]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_10_ii/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_10_ii/">
        </link>
        <updated>2022-06-16T13:50:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>类似斐波那契数列的问题，使用动态规划解决，需要注意初始状态的区别。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="动态规划">动态规划</h3>
<p>跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 种跳法，在所有跳法中，最后一步只有两种情况：</p>
<ul>
<li>跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 级，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n - 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 种；</li>
<li>跳 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 级，有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 种。</li>
</ul>
<p>所以步骤如下：</p>
<ol>
<li>状态定义：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 表示跳上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 级台阶的跳法总数；</li>
<li>转移方程：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n) = F(n - 1) + F(n - 2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span>；</li>
<li>初始状态：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>0</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(0) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(1) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mn>2</mn><mo>)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">F(2) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>；</li>
<li>返回结果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">F(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<pre><code class="language-js">var numWays = function(n) {
    if (n &lt; 2) return 1;
    let p = 0, q = 1, r = 1;
    for (let i = 2; i &lt;= n; ++i) {
        p = q;
        q = r;
        r = (p + q) % (1e9+7);
    }
    return r;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[11. 旋转数组的最小数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_11/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_11/">
        </link>
        <updated>2022-06-13T14:00:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>这一题的二分法很特别，因为在<code>numbers[m] = numbers[r]</code>的情况下，无法判断旋转点在哪个半区，因此无法通过常规方法缩小区间，而需要使用<code>--r</code>来缩小区间，而<code>--r</code>的终止条件应当是<code>l === r</code>时，因此本题需要使用模板二，二分法具体模板见<a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>找到第一个变小的数字：</p>
<pre><code class="language-js">var minArray = function(numbers) {
    for (let i = 1; i &lt; numbers.length; ++i) {
        if (numbers[i] &lt; numbers[i - 1]) return numbers[i];
    }
    // 旋转0个数的情况
    return numbers[0];
};
</code></pre>
<h3 id="法二二分法">法二：二分法</h3>
<p>要保证每次缩小区间后最小值仍在区间内。<br>
二分会有三种情况：</p>
<ul>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] &gt; nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 一定在左排序数组中，即旋转点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一定在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[m + 1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 闭区间内，因此执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = m + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；</li>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] &lt; nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 一定在右排序数组中，即旋转点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一定在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 闭区间内，因此执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">r = m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>；</li>
<li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] = nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 时： 无法判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 在哪个排序数组中，即无法判断旋转点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l, m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 还是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[m + 1, r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 区间中，但由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] = nums[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 并且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 一定在区间内，因此即使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">num[r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 是最小值，也可以执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>=</mo><mi>r</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r = r - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 缩小范围。</li>
</ul>
<p>为什么本题二分法不用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 作比较？ 避免了旋转 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 个数出现的问题。<br>
二分目的是判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 在哪个排序数组中，从而缩小区间。而在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>m</mi><mo>]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[m] &gt; nums[l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">m</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 情况下，无法判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 在哪个排序数组中。本质上是由于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 初始值肯定在右排序数组中；但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 初始值无法确定在哪个排序数组中。</p>
<pre><code class="language-js">var minArray = function(numbers) {
    let l = 0, r = numbers.length;
    while (l &lt; r) {
        const m = l + Math.floor((r - l) / 2);
        if (numbers[m] &gt; numbers[r]) l = m + 1;
        else if (numbers[m] &lt; numbers[r]) r = m;
        else --r;
    }
    return numbers[l];
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[04. 二维数组中的查找]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_04/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_04/">
        </link>
        <updated>2022-06-13T13:31:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题中的二维数组虽然每一行和每一列都是递增的，但整体是无序的，因此不适用二分查找。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>注意题目中提示了输入可能是空数组，这种情况需要特别考虑：</p>
<pre><code class="language-js">var findNumberIn2DArray = function(matrix, target) {
    // 若 matrix 为空，则 matrix[0].length 会报错，故这种情况单独考虑
    if (!matrix.length) return false;
    let n = matrix.length, m = matrix[0].length;
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; m; ++j) {
            if (matrix[i][j] === target) return true;
        }
    }
    return false;
};
</code></pre>
<h3 id="法二标志数">法二：标志数</h3>
<p>将矩阵逆时针旋转 45°，能够发现其结构类似<strong>二叉搜索树</strong>，左分支更小，右分支更大；<br>
因此从根节点，也就是右上角开始搜索，比<code>target</code>大就向左，否则向右；<br>
矩阵的左下角和右上角元素均可以作为根节点，这就是标志数。<br>
<img src="https://AriesSK.github.io/post-images/1655732925766.png" alt="" loading="lazy"></p>
<pre><code class="language-js">// 右上角开始
var findNumberIn2DArray = function(matrix, target) {
    if (!matrix.length) return false;
    let i = 0, j = matrix[0].length - 1;
    while (i &lt; matrix.length &amp;&amp; j &gt;= 0) {
        if (matrix[i][j] === target) return true;
        else if (matrix[i][j] &lt; target) ++i;
        else --j;
    }    
    return false;
};

// 左下角开始
var findNumberIn2DArray = function(matrix, target) {
    let i = matrix.length - 1, j = 0;
    // 空数组的情况下，由于 i &gt;= 0 没有满足，因此没有执行到 matrix[0].length 所以不会报错
    while (i &gt;= 0 &amp;&amp; j &lt; matrix[0].length) {
        if (matrix[i][j] === target) return true;
        else if (matrix[i][j] &gt; target) --i;
        else ++j;
    }    
    return false;
};
</code></pre>
]]></content>
    </entry>
</feed>