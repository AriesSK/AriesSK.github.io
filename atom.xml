<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-06-26T11:12:29.266Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[55 - II. 平衡二叉树]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_55_ii/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_55_ii/">
        </link>
        <updated>2022-06-26T05:51:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="自顶向下与自底向上">自顶向下与自底向上</h3>
<p>目前来看，我感觉在深度优先搜索中，<strong>自顶向下</strong>的思路比<strong>自底向上</strong>的思路容易想到，而<strong>自底向上</strong>的思路往往比<strong>自顶向下</strong>的思路时间复杂度低，<strong>自底向上</strong>使用<strong>后序遍历</strong>，<strong>自顶向下</strong>使用<strong>先序遍历</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一先序遍历-计算深度自顶向下">法一：先序遍历 + 计算深度（自顶向下）</h3>
<p>我的想法是沿用<a href="https://ariessk.github.io/post/jianzhi_55_i/">55 - I. 二叉树的深度</a>里的方法，<code>depth()</code>用以计算节点的左右子树的深度，<code>isBalanced()</code>用以遍历所有节点并判断是否平衡，但这种方法在遍历节点时进行了许多的重复计算，时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var isBalanced = function(root) {
    if (!root) return true;
    // 先处理根节点 再处理左右节点
    return Math.abs(depth(root.left) - depth(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);
};

var depth = function(root) {
    if (!root) return 0;
    return Math.max(depth(root.left), depth(root.right)) + 1;
}
</code></pre>
<h3 id="法二后序遍历-剪枝自底向上">法二：后序遍历 + 剪枝（自底向上）</h3>
<p>这道题的最优解法应当延续<a href="https://ariessk.github.io/post/jianzhi_55_i/">55 - I. 二叉树的深度</a>的法二，使用后续遍历，自底向上，若判断子树不是平衡树则可以直接<strong>剪枝</strong>，思路是从叶子节点开始，计算其左右子树的深度，判断其差值的绝对值：</p>
<ul>
<li>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi><mi>s</mi><mo>(</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>)</mo><mo>−</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>)</mo><mo>)</mo><mo>&lt;</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">abs(depth(root.left) - depth(root.right)) &lt;= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，返回该树深度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>)</mo><mo separator="true">,</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mo>(</mo><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>)</mo><mo>)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">max(depth(root.left), depth(root.right)) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>否则返回 -1，并且一直返回至结束递归。</li>
</ul>
<p>算法复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>：</p>
<pre><code class="language-js">var isBalanced = function(root) {
    return dfs(root) !== -1;
};

var dfs = function(root) {
    if (!root) return 0;
    let left = dfs(root.left);
    if (left === -1) return -1;
    let right = dfs(root.right);
    if (right === -1) return -1;
    return Math.abs(left - right) &lt;= 1 ? Math.max(left, right) + 1 : -1;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[55 - I. 二叉树的深度]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_55_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_55_i/">
        </link>
        <updated>2022-06-26T05:27:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>要掌握 BFS 和 DFS 两种搜索算法的核心思想，结合题目要求，优化自己的代码！</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>我一开始的想法是<strong>自顶向下</strong>的，核心思想是遍历每一个叶子节点并记录其深度，取最大值：</p>
<ul>
<li>使用<code>depth</code>记录当前层的深度，从<code>root</code>开始每向下一层<code>++depth</code>，到达叶子节点后使用<code>max</code>记录深度中更大的那一个；</li>
<li>每返回上一层<code>--depth</code>；</li>
<li>遍历完所有叶子节点，输出最大值。</li>
</ul>
<pre><code class="language-js">var maxDepth = function(root) {
    let max = 0, depth = 0;
    dfs(root);
    return max;

    function dfs(root){
        if (!root) return;
        ++depth;
        if (!root.left &amp;&amp; !root.right) max = Math.max(max, depth);
        dfs(root.left);
        dfs(root.right);
        --depth;
    }
};
</code></pre>
<p>后来想到一种<strong>自底向上</strong>的思路来优化代码：</p>
<ul>
<li>空节点，返回深度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；</li>
<li>非空节点，返回左右树深度中较大的那个。</li>
</ul>
<p>自底向上逐步计算，最终返回树的深度：</p>
<pre><code class="language-js">var maxDepth = function(root) {
    if (!root) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[41. 数据流中的中位数]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_41/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_41/">
        </link>
        <updated>2022-06-25T05:41:07.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的堆优先队列">JavaScript 的堆（优先队列）</h3>
<p>js 中没有封装好的堆，也不能直接用数组模拟，需要自己封装一个数据结构，下面实现了一个<strong>最大堆</strong>，<strong>最小堆</strong>在<strong>最大堆</strong>的继承基础上实现：</p>
<pre><code class="language-js">class MaxHeap {
    // 堆顶节点序号为 0
    constructor() {
        this.heap = [];
    }
    // 获取父节点：(index - 1 / 2)，向下取整
    getParentIndex(index) {
        return (index - 1) &gt;&gt; 1;
    }
    // 获取左节点
    getLeftIndex(index) {
        return index * 2 + 1;
    }
    // 获取右节点
    getRightIndex(index) {
        return index * 2 + 2;
    }
    // 交换值
    swap(index1,index2) {
        const temp = this.heap[index1];
        this.heap[index1] = this.heap[index2];
        this.heap[index2] = temp;
    }
    // 上移节点 用于插入元素
    shiftUp(index) {
        //到达堆顶就不用上移了
        if(index == 0) return;
        const parentIndex = this.getParentIndex(index);
        // 最大堆要求父节点比子节点大
        if(this.heap[parentIndex] &lt; this.heap[index]) {
            // 大的值上浮
            this.swap(parentIndex,index);
            // 一直上浮至无法上浮
            this.shiftUp(parentIndex);
        }
    }
    //下移节点 用于删除元素
    shiftDown(index) {
        const leftIndex = this.getLeftIndex(index);
        const rightIndex = this.getRightIndex(index);
        // 小的值下沉至无法下沉
        if(this.heap[leftIndex] &gt; this.heap[index]) {
            this.swap(leftIndex,index);
            this.shiftDown(leftIndex);
        }
        if(this.heap[rightIndex] &gt; this.heap[index]) {
            this.swap(rightIndex,index);
            this.shiftDown(rightIndex);
        }
    }
    //插入节点 插入堆尾 使其上浮
    add(value) {
        this.heap.push(value);
        this.shiftUp(this.size() - 1);
    }
    //删除堆顶元素 移除堆尾节点 将其值给堆顶 使其下沉
    pop() {
        const top = this.heap[0];
        if (this.size() === 1) return this.heap.pop();
        else {
            // 在堆只有一个元素的时候不能将堆尾值赋给堆顶，否则会导致没有删除该元素（删了后又新增）
            this.heap[0] = this.heap.pop();
            this.shiftDown(0);
        }
        return top;
    }
    // 获取堆顶
    peek() {
        return this.heap[0];
    }
    // 获取堆的大小
    size() {
        return this.heap.length;
    }
}

class MinHeap extends MaxHeap{
    shiftUp(index) {
        if(index == 0) return;
        const parentIndex = this.getParentIndex(index);
        if(this.heap[parentIndex] &gt; this.heap[index]) {
            this.swap(parentIndex,index);
            this.shiftUp(parentIndex);
        }
    }
    shiftDown(index) {
        const leftIndex = this.getLeftIndex(index);
        const rightIndex = this.getRightIndex(index);
        if(this.heap[leftIndex] &lt; this.heap[index]) {
            this.swap(leftIndex,index);
            this.shiftDown(leftIndex);
        }
        if(this.heap[rightIndex] &lt; this.heap[index]) {
            this.swap(rightIndex,index);
            this.shiftDown(rightIndex);
        }
    }
}
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="堆">堆</h3>
<p>对于数据流，要应用堆<strong>来一个处理一个</strong>的优点，因此这道题建立一个<strong>最大堆</strong>和一个<strong>最小堆</strong>，规定：</p>
<ul>
<li><strong>最小堆</strong>保存<strong>较大</strong>的一半元素；</li>
<li><strong>最大堆</strong>保存<strong>较小</strong>的一半元素；</li>
<li>若元素个数为奇数，最小堆多保存一个元素。</li>
</ul>
<p>这样设计便可以保证：</p>
<ul>
<li>元素个数为奇数时，最小堆堆顶是中位数；</li>
<li>元素个数为偶数时，两堆堆顶的平均数是中位数。</li>
</ul>
<p>而判断元素奇偶的方法是比较<strong>两个堆的<code>size()</code></strong>，相同为偶，不同为奇；<br>
为了保证<strong>最小堆</strong>存<strong>较大</strong>，<strong>最大堆</strong>存<strong>较小</strong>的原则，在插入元素时，若意图插入一个堆，则应当<strong>先插入另一个堆，再将其堆顶元素插入目标堆</strong>。</p>
<pre><code class="language-js">var MedianFinder = function() {
    this.maxHeap = new MaxHeap();
    this.minHeap = new MinHeap();
};

/** 
 * @param {number} num
 * @return {void}
 */
MedianFinder.prototype.addNum = function(num) {
    if(this.minHeap.size() !== this.maxHeap.size()) {
        this.minHeap.add(num);
        this.maxHeap.add(this.minHeap.pop());
    } else {
        this.maxHeap.add(num);
        this.minHeap.add(this.maxHeap.pop());
    }
};

/**
 * @return {number}
 */
MedianFinder.prototype.findMedian = function() {
    return this.minHeap.size() !== this.maxHeap.size() ? this.minHeap.peek() : (this.minHeap.peek() + this.maxHeap.peek()) / 2;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[40. 最小的k个数]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_40/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_40/">
        </link>
        <updated>2022-06-25T03:52:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="topk-问题的两种解法及优劣比较">TopK 问题的两种解法及优劣比较</h3>
<h4 id="快速选择">快速选择</h4>
<p>快速选择是基于<strong>快速排序思想</strong>的方法，关于快速排序请查看<a href="https://ariessk.github.io/post/jianzhi_45/">45. 把数组排成最小的数</a>。<br>
在解决 TopK 问题时，快速排序需要对整个数组进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的排序，事实上我们只需要返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数，并不需要保证其顺序，因此只需要找到某次数组划分后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pivot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，此时返回其左边所有数组即可。<br>
对比快速排序，快速选择每次排序后可以根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">pivot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的大小关系舍弃其中一个区间，因此最终时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> （<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>4</mn></mfrac><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo>+</mo><mfrac><mi>n</mi><mi>n</mi></mfrac><mo>=</mo><mn>2</mn><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n + \frac{n}{2} + \frac{n}{4} + ... + + \frac{n}{n} = 2n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord">+</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>）：</p>
<pre><code class="language-js">var quickSelect = function(nums, l, r, k) {
    let i = l, j = r, tmp = nums[l];
    while (i &lt; j) {
        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) --j;
        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) ++i;
        tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    nums[i] = nums[l];
    nums[l] = tmp;
    // 递归终止条件 注意 slice() 是左闭右开的
    if (i === k) return nums.slice(0, k);
    return i &gt; k ? quickSelect(nums, l, i - 1, k) : quickSelect(nums, i + 1, r, k);
}
</code></pre>
<h4 id="堆">堆</h4>
<p>以前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 小问题为例，思路是用大根堆维护数组的前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 小个数，先将前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数插入大根堆，后边的数如果比堆顶小，则弹出堆顶，插入该数，最后返回堆即可，关于 JavaScript 的堆实现，请查看<a href="https://ariessk.github.io/post/jianzhi_41/">41. 数据流中的中位数</a>。</p>
<h4 id="优劣比较">优劣比较</h4>
<ul>
<li>快速选择相较于堆的优势：快速选择时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>；堆的时间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，时空复杂度均是快速选择较优；</li>
<li>快速选择相较于堆的劣势：
<ol>
<li>快速选择需要修改原数组，若不允许修改则需要拷贝数组，增加了空间复杂度；</li>
<li>对于<strong>数据流</strong>，堆来一个处理一个，最终保存的只是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大小的堆；而快速选择则需要先保存所有数据再运行算法。因此在处理数据量大的数据流时，使用堆较优。</li>
</ol>
</li>
</ul>
<h3 id="计数排序">计数排序</h3>
<p>计数排序是一种<strong>非基于比较的排序算法</strong>，在给定范围的整数排序中，快于任何比较排序算法（牺牲空间换时间），算法复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>k</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n + k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 为整数的范围：</p>
<ol>
<li>根据待排序数组中数值的范围，申请额外空间；</li>
<li>遍历待排序数组，将其每一个元素的出现次数记录到额外空间对应的元素值处；</li>
<li>遍历额外空间，按顺序与次数输出排序数组。</li>
</ol>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一sort">法一：sort()</h3>
<p>最容易想到的思路，排序输出前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个：</p>
<pre><code class="language-js">var getLeastNumbers = function(arr, k) {
    arr.sort((a, b) =&gt; a - b);
    return arr.slice(0, k);
};
</code></pre>
<h3 id="法二快速选择">法二：快速选择</h3>
<pre><code class="language-js">var getLeastNumbers = function(arr, k) {
    if (k &gt;= arr.length) return arr;
    return quickSelect(arr, 0, arr.length - 1, k);
};

var quickSelect = function(nums, l, r, k) {
    // if (l &gt;= r) return; 是快排的递归终止条件，本题不应使用，会导致递归提前结束而出错
    let i = l, j = r, tmp = nums[l];
    while (i &lt; j) {
        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) --j;
        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) ++i;
        tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    nums[i] = nums[l];
    nums[l] = tmp;
    // 递归终止条件
    if (i === k) return nums.slice(0, k);
    return i &gt; k ? quickSelect(nums, l, i - 1, k) : quickSelect(nums, i + 1, r, k);
}
</code></pre>
<h3 id="法三堆">法三：堆</h3>
<p>js 需要手写堆的数据结构：</p>
<pre><code class="language-js">var getLeastNumbers = function(arr, k) {
    let i = 0;
    const heap = new MaxHeap(), res = [];
    for (i; i &lt; k; ++i) heap.add(arr[i]);
    for (i; i &lt; arr.length; ++i) {
        if (arr[i] &lt; heap.peek()) {
            heap.pop();
            heap.add(arr[i]);
        }
    }
    while (heap.size()) res.push(heap.pop());
    return res;
};

class MaxHeap{
    constructor() {
        this.heap = [];
    }
    getParentIndex(index) {
        return (index - 1) &gt;&gt; 1;
    }
    getLeftIndex(index) {
        return index * 2 + 1;
    }
    getRightIndex(index) {
        return index * 2 + 2;
    }
    swap(index1,index2) {
        const temp = this.heap[index1];
        this.heap[index1] = this.heap[index2];
        this.heap[index2] = temp;
    }
    shiftUp(index) {
        if(index == 0) return;
        const parentIndex = this.getParentIndex(index);
        if(this.heap[parentIndex] &lt; this.heap[index]) {
            this.swap(parentIndex,index);
            this.shiftUp(parentIndex);
        }
    }
    shiftDown(index) {
        const leftIndex = this.getLeftIndex(index);
        const rightIndex = this.getRightIndex(index);
        if(this.heap[leftIndex] &gt; this.heap[index]) {
            this.swap(leftIndex,index);
            this.shiftDown(leftIndex);
        }
        if(this.heap[rightIndex] &gt; this.heap[index]) {
            this.swap(rightIndex,index);
            this.shiftDown(rightIndex);
        }
    }
    add(value) {
        this.heap.push(value);
        this.shiftUp(this.heap.length - 1);
    }
    pop() {
        const top = this.heap[0];
        if (this.size() === 1) return this.heap.pop();
        else{
            this.heap[0] = this.heap.pop();
            this.shiftDown(0);
        }
        return top;
    }
    peek() {
        return this.heap[0];
    }
    size() {
        return this.heap.length;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[#每日更新# 知识点导航]]></title>
        <id>https://AriesSK.github.io/post/zhishidian/</id>
        <link href="https://AriesSK.github.io/post/zhishidian/">
        </link>
        <updated>2022-06-25T01:55:02.000Z</updated>
        <content type="html"><![CDATA[<p>知识点</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[61. 扑克牌中的顺子]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_61/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_61/">
        </link>
        <updated>2022-06-24T11:14:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的自定义sort函数">JavaScript 的自定义sort()函数</h3>
<p><code>sort()</code>支持自定义，输入两个参数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，计算函数体中表达式（规则）的值：</p>
<ul>
<li>当值为负数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 排在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 前面，升序排序；</li>
<li>当值为正数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 排在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 后面，降序排序；</li>
<li>当值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，顺序不变。</li>
</ul>
<p>举[45. 把数组排成最小的数]{https://ariessk.github.io/post/jianzhi_45/}为例：</p>
<pre><code class="language-js">// 自定义了排序的规则：如果 a 和 b 的拼接小于 b 和 a 的拼接，则 a 应该排到 b 的前面
nums.sort((a, b) =&gt; (&quot;&quot; + a + b) - (&quot;&quot; + b + a))；
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一排序-哈希">法一：排序 + 哈希</h3>
<p>我最先想到的方法：</p>
<ol>
<li>对数组进行排序，从大到小；</li>
<li>遍历数组将非 0 元素存入<code>Set()</code>，若重复返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>，遇到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则跳出循环，记下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的个数；</li>
<li>从<code>nums[0] - 1</code>开始每轮自建，查看<code>Set()</code>中能否找到对应数字，找到则继续，找不到用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 替代，同时使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的个数自减，若找不到对应数字的同时  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的个数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>，完成遍历返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>。</li>
</ol>
<pre><code class="language-js">var isStraight = function(nums) {
    nums.sort((a, b) =&gt; b - a);
    let count = 0, num = nums[0] - 1;
    const set = new Set();
    for (const i in nums) {
        if (!nums[i]) {
            count = 5 - i;
            break;
        }
        if (!set.has(nums[i])) set.add(nums[i]);
        else return false;
    }
    for (let j = 3; j &gt;= 0; --j) {
        if (set.has(num--)) continue;
        if(count) --count;
        else return false;
    }
    return true;
};
</code></pre>
<h3 id="法二哈希-遍历">法二：哈希 + 遍历</h3>
<p>事实上用了<code>Set()</code>就无需排序，本题满足是顺子需要同时满足两个条件：</p>
<ol>
<li>无重复牌（除大小王）；</li>
<li>最大牌 - 最小牌 &lt; 5。</li>
</ol>
<p>因此在遍历过程中跳过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，使用<code>Set()</code>判重，同时记录最大值和最小值即可：</p>
<pre><code class="language-js">var isStraight = function(nums) {
    const set = new Set();
    let min = 13, max = 0;
    for (const num of nums) {
        if (!num) continue;
        max = Math.max(num, max);
        min = Math.min(num, min);
        if (set.has(num)) return false;
        else set.add(num);
    }
    return max - min &lt; 5;
};
</code></pre>
<h3 id="法三排序-遍历">法三：排序 + 遍历</h3>
<p>用了排序就无需<code>Set()</code>：</p>
<ol>
<li>先对数组执行排序；</li>
<li>判别重复： 排序数组中的相同元素位置相邻，因此可通过遍历数组，判断 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i] = nums[i + 1]nums[i]=nums[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 是否成立来判重；</li>
<li>获取最大值和最小值： 排序后，数组末位元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>4</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span></span></span></span> 为最大牌；元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[joker]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 为最小牌，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>o</mi><mi>k</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">joker</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> 为大小王的数量。</li>
</ol>
<pre><code class="language-js">var isStraight = function(nums) {
    let count = 0;
    nums.sort((a, b) =&gt; a - b);
    for (let i = 0; i &lt; 4; ++i) {
        if (!nums[i]) ++count;
        else if (nums[i] === nums[i + 1]) return false;
    }
    return nums[4] - nums[count] &lt; 5;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[45. 把数组排成最小的数]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_45/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_45/">
        </link>
        <updated>2022-06-24T04:55:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="快速排序">快速排序</h3>
<p>快速排序一轮需要遍历 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数，而每一轮理想情况下能将数组等半分割，因此需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 轮，因此平均时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，并且是不稳定的排序算法。<br>
原地快排模板，<strong>注意设置中枢在哪侧则另一侧的指针先动</strong>：</p>
<pre><code class="language-js">var quickSort = function(nums, l, r) {
    // 递归的终止条件
    if (l &gt;= r) return;
    // 这里需要声明 tmp，不能在 while 中声明
    let i = l, j = r, tmp = nums[i];
    // 声明本轮快排的中枢，这样写是为了容易看懂，其实 l 等同于 pivot
    const pivot = l;
    while (i &lt; j) {
        // 从右侧开始找第一个比中枢小的，从左侧开始找第一个比中枢大的，交换
        // 需要取等号是为了防止把 pivot 交换出去，只有在一轮遍历结束后才交换 pivot
        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[pivot]) --j;
        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[pivot]) ++i;
        tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    // 上面的交换一直重复至 i === j，此时 i 指向的位置就是中枢最终的位置，交换
    nums[i] = nums[pivot];
    nums[pivot] = tmp;
    quickSort(nums, l, i - 1);
    quickSort(nums, i + 1, r);
}
</code></pre>
<p>新建数组的快排，利用了新建左右两个数组和连接函数<code>concat()</code>，简单易懂，但需要额外的数组空间：</p>
<pre><code class="language-js">var quickSort = function(nums) {
    if (nums.length &lt;= 1) return nums;
    const pivot = nums[0];
    let left = [], right = [];
    for (let i = 1; i &lt; nums.length; ++i) {
        if (nums[i] &lt;= pivot) left.push(nums[i]);
        else right.push(nums[i]);
    }
    return quickSort(left).concat([pivot], quickSort(right));
}
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<p>这道题本质上是一个<strong>排序</strong>问题，难点就在于其排序判断的规则：</p>
<ul>
<li>若拼接字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>&gt;</mo><mi>y</mi><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x +y &gt; y + x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 排在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 之后；</li>
<li>反之，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 排在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 前面；</li>
</ul>
<p>了解排序规则后，只需要选择一种排序方法对数组进行排序即可。</p>
<h3 id="法一快速排序">法一：快速排序</h3>
<p>在原地快速排序的基础上修改判定的条件实现：</p>
<pre><code class="language-js">var minNumber = function(nums) {
    quickSort(nums, 0, nums.length - 1);
    // 通过 join() 能够把数组元素以特定的分隔符连成一个字符串，这里用 &quot;&quot; 作为分隔符
    return nums.join(&quot;&quot;);
};

var quickSort = function(nums, l, r) {
    if (l &gt;= r) return;
    let i = l, j = r, tmp = nums[l];
    while (i &lt; j) {
        while (i &lt; j &amp;&amp; &quot;&quot; + nums[j] + nums[l] &gt;= &quot;&quot; + nums[l] + nums[j]) --j;
        while (i &lt; j &amp;&amp; &quot;&quot; + nums[i] + nums[l] &lt;= &quot;&quot; + nums[l] + nums[i]) ++i;
        tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    nums[i] = nums[l];
    nums[l] = tmp;
    quickSort(nums, l, i - 1);
    quickSort(nums, i + 1, r);
}
</code></pre>
<h3 id="法二sort函数">法二：<code>sort()</code>函数</h3>
<p>通过自定义内置<code>sort()</code>函数实现排序：</p>
<pre><code class="language-js">var minNumber = function(nums) {
  return nums.sort((a, b) =&gt; {
    // 如果 a 和 b 的拼接小于 b 和 a 的拼接，则 a 应该排到 b 的前面
    if(&quot;&quot; + a + b &lt; &quot;&quot; + b + a){
      // 返回结果小于0，a 在 b 的前面
      return -1;
    }else{
      // 返回结果大于0，a 在 b 的后面
      return 1;
    }
  }).join('');
};
</code></pre>
<p>甚至还能一行写完：</p>
<pre><code class="language-js">var minNumber = function(nums) {
  return nums.sort((a, b) =&gt; (&quot;&quot; + a + b) - (&quot;&quot; + b + a)).join('');
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[54. 二叉搜索树的第k大节点]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_54/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_54/">
        </link>
        <updated>2022-06-23T08:30:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="运算符优先级">运算符优先级</h3>
<p>关于运算符的优先级，见<a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a><br>
下面两种的运算结果是一样的，这题中都可以：</p>
<pre><code class="language-js">let k = 1;
console.log(!--k); // true
k = 1;
console.log(!(--k)); // true
</code></pre>
<p>不过这样写容易出错，还是老实写：</p>
<pre><code class="language-js">let k = 1;
console.log(--k == 0); // true
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>二叉搜索树的中序遍历就是升序数组，本题进行逆向的中序遍历，并且设置<code>isFound</code>标志找到了目标，提前结束递归（题目规定不会有空树的情况）：</p>
<pre><code class="language-js">var kthLargest = function(root, k) {
	let isFound = false, res;
	dfs(root);
    return res;

    function dfs(root) {
        if (!root) return;
        dfs(root.right);
		if (isFound) return;
        if (k - 1) --k;
        else {
			res = root.val;
			isFound = true;
		}
        dfs(root.left);
    }
};
</code></pre>
<p>后来发现<code>isFound</code>可以省略，当<code>k</code>减到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时即代表找到了目标：</p>
<pre><code class="language-js">var kthLargest = function(root, k) {
	let res;
	dfs(root);
    return res;

    function dfs(root) {
        if (!root) return;
        dfs(root.right);
		if (!k) return;
        // 先自减再判断是否为 0
        if (!--k) res = root.val;
        dfs(root.left);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. 二叉搜索树与双向链表]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_36/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_36/">
        </link>
        <updated>2022-06-23T06:12:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二叉搜索树二叉查找树二叉排序树">二叉搜索树（二叉查找树，二叉排序树）</h3>
<p><strong>定义：</strong> 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。<br>
二叉搜索树（Binary Search Tree, BST）的<strong>中序遍历</strong>是<strong>升序序列</strong>。</p>
<h3 id="三种深度优先搜索">三种深度优先搜索</h3>
<p>前中后指的是<code>root</code>节点在三个节点中的位置</p>
<h4 id="前序遍历">前序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    console.log(root.val); // 操作 root 节点，比如打印其值
    dfs(root.left);
    dfs(root.right);
}
</code></pre>
<h4 id="中序遍历">中序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    dfs(root.left);
    console.log(root.val); // 操作 root 节点，比如打印其值
    dfs(root.right);
}
</code></pre>
<h4 id="后序遍历">后序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    dfs(root.left);
    dfs(root.right);
    console.log(root.val); // 操作 root 节点，比如打印其值
}
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一使用队列">法一：使用队列</h3>
<p>我一开始想到的方法，在中序遍历的同时使用一个队列按顺序保存每一个节点，再按顺序输出节点并连接：</p>
<pre><code class="language-js">var treeToDoublyList = function(root) {
    if (!root) return root;
    const list = [];
    dfs(root);
    const head = list.shift();
    let ptr = head;
    while(list.length) {
        ptr.right = list.shift();
        ptr.right.left = ptr;
        ptr = ptr.right;
    }
    ptr.right = head;
    head.left = ptr;
    return head;

    function dfs(root) {
        if (!root) return;
        dfs(root.left);
        list.push(root);
	    dfs(root.right);
    }
};
</code></pre>
<h3 id="法二原地算法">法二：原地算法</h3>
<p>事实上并不需要使用队列保存节点，使用一个``pre<code>和一个</code>curr`指针分别保存上一个节点和当前节点即可：</p>
<pre><code class="language-js">var treeToDoublyList = function(root) {
    let pre, curr;
    // 空树
    if (!root) return root;
    dfs(root);
    // 完成中序遍历后还需将头节点和尾节点连接起来成环
    head.left = pre;
    pre.right = head;
    return head;

    function dfs(curr) {
        if (!curr) return;
        // 先找到最左侧的叶子节点，是链表的头节点
        dfs(curr.left);
        if (pre) pre.right = curr;
        else head = curr;
        curr.left = pre;
        // 更新 curr
        pre = curr;
	    dfs(curr.right);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. 二叉树中和为某一值的路径]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_34/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_34/">
        </link>
        <updated>2022-06-23T03:08:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的坑">JavaScript 的坑</h3>
<p>做这道题的过程中遇到了两个坑，记录一下。</p>
<h4 id="声明全局变量">声明全局变量</h4>
<p>这道题中我需要在<code>dfs(root, target)</code>中使用<code>path</code>和<code>res</code>，所以一开始在最外层声明了变量，即全局变量，像下面这样：</p>
<pre><code class="language-js">const path = [], res = [];
var pathSum = function(root, target) {}
var dfs = function(root, target) {}
</code></pre>
<p>这样写能够通过 Leetcode 的测试用例，但同样的用例在正式提交时却会报错，这是因为上一次用例运行留下的全局变量并没有被销毁，会使之后的用例运行出错，所以应当将<code>dfs(root, target)</code>设置为局部函数：</p>
<pre><code class="language-js">var pathSum = function(root, target) {
    const path = [], res = [];
    function dfs(root, target) {}
}
</code></pre>
<h4 id="引用值">引用值</h4>
<p>这道题里的<code>path</code>是引用对象，使用<code>res.push([path])</code>是将这个引用对象放入了<code>res</code>中，而后续<code>path</code>对象改变时，<code>res</code>中的<code>path</code>的会随之改变，输出错误结果，正确处理需要深拷贝<code>path</code>存入<code>res</code>中，需要用到展开<strong>运算符</strong><code>...</code>。</p>
<pre><code class="language-js">res.push([...path]);
</code></pre>
<ul>
<li>对于一级基础数据，展开运算符实现<strong>深拷贝</strong>；</li>
<li>对于二级及以上的复杂数据，展开运算符实现<strong>浅拷贝</strong>。</li>
</ul>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>这道题需要遍历到叶子节点并且输出所有可能，因此无法剪枝。<br>
使用<code>path</code>保存当前遍历的路径，<code>res</code>保存符合要求的路径，需要注意的是在返回上一层递归的时候需要通过<code>path.pop()</code>将<code>path</code>恢复至上一层节点：</p>
<pre><code class="language-js">var pathSum = function(root, target) {
    const path = [], res = [];
    dfs(root, target);
    return res;

    // 声明函数
    function dfs(root, target) {
        if (!root) return;
        path.push(root.val);
        target -= root.val;
        // 深拷贝 path 并存入 res
        if (!root.left &amp;&amp; !root.right &amp;&amp; !target) res.push([...path]);
        dfs(root.left, target);
        dfs(root.right, target);
        // 恢复 path
        path.pop();
    };
};
</code></pre>
]]></content>
    </entry>
</feed>