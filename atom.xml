<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-08-02T03:42:01.702Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[#每日更新# 知识点导航]]></title>
        <id>https://AriesSK.github.io/post/zhishidian/</id>
        <link href="https://AriesSK.github.io/post/zhishidian/">
        </link>
        <updated>2022-08-02T15:59:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="javascript-知识点">JavaScript 知识点</h3>
<p><strong>变量</strong></p>
<ul>
<li>const 声明变量 —— <a href="https://ariessk.github.io/post/jianzhi_57/">57. 和为s的两个数字</a></li>
<li>全局变量的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
</ul>
<p><strong>函数与方法</strong></p>
<ul>
<li>函数与方法 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>赋值与传值</strong></p>
<ul>
<li>原始值与引用值 —— <a href="https://ariessk.github.io/post/jianzhi_25/">25. 合并两个排序的链表</a></li>
<li>函数传值 —— <a href="https://ariessk.github.io/post/jianzhi_13/">13. 机器人的运动范围</a></li>
<li>引用对象的问题 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>赋值运算顺序 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
</ul>
<p><strong>prototype</strong></p>
<ul>
<li>通过构造函数的 prototype 原型属性给对象添加新的方法 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>this 关键字</strong></p>
<ul>
<li>this 的指向 —— <a href="https://ariessk.github.io/post/jianzhi_59_ii/">59 - II. 队列的最大值</a></li>
</ul>
<p><strong>数值</strong></p>
<ul>
<li>Number 最值 —— <a href="https://ariessk.github.io/post/jianzhi_59_i/">59 - I.滑动窗口的最大值</a></li>
<li>安全整数 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>判空</strong></p>
<ul>
<li>通过数组长度判空 —— <a href="https://ariessk.github.io/post/jianzhi_09/">09. 用两个栈实现队列</a></li>
</ul>
<p><strong>运算符</strong></p>
<ul>
<li>运算符优先级 —— <a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a></li>
<li>展开运算符 —— <a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a></li>
<li>逻辑运算符的短路 —— <a href="https://ariessk.github.io/post/jianzhi_64/">64. 求1+2+...+n</a></li>
<li>右移运算符向下取整 按位与取余运算 —— <a href="https://ariessk.github.io/post/jianzhi_16/">16. 数值的整数次方</a></li>
<li>位运算 按位与消去最右的 0 —— <a href="https://ariessk.github.io/post/jianzhi_15/">15. 二进制中1的个数</a></li>
<li>位运算替代加法 —— <a href="https://ariessk.github.io/post/jianzhi_65/">65. 不用加减乘除做加法</a></li>
<li>按位异或找只出现一次的数字 —— <a href="https://ariessk.github.io/post/jianzhi_56_i/">56 - I. 数组中数字出现的次数 I</a></li>
<li>位运算获取每一位 为每一位赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>幂运算 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>正则表达式 —— <a href="https://ariessk.github.io/post/jianzhi_19/">19. 正则表达式匹配</a></li>
<li>位运算替代加减乘除运算 —— <a href="https://ariessk.github.io/post/top_33/">29. 两数相除</a></li>
</ul>
<p><strong>数组</strong></p>
<ul>
<li>二维数组创建 赋值 —— <a href="https://ariessk.github.io/post/jianzhi_32_ii/">32 - II. 从上到下打印二叉树 II</a></li>
<li>创建指定大小的二维数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>数字数组赋值 —— <a href="https://ariessk.github.io/post/jianzhi_56_ii/">56 - II. 数组中数字出现的次数 II</a></li>
<li>创建二维数组的问题 —— <a href="https://ariessk.github.io/post/jianzhi_29/">29. 顺时针打印矩阵</a></li>
<li>字符数组的 join —— <a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a></li>
<li>判断数组是否包含某元素 —— <a href="https://ariessk.github.io/post/top_2/">2. 两数相加</a></li>
<li>使用 map 创建二维数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>二维数组翻转替代旋转 —— <a href="https://ariessk.github.io/post/top_48/">48. 旋转图像</a></li>
</ul>
<p><strong>栈</strong></p>
<ul>
<li>数组模拟栈 —— <a href="https://ariessk.github.io/post/jianzhi_30/">30. 包含min函数的栈</a></li>
<li>栈相关的数组操作 —— <a href="https://ariessk.github.io/post/jianzhi_06/">06. 从头到尾打印链表</a></li>
<li>快速判断出栈序列合法 —— <a href="https://ariessk.github.io/post/jianzhi_31/">31. 栈的压入、弹出序列</a></li>
<li>括号匹配 —— <a href="https://ariessk.github.io/post/top_20/">20. 有效的括号</a></li>
</ul>
<p><strong>队列</strong></p>
<ul>
<li>数组模拟队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>双端队列 —— <a href="https://ariessk.github.io/post/jianzhi_32_iii/">32 - III. 从上到下打印二叉树 III</a></li>
</ul>
<p><strong>堆</strong></p>
<ul>
<li>封装堆的数据结构 —— <a href="https://ariessk.github.io/post/jianzhi_41/">41. 数据流中的中位数</a></li>
</ul>
<p><strong>链表</strong></p>
<ul>
<li>对象模拟链表 —— <a href="https://ariessk.github.io/post/jianzhi_35/">35. 复杂链表的复制</a></li>
<li>链表删除 —— <a href="https://ariessk.github.io/post/top_19/">19. 删除链表的倒数第 N 个节点</a></li>
</ul>
<p><strong>树</strong></p>
<ul>
<li>对象模拟树 树的比较 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>二叉搜索树 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>最近公共祖先 —— <a href="https://ariessk.github.io/post/jianzhi_68_ii/">68 - II. 二叉树的最近公共祖先</a></li>
</ul>
<p><strong>字符串</strong></p>
<ul>
<li>字符串中的字符赋值 —— <a href="https://ariessk.github.io/post/jianzhi_05/">05. 替换空格</a></li>
<li>字符串操作函数 —— <a href="https://ariessk.github.io/post/jianzhi_58_ii/">58 - II. 左旋字符串</a></li>
<li>转化为字符数组 获取 ASCII 值 —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>substr slice 与 substring —— <a href="https://ariessk.github.io/post/jianzhi_46/">46. 把数字翻译成字符串</a></li>
<li>slice substr 补充说明 字符 ASCII 范围 —— <a href="https://ariessk.github.io/post/jianzhi_48/">48. 最长不含重复字符的子字符串</a></li>
<li>操作函数的时间复杂度 split 说明 —— <a href="https://ariessk.github.io/post/jianzhi_58_i/">58 - I. 翻转字符单词顺序</a></li>
<li>判断数字字符 —— <a href="https://ariessk.github.io/post/jianzhi_67/">67. 把字符串转换为整数</a></li>
<li>charAt 越界 —— <a href="https://ariessk.github.io/post/top_14/">14. 最长公共前缀</a></li>
<li>字符和 ASCII 码转化 —— <a href="https://ariessk.github.io/post/top_49/">49. 字母异位词分组</a></li>
</ul>
<p><strong>哈希表</strong></p>
<ul>
<li>Map 和 Set —— <a href="https://ariessk.github.io/post/jianzhi_03/">03. 数组中重复的数字</a></li>
<li>Map 的 key 和 value —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
<li>哈希表与数组 —— <a href="https://ariessk.github.io/post/top_36/">36. 有效的数独</a></li>
<li>原地哈希表 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>排序函数</strong></p>
<ul>
<li>sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
<li>自定义 sort 函数 —— <a href="https://ariessk.github.io/post/jianzhi_61/">61. 扑克牌中的顺子</a></li>
</ul>
<p><strong>箭头函数</strong></p>
<ul>
<li>箭头函数 —— <a href="https://ariessk.github.io/post/jianzhi_53_ii/">53 - II. 0~n-1中缺失的数字</a></li>
</ul>
<p><strong>循环遍历</strong></p>
<ul>
<li>for in 与 for of —— <a href="https://ariessk.github.io/post/jianzhi_50/">50. 第一个只出现一次的字符</a></li>
<li>for in 与 for of 遍历未赋值数组 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>for in 遍历的属性是字符串 —— <a href="https://ariessk.github.io/post/jianzhi_07/">07. 重建二叉树</a></li>
<li>for in 和 for of 遍历的坑 —— <a href="https://ariessk.github.io/post/top_41/">41. 缺失的第一个正数</a></li>
</ul>
<p><strong>判断语句</strong></p>
<ul>
<li>if 判空 —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
</ul>
<hr>
<h3 id="算法知识点">算法知识点</h3>
<p><strong>思路</strong></p>
<ul>
<li>算法的优化思路 —— <a href="https://ariessk.github.io/post/top_42/">42. 接雨水</a></li>
</ul>
<p><strong>递归与迭代</strong></p>
<ul>
<li>递归总结 —— <a href="https://ariessk.github.io/post/jianzhi_24/">24. 反转链表</a></li>
<li>迭代与递归的空间复杂度 —— <a href="https://ariessk.github.io/post/jianzhi_68_i/">68 - I. 二叉搜索树的最近公共祖先</a></li>
<li>归并的递归与迭代 —— <a href="https://ariessk.github.io/post/top_23/">23. 合并K个升序链表</a></li>
</ul>
<p><strong>双指针</strong></p>
<ul>
<li>双指针 剪枝 —— <a href="https://ariessk.github.io/post/top_11/">11. 盛水最多的容器</a></li>
<li>双指针 去重 —— <a href="https://ariessk.github.io/post/top_15/">15. 三数之和</a></li>
</ul>
<p><strong>二分法</strong></p>
<ul>
<li>二分法总结 —— <a href="https://ariessk.github.io/post/jianzhi_53_i/">53 - I. 在排序数组中查找数字 I</a></li>
<li>二分法核心思想 —— <a href="https://ariessk.github.io/post/top_33/">33. 搜索旋转排序数组</a></li>
<li>二分法的问题转化 —— <a href="https://ariessk.github.io/post/top_34/">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>
</ul>
<p><strong>广度优先搜索</strong></p>
<ul>
<li>BFS —— <a href="https://ariessk.github.io/post/jianzhi_32_i/">32 - I. 从上到下打印二叉树 I</a></li>
<li>层序遍历 保存完整信息 —— <a href="https://ariessk.github.io/post/jianzhi_37/">37. 序列化二叉树</a></li>
</ul>
<p><strong>深度优先搜索</strong></p>
<ul>
<li>DFS —— <a href="https://ariessk.github.io/post/jianzhi_26/">26. 树的子结构</a></li>
<li>递归转迭代 —— <a href="https://ariessk.github.io/post/jianzhi_28/">28. 对称的二叉树</a></li>
<li>剪枝 —— <a href="https://ariessk.github.io/post/jianzhi_12/">12. 矩阵中的路径</a></li>
<li>前序 中序 后序遍历 —— <a href="https://ariessk.github.io/post/jianzhi_36/">36. 二叉搜索树与双向链表</a></li>
<li>自顶向下与自底向上 —— <a href="https://ariessk.github.io/post/jianzhi_55_ii/">55 - II. 平衡二叉树</a></li>
<li>前序 中序 后序遍历序列 —— <a href="https://ariessk.github.io/post/jianzhi_33/">33. 二叉搜索树的后序遍历序列</a></li>
<li>字符串排列 —— <a href="https://ariessk.github.io/post/top_17/">17. 电话号码的字母组合</a></li>
<li>深度优先搜索代码优化 —— <a href="https://ariessk.github.io/post/top_22/">22. 括号生成</a></li>
</ul>
<p><strong>动态规划</strong></p>
<ul>
<li>动态规划总结 —— <a href="https://ariessk.github.io/post/jianzhi_10_i/">10 - I. 斐波那契数列</a></li>
<li>二维数组的动态规划 —— <a href="https://ariessk.github.io/post/jianzhi_47/">47. 礼物的最大价值</a></li>
<li>动态规划优化 —— <a href="https://ariessk.github.io/post/top_62/">62. 不同路径</a></li>
</ul>
<p><strong>排序</strong></p>
<ul>
<li>快速排序 —— <a href="https://ariessk.github.io/post/jianzhi_45/">45. 把数组排成最小的数</a></li>
<li>快速选择 计数排序 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
<li>归并排序 —— <a href="https://ariessk.github.io/post/jianzhi_51/">51. 数组中的逆序对</a></li>
</ul>
<p><strong>TopK 问题</strong></p>
<ul>
<li>TopK 问题两种解法及比较 —— <a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a></li>
</ul>
<p><strong>贪心算法</strong></p>
<ul>
<li>贪心算法 —— <a href="https://ariessk.github.io/post/top_55/">55. 跳跃游戏</a></li>
</ul>
<p><strong>超过一半的数</strong></p>
<ul>
<li>摩尔投票法 —— <a href="https://ariessk.github.io/post/jianzhi_39/">39. 数组中出现次数超过一半的数字</a></li>
</ul>
<p><strong>剪绳子</strong></p>
<ul>
<li>两个推论 —— <a href="https://ariessk.github.io/post/jianzhi_14_i/">14 - I.剪绳子 I</a></li>
</ul>
<p><strong>滑动窗口</strong></p>
<ul>
<li>重要性质 —— <a href="https://ariessk.github.io/post/jianzhi_57_ii/">57 - II. 和为s的连续正数序列</a></li>
</ul>
<p><strong>约瑟夫环</strong></p>
<ul>
<li>推导 —— <a href="https://ariessk.github.io/post/jianzhi_62/">62. 圆圈中最后剩下的数字</a></li>
</ul>
<p><strong>有限状态自动机</strong></p>
<ul>
<li>步骤 —— <a href="https://ariessk.github.io/post/jianzhi_20/">20. 表示数值的字符串</a></li>
<li>思路 —— <a href="https://ariessk.github.io/post/top_8/">8. 字符串转换整数</a></li>
</ul>
<p><strong>质数</strong></p>
<ul>
<li>找质数 丑数 —— <a href="https://ariessk.github.io/post/jianzhi_49/">49. 丑数</a></li>
</ul>
<p><strong>正推与逆推</strong></p>
<ul>
<li>两种思路 —— <a href="https://ariessk.github.io/post/jianzhi_60/">60. n个骰子的点数</a></li>
</ul>
<p><strong>大数</strong></p>
<ul>
<li>大数处理 —— <a href="https://ariessk.github.io/post/jianzhi_17/">17. 打印从1到最大的n位数</a></li>
<li>大数越界的求余 —— <a href="https://ariessk.github.io/post/jianzhi_14_ii/">14 - II. 剪绳子 II</a></li>
</ul>
<p><strong>中位数</strong></p>
<ul>
<li>中位数小技巧 —— <a href="https://ariessk.github.io/post/top_4/">4. 寻找两个正序数组的中位数</a></li>
</ul>
<p><strong>回文串</strong></p>
<ul>
<li>中心扩散法 —— <a href="https://ariessk.github.io/post/top_5/">5. 最长回文子串</a></li>
</ul>
<p><strong>模拟</strong></p>
<ul>
<li>模拟概念 —— <a href="https://ariessk.github.io/post/top_13/">13. 罗马数字转整数</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端面试]]></title>
        <id>https://AriesSK.github.io/post/qian-duan-mian-shi/</id>
        <link href="https://AriesSK.github.io/post/qian-duan-mian-shi/">
        </link>
        <updated>2022-08-02T06:15:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前端基础">前端基础</h2>
<h3 id="html">HTML</h3>
<p><strong>h5 新特性</strong></p>
<ul>
<li>媒体播放 video 和 audio</li>
<li>本地存储 localStorge 和 sessionStorage</li>
<li>语义化标签 header、nav、article、section、footer</li>
<li>历史管理 history API</li>
<li>新增选择器 document.querySelector()、document.querySelectorAll()，可以方便地获取 DOM 元素，前者返回第一个，后者返回所有，参数为字符串类型的 &quot;选择器语法&quot;</li>
<li>拖拽释放 Drag and drop API</li>
</ul>
<p><strong>h5 新增加的表单元素</strong><br>
datalist：初始化是一个输入框，点击后出现下拉选项列表，下拉选项通过 option 标签创建<br>
keygen：密钥对生成器，提供验证用户的可靠方法，提交表单生成私钥存在客户端，公钥发到服务器<br>
output：用于不同类型的输出</p>
<p><strong>iframe</strong><br>
内联框架，往网页中引入另一个网页<br>
优点：</p>
<ul>
<li>把嵌入的网页原封不动展现</li>
<li>可以将网页公用的部分写成一个页面使用 iframe 来嵌套，有利于网页统一风格，增加代码可重用</li>
<li>多网页引用时只需修改 iframe 内容就可以更改调用它的每一个页面</li>
<li>可以解决加载缓慢的第三方内容</li>
</ul>
<p>缺点：</p>
<ul>
<li>阻塞主页面的 onload 事件</li>
<li>与主页面共享连接池，会影响页面的并行加载，并且产生的多个页面不容易管理</li>
<li>可能出现上下左右滚动条，用户体验差</li>
<li>不利于 SEO 搜索引擎优化，爬虫难处理 iframe 中的内容</li>
<li>许多移动端设备不兼容</li>
<li>增加服务器的 http 请求，大型网站不可取</li>
</ul>
<p><strong>Web Components</strong><br>
提供一套完善的封装机制使 Web 组件化能够标准化，每种框架的组件都统一标准，推动组件的复用<br>
包含四部分：</p>
<ul>
<li>Custom Elements：让开发者自定义 HTML 元素，包括组成、样式和行为</li>
<li>HTML Imports：在 HTML 中引用和复用其他 HTML 文档的方式</li>
<li>HTML Templates：模板</li>
<li>Shadow DOM：提供更好的组织页面元素的方式，类似 DOM 中的 DOM，其元素和样式独立于原始 DOM</li>
</ul>
<p><strong>浏览器渲染</strong><br>
总体流程：</p>
<ol>
<li>解析文档生成 DOM 树；解析 CSS 生成 CSS 规则树；解析 JavaScript 操作前面两种树</li>
<li>完成解析后通过 DOM 树和 CSS 规则树构造 Rendering Tree (渲染树)；然后计算树中每个渲染对象的位置，叫做回流(布局)</li>
<li>调用 UI 组件绘制(重绘)，将渲染树中的渲染对象内容显示在屏幕上</li>
</ol>
<p>构建 DOM 树：</p>
<ol>
<li>浏览器从磁盘或网络读取原始字节数据，通过指定编码转换为字符串</li>
<li>将字符串转换为 Token，其中会表示出当前 Token 是开始标签、结束标签或文本</li>
<li>根据 Token 生成节点对象，构建 DOM 树</li>
</ol>
<p>构建 CSSOM 树：与构建 DOM 树流程类似。<br>
构建渲染树：将两树组合为渲染树，只包含需要显示的节点及其样式信息(display: none; 的节点不会出现在渲染树中)<br>
布局(回流)：生成渲染树后根据渲染树进行布局，计算个节点在页面中的确切位置和大小，也被称为自动重排，布局输出盒模型，所以的相对测量值都会转化为屏幕上的<strong>绝对像素</strong><br>
绘制：布局完成后触发 Paint 事件，将渲染树转换为屏幕上的像素</p>
<p>渲染遇到 JS 文件：JS 的加载、解析和执行都会阻塞 DOM 的执行，遇到 JS 会暂停构建 DOM，等 JS 引擎运行完后再从中断的地方恢复 DOM 构建。所以想让首批渲染快就不应该在首屏加载 JS 文件，建议将 script 标签放在 body 标签底部。JS 不只是阻塞 DOM 构建，会导致 CSSOM 阻塞 DOM 构建，本来样式不改变 DOM，两者互不影响，但因为 JS 不仅能够更改 DOM，还能更改 CSSOM，而 JS 访问需要完整的 CSSOM，所以这种情况下，浏览器<strong>先下载构建 CSSOM，再执行 JS，再构建 DOM</strong></p>
<p>回流：渲染树中出现元素尺寸、布局、隐藏等改变，需要重新构建<br>
重绘：渲染树中元素更改外观，不影响布局<br>
回流必定重绘，重绘不一定回流<br>
减少回流、重绘：使用 transform 替代 top 做动画；使用 visibility 替换 display，opacity替代 visibility；不使用 table 布局；将频繁重绘或回流的节点设置为图层，避免影响别的节点</p>
<p><strong>首次渲染</strong><br>
为了尽快完成首次渲染，需要最大限度减少以下三种可变因素：</p>
<ol>
<li>关键资源数量：可能阻止网页首次渲染的资源</li>
<li>关键路径长度：受关键资源和字节大小一级依赖关系影响</li>
<li>关键字节数量</li>
</ol>
<p>优化关键渲染路径步骤：</p>
<ol>
<li>分析关键路径的资源数、字节数、长度</li>
<li>最大限度减少关键资源的数量：延迟下载，标记为异步等</li>
<li>优化关键字节数，缩短下载时间</li>
<li>优化关键资源加载顺序：尽早下载所有关键资源</li>
</ol>
<p><strong>web 标准的理解</strong><br>
web 标准是多个标准的集合，主要有结构标准、表现标准、行为标准<br>
结构标准：文档的结构与组织，对应 HTML 和 XML<br>
表现标准：文档的表现效果，对应 CSS<br>
行为标准：对网页的逻辑操作，网页的交互，对应 ECMA Script</p>
<h3 id="javascript">JavaScript</h3>
<p><strong>字面量</strong><br>
字面量，和常量差不多，其表达的信息如字面所示</p>
<p><strong>Object.assign(target, ...sources)</strong><br>
将 source 中的可枚举属性复制给 target，重名属性后面的覆盖前面的<br>
复制的是属性值，如果属性值是引用类型则复制引用地址，会出现引用共享的问题（修改其中的一个会影响到别的）</p>
<p><strong>constructor</strong><br>
constructor 属性是专门为 function 设计的，存在于每一个 function 函数的 prototype 原型属性中，是指向 prototype 所在函数的指针<br>
当我们调用该函数作为构造函数创建一个新实例后，该实例中将包含一个指向构造函数中的 prototype 的指针 proto<br>
如果以等于一个以<strong>对象字面量</strong>形式创建的新对象，constructor 不再指向该构造函数，比如</p>
<pre><code class="language-js">var person={ 
    name:&quot;Jack&quot;, 
    age:10
};
</code></pre>
<p><strong>map 和 forEach</strong></p>
<pre><code class="language-js">const arr = [1,2,3];
// map 遍历数组并给每个数翻倍
const arr1 = arr.map(x=&gt;x*2); //[2,4,6]
// forEach 遍历数组，有三个参数，分别是：当前遍历的数组元素 item、当前的元素下标 index、数组本身 arr
let sum = 0;
arr.forEach(function(item, index, arr) {
    if (arr[index] &gt; 0) sum += item;
})
</code></pre>
<p>相同点：</p>
<ol>
<li>均循环遍历数组每一项</li>
<li>只能遍历数组</li>
<li>匿名函数都支持三个参数 item、index、arr</li>
<li>匿名函数中的 this 指向 window</li>
</ol>
<p>不同点：</p>
<ol>
<li>map 创建新数组并返回，forEach 无返回</li>
<li>forEach 可以修改原数组，map 不会</li>
</ol>
<p><strong>for of</strong><br>
es6 的新增方法，只限于迭代器(iterator)，也就是<strong>可迭代</strong>对象，比如 Array、Map、Set、String、arguments、TyoedArray 等</p>
<p><strong>js 静态类型检查</strong><br>
静态类型语言：变量在定义的时候有类型声明，类型的检查发生在编译时，在运行的时候无法修改变量类型，编译器可以确定运行时需要的内存总量<br>
动态类型语言：变量在定义的时候无类型声明，类型的检查发生在运行时，在运行的时候可以修改变量类型<br>
对比：静态类型可以尽早发现错误，减少了复杂的错误处理，将数据和行为分离，也有利于代码重构；动态类型的代码比较精简，并且不需要花时间掌握类型<br>
js 的静态类型检查方法：<strong>Flow</strong>是 Facebook 的 js 静态类型检查工具，能够找出类型错误；<strong>TypeScript</strong> 在 js 的基础上添加静态类型定义，并且会被编译成 js</p>
<p><strong>indexOf</strong><br>
<code>str.indexOf(searchValue[, fromIndex])</code> 找到返回第一个匹配字串的起始下标，未找到返回 0<br>
searchValue 不设置会查找字符串 'undefined'<br>
fromIndex 是可选的，不填默认 0，负数等同 0，大于字符串长度等同于字符串长度<br>
<strong>严格区分大小写</strong></p>
<p><strong>变量提升</strong><br>
js 是单线程语言，是按顺序执行，但是一段一段地分析执行，代码执行前的编译阶段会检测到所有的变量和函数声明，添加到叫做 Lexical Environment 的 js 数据结构的内存中，所以能够在真正被声明前使用</p>
<p><strong>HashMap 和 Array</strong><br>
HashMap 散列表 是 数组 + 链表</p>
<ul>
<li>查找效率：HashMap 根据 hashcode 直接算出 index，在数组每个下标的链表只有一个元素的时候，能达到 O(1)；Array 二分查找，受数组长度影响较大</li>
<li>扩容数量：HashMap 初始长度 16，每次扩容申请双倍，扩容次数少；Array 小于 4 申请 4，小于 8 申请 8，大于 8 申请 size * 1.5，申请空间少</li>
<li>扩容效率：HashMap 扩容重新计算每个元素的位置，然后放到新的位置；Array 直接赋值数组，效率更高</li>
<li>内存消耗：Array 使用了独特的方式重复利用因为数组扩容遗留的数组空间，HashMap 没有</li>
</ul>
<p>总的来说，数据量小且使用频繁使用 Array，数据量大使用 HashMap</p>
<p><strong>HashMap 和 Object</strong><br>
两者累次允许按键存取值，删除键，检测键是否有值，不过 Map 有些优势：</p>
<ul>
<li>意外的键：Map 默认不包含任何键；Object 有原型，可能与插入的键名冲突</li>
<li>键的类型：Map 键可以是任意值；Object 只能是 String 或 Symbol</li>
<li>键的顺序：Map 键是有序的，迭代时以<strong>插入顺序</strong>返回；Object 无序</li>
<li>Size：Map 通过 size 容易获取键值对个数；Object 手动计算</li>
<li>迭代：Map 可直接迭代；获取 Object 的键值后才能迭代</li>
<li>性能：Map 在频繁增删时性能更优；Object 无优化</li>
</ul>
<p><strong>原型与原型链</strong><br>
js 每个构造函数都有 prototype 属性指向它的原型对象（实例原型），原型对象派生的子对象叫构造函数<br>
每个构造函数的实例都包含一个指向原型对象的内部指针 __proto__，该属性可以访问原型，但不存在于 Person.prototype 中，而是来自 Object.prototype，使用了 getter 方法<br>
每个原型对象有一个 constructor 指针指向其关联的构造函数<br>
如果原型对象是另一个类型的实例，则该原型对象包含着指向另一个原型的指针，层层递进就会形成实例与原型的链条，称为原型链，是图中蓝色的箭头<br>
<img src="https://AriesSK.github.io/post-images/1658986531078.png" alt="" loading="lazy"><br>
根据原型链，就可以实现 instanceOf，其原理就是判断右边变量的 prototype 是否在左边变量的原型链上即可：</p>
<pre><code class="language-js">funcion instance_of(left, right) {
    let rightProto = right.prototype;
    left = left._proto_;
    while (true) {
        if (left === null) return false;
        if (left === rightProto) return true;
        left = left._proto_;
    }
}
</code></pre>
<p><strong>强弱引用</strong><br>
对象的引用就是强引用，WeakMaps 和 WeakSets 是 js 弱引用的唯一途径，弱引用不能防止对象被垃圾回收</p>
<p><strong>垃圾回收</strong><br>
内存是临时存储变量等数据的位置，内存也有生命周期，从内存创建分配到内存读写再到内存销毁，当内存不再使用，则会被垃圾回收，防止内存泄露（在执行垃圾回收时，遗漏一些内存没有回收）<br>
所以垃圾回收机制的<strong>核心</strong>就是判断内存是否不再使用，有两种方法：</p>
<ul>
<li>引用计数：早期浏览器方法，计算内存被引用的次数，被引用一次计数 +1，不被引用一次计数 -1，计数为 0 就将内存释放回收，该方法简单有效，但循环引用会导致内存泄漏</li>
<li>标记清除：目前浏览器方法，标记所有从根节点开始能够访问到的对象，未被标记的对象就是未被强据引用的垃圾对象，被清除</li>
</ul>
<p><strong>内存泄漏</strong></p>
<ul>
<li>意外的全局变量：全局变量内存不会回收，若全局变量使用不当又没有手动回收（赋值 null），就发生内存泄漏</li>
<li>未被清空的定时器：定时器的生命周期有专门的线程维护，不挂靠在页面上，所以在某个页面使用定时器，页面销毁而没有手动清空定时器，就发生内存泄漏</li>
<li>使用不当的闭包：在一个函数内部定义一个子函数，并且子函数调用了在父函数内定义的变量，并且在父函数外部被调用，这就形成了闭包；通常函数使用完后申请的内存会被回收，但闭包会导致父函数执行完内存仍无法被回收，造成内存泄漏</li>
<li>遗漏的 DOM 引用：DOM 元素的生命周期正常取决与是否挂载在 DOM 树上，但被 js 引用时，还由 js 决定，若未清理则发生内存泄露</li>
<li>未被销毁的事件监听：垃圾回收机制不能判断事件是否需要被解除，需要手动解除，否则出现内存泄漏</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[62. 不同路径]]></title>
        <id>https://AriesSK.github.io/post/top_62/</id>
        <link href="https://AriesSK.github.io/post/top_62/">
        </link>
        <updated>2022-08-02T02:29:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="动态规划优化">动态规划优化</h3>
<p>对于当前状态只与前一状态有关的动态规划，往往可以使用<strong>滚动数组</strong>的方式降低空间复杂度。<br>
像这道题就是经典的动态规划题，基础的做法空间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的，使用滚动数组替代二维数组就可以将空间复杂度降至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>
该题的法一的优化方法值得多思考！！！</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一动态规划">法一：动态规划</h3>
<p>简单的动态规划：</p>
<pre><code class="language-js">var uniquePaths = function(m, n) {
    const dp = new Array(m).fill().map(() =&gt; new Array(n).fill(1));
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
};
</code></pre>
<p>该方法还能优化，因为当前状态只和该行和上一行有关，可以用一维数组替代二维数组：</p>
<pre><code class="language-js">var uniquePaths = function(m, n) {
    const dp = new Array(n).fill(1);
    for (let i = 1; i &lt; m; ++i) {
        for (let j = 1; j &lt; n; ++j) {
            // dp[j] 在未更新前等于上一行同列的值，dp[j - 1] 已更新是上一列同行的值，更新获得所求值
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
};
</code></pre>
<p>还可以让 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">dp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span></span></span></span> 数组长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m, n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span> 中较小的那一个，进一步降低空间复杂度。</p>
<h3 id="法二数学">法二：数学</h3>
<p>数学的方法只要能想到就简单粗暴，时空复杂度均很低。<br>
从左上角到右下角，共移动 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m + n - 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次，只需要在其中选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次向下移动的即可，排雷组合问题，总的方案数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>C</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_{m + n - 2}^{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<pre><code class="language-js">var uniquePaths = function(m, n) {
    let res = 1;
    for (let x = n, y = 1; y &lt; m; ++x, ++y) {
        res = res * x / y;
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[56. 合并区间]]></title>
        <id>https://AriesSK.github.io/post/top_56/</id>
        <link href="https://AriesSK.github.io/post/top_56/">
        </link>
        <updated>2022-08-02T02:06:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题主要用到的知识点是自定义<code>sort()</code>函数，总体来说比较简单，有一点小坑。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="排序">排序</h3>
<p>先根据 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span> 排序数组，将第一个元素作为初始元素，从第二个元素开始尝试合并：</p>
<ul>
<li>若能合并则将合并区间作为初始元素，并则尝试合并下一个元素；</li>
<li>若不能合并，则将初始元素存入结果数组，并将当前元素更新为初始元素；</li>
<li>遍历完毕后需要将最终的初始元素存入结果数组。</li>
</ul>
<p><strong>特别</strong>需要注意的是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">start</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span></span></span></span> 较小的元素的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 不一定较小，因此在合并区间的时候，合并后的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 要取两个元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">end</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> 的较大值。</p>
<pre><code class="language-js">var merge = function(intervals) {
    const res = [];
    intervals.sort((a, b) =&gt; a[0] - b[0]);
    let tmp = intervals[0];
    for (let i = 1; i &lt; intervals.length; ++i) {
        if (tmp[1] &gt;= intervals[i][0]) tmp = [tmp[0], Math.max(tmp[1], intervals[i][1])];
        else {
            res.push(tmp)
            tmp = intervals[i];
        }
    }
    res.push(tmp);
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[55. 跳跃游戏]]></title>
        <id>https://AriesSK.github.io/post/top_55/</id>
        <link href="https://AriesSK.github.io/post/top_55/">
        </link>
        <updated>2022-08-01T03:12:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="贪心算法">贪心算法</h3>
<p>贪心算法是指在对问题求解时，总是作出当前最好的选择，即不从整体最优上加以考虑，而是考虑局部最优解。<br>
所求问题的<strong>整体最优解</strong>可以通过一系列**局部最优的选择（贪心选择）**来达到。<br>
贪心算法不能保证求得的解是最佳的。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一暴力">法一：暴力</h3>
<p>一个数组中只有跳转到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 才会无法到达最后一个下标，所以对每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 进行前面的数进行判断，看能不能越过这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>：</p>
<pre><code class="language-js">var canJump = function(nums) {
    // 只有一个元素，一定能到达
    if (nums.length === 1) return true;
    // 数组最后一个下标不用判断
    for (let i = 0; i &lt; nums.length - 1; ++i) {
        if (!nums[i]) {
            // 如果第一个元素就是 $0$，不可能到达
            if (!i) return false;
            // 对每个 0 判断能否越过
            for (let j = i - 1, k = 1; j &gt;= 0; --j, ++k) {
                if (nums[j] &gt; k) break;
                if (!j) return false;
            }
        }
    }
    return true;
};
</code></pre>
<h3 id="法二贪心">法二：贪心</h3>
<p>暴力解法明显要对数组进行多次遍历，时间复杂度较高，这道题可以使用贪心的方法解决。<br>
依次遍历数组的每一个位置，实时维护<strong>最远可以到达的位置</strong>，在白能力过程中若该位置大于等于数组的最后一个位置，则可以返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，若遍历结束仍不可达，则返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span></span></span></span>：</p>
<pre><code class="language-js">var canJump = function(nums) {
    let max = 0;
    for (let i = 0; i &lt; nums.length; ++i) {
        // 可达
        if (max &gt;= nums.length - 1) return true;
        // 当前位置不可达
        if (max &lt; i) break;
        max = Math.max(i + nums[i], max);
    }
    return false;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[54. 螺旋矩阵]]></title>
        <id>https://AriesSK.github.io/post/top_54/</id>
        <link href="https://AriesSK.github.io/post/top_54/">
        </link>
        <updated>2022-08-01T01:46:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>这道题与剑指offer的<a href="https://ariessk.github.io/post/jianzhi_29/">29. 顺时针打印矩阵</a>相同，第二次做成功做出来了。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="模拟">模拟</h3>
<p>设置四个边界，每次沿着一条边界遍历后该边界向内收缩，直到全部元素遍历完，模拟整个过程即可：</p>
<pre><code class="language-js">var spiralOrder = function(matrix) {
    const res = [];
    let l = 0, t = 0, r = matrix[0].length - 1, b = matrix.length - 1;
    while (true) {
        for (let i = l; i &lt;= r; ++i) res.push(matrix[t][i]);
        if (++t &gt; b) break;
        for (let i = t; i &lt;= b; ++i) res.push(matrix[i][r]);
        if (--r &lt; l) break;
        for (let i = r; i &gt;= l; --i) res.push(matrix[b][i]);
        if (--b &lt; t) break;
        for (let i = b; i &gt;= t; --i) res.push(matrix[i][l]);
        if (++l &gt; r) break;
    }
    return res;   
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[50. Pow(x, n)]]></title>
        <id>https://AriesSK.github.io/post/top_50/</id>
        <link href="https://AriesSK.github.io/post/top_50/">
        </link>
        <updated>2022-07-31T08:20:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>本题与剑指offer<a href="https://ariessk.github.io/post/jianzhi_16/">16. 数值的整数次方</a>相同，使用快速幂 + 迭代解决，比递归空间复杂度低。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="快速幂-迭代">快速幂 + 迭代</h3>
<p>每次对幂的值进行二分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 次幂为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>：</p>
<pre><code class="language-js">var myPow = function(x, n) {
    if (!n) return 1;
    if (!x) return 0;
    let res = 1;
    if (n &lt; 0) {
        x = 1 / x;
        n = -n;
    }
    while (n) {
        // 目的将 n 拆分成 2 的整数次幂的和
        // 比如 x^10，res = x^2 * x^8；x^15，res = x^1 * x^2 * x^4 * x^8 
        if (n &amp; 1) res *= x;
        x *= x;
        n &gt;&gt;&gt;= 1;
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[49. 字母异位词分组]]></title>
        <id>https://AriesSK.github.io/post/top_49/</id>
        <link href="https://AriesSK.github.io/post/top_49/">
        </link>
        <updated>2022-07-31T06:27:37.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中字符和-ascii-码转化">JavaScript 中字符和 ASCII 码转化</h3>
<p>方法如下：</p>
<pre><code class="language-js">// 字符转 ASCII 码
&quot;a&quot;.charCodeAt(); // 97
// ASCII 码转字符
String.fromCharCode(97); // a
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一排序">法一：排序</h3>
<p>将每个字符串拆分成字符数组，然后进行排序，再恢复成字符串。异位词在排序后应当是相同的，因此可以将排序后的字符串作为键，其对应的字符串数组作为值存入哈希表中，实现分组：</p>
<pre><code class="language-js">var groupAnagrams = function(strs) {
    const map = new Map();
    for (const str of strs) {
        const arr = Array.from(str);
        // 这里用 toString() 替代 join() 也可以，前者中间有逗号，后者没有，只要保证唯一即可
        const key = arr.sort().join(&quot;&quot;); 
        // 有则获取字符串数组，无则创建空数组
        const tmp = map.has(key) ? map.get(key) : new Array();
        tmp.push(str);
        map.set(key, tmp);
    }
    return Array.from(map.values());
};
</code></pre>
<h3 id="法二计数">法二：计数</h3>
<p>法二其实也是排序，只不过将法一的排序换为计数排序，由于小写字母只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>26</mn></mrow><annotation encoding="application/x-tex">26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span> 个，所以可以用长度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>26</mn></mrow><annotation encoding="application/x-tex">26</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span></span></span></span> 的数组空间来降低排序算法的时间复杂度，关于计数排序详见<a href="https://ariessk.github.io/post/jianzhi_40/">40. 最小的k个数</a>：</p>
<pre><code class="language-js">var groupAnagrams = function(strs) {
    const map = new Map();
    for (const str of strs) {
        const arr = Array.from(str);
        const key = helper(arr);
        const tmp = map.has(key) ? map.get(key) : new Array();
        tmp.push(str);
        map.set(key, tmp);
    }
    return Array.from(map.values());

    function helper(arr) {
        const count = new Array(26).fill(0);
        let str = &quot;&quot;;
        for (const c of arr) count[c.charCodeAt() - &quot;a&quot;.charCodeAt()]++;
        for (let i = 0; i &lt; 26; ++i) {
            if (count[i]) {
                while (count[i]--) str += String.fromCharCode(&quot;a&quot;.charCodeAt() + i);
            }
        }
        return str;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[48. 旋转图像]]></title>
        <id>https://AriesSK.github.io/post/top_48/</id>
        <link href="https://AriesSK.github.io/post/top_48/">
        </link>
        <updated>2022-07-30T05:31:53.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二维矩阵翻转替代旋转">二维矩阵翻转替代旋转</h3>
<p>二维矩阵的翻转问题和旋转问题在很多情况下可以相互转换。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一原地旋转">法一：原地旋转</h3>
<p>每个元素旋转后的位置与原位置的关系还是很好找的，但难点就在如何保证<strong>不重复</strong>旋转。<br>
仔细观察后发现规律：对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的二维数组，只需要保证对第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 行的从第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个元素开始的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n - 2i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个元素进行旋转，即可保证不重复旋转。</p>
<pre><code class="language-js">var rotate = function(matrix) {
    const n = matrix.length;
    for (let i = 0; i &lt; n &gt;&gt; 1; ++i) {
        for (let j = i; j &lt; n - i - 1; ++j) {
            const tmp = matrix[i][j];
            matrix[i][j] = matrix[n - j - 1][i];
            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
            matrix[j][n - i - 1] = tmp;
        }
    }
    return matrix;
};
</code></pre>
<h3 id="法二翻转替代旋转">法二：翻转替代旋转</h3>
<p>法一的规律还是有一些难度的，比较容易出错，还有更巧妙的办法：<br>
先将数组沿水平的中心轴翻转，再将数组沿主对角线翻转，即可起到要求的旋转效果，因为这两步翻转的公式合并起来与法一的公式是相同的：</p>
<pre><code class="language-js">var rotate = function(matrix) {
    const n = matrix.length;
    for (let i = 0; i &lt; n &gt;&gt; 1; ++i) {
        for (let j = 0; j &lt; n; ++j) {
            const tmp = matrix[i][j];
            matrix[i][j] = matrix[n - i - 1][j];
            matrix[n - i - 1][j] = tmp;
        }
    }
    for (let i = 0; i &lt; n; ++i) {
        for (let j = 0; j &lt; i; ++j) {
            const tmp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = tmp;
        }
    }
    return matrix;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[46. 全排列]]></title>
        <id>https://AriesSK.github.io/post/top_46/</id>
        <link href="https://AriesSK.github.io/post/top_46/">
        </link>
        <updated>2022-07-30T05:20:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>这道题在做的时候又踩了坑，直接将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 加入了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 中，然而后续 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 的改变都会影响 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">res</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span> 中的值，记住一定要<strong>深拷贝</strong>数组！详见<a href="https://ariessk.github.io/post/jianzhi_34/">34. 二叉树中和为某一值的路径</a>。希望下次别再犯同样的错误了！</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>本题与<a href="https://ariessk.github.io/post/jianzhi_38/">38. 字符串的排列</a>解法一致并且因为元素均不重复，不用考虑剪枝问题，相对简单：</p>
<pre><code class="language-js">var permute = function(nums) {
    const res = [];
    dfs(0);
    return res;

    function dfs(x) {
        if (x === nums.length - 1) {
            // 深拷贝
            res.push([...nums]);
            return;
        }
        for (let i = x; i &lt; nums.length; ++i) {
            swap(x, i);
            dfs(x + 1);
            swap(x, i);
        }
    }

    function swap(a, b) {
        const tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>