<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://AriesSK.github.io</id>
    <title>🐧AriesSK</title>
    <updated>2022-06-23T14:37:34.030Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://AriesSK.github.io"/>
    <link rel="self" href="https://AriesSK.github.io/atom.xml"/>
    <subtitle>行百里者半九十</subtitle>
    <logo>https://AriesSK.github.io/images/avatar.png</logo>
    <icon>https://AriesSK.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 🐧AriesSK</rights>
    <entry>
        <title type="html"><![CDATA[54. 二叉搜索树的第k大节点]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_54/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_54/">
        </link>
        <updated>2022-06-23T08:30:59.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="运算符优先级">运算符优先级</h3>
<p>关于运算符的优先级，见<a href="https://ariessk.github.io/post/jianzhi_21/">21. 调整数组顺序使奇数位于偶数前面</a><br>
下面两种的运算结果是一样的，这题中都可以：</p>
<pre><code class="language-js">let k = 1;
console.log(!--k); // true
k = 1;
console.log(!(--k)); // true
</code></pre>
<p>不过这样写容易出错，还是老实写：</p>
<pre><code class="language-js">let k = 1;
console.log(--k == 0); // true
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>二叉搜索树的中序遍历就是升序数组，本题进行逆向的中序遍历，并且设置<code>isFound</code>标志找到了目标，提前结束递归（题目规定不会有空树的情况）：</p>
<pre><code class="language-js">var kthLargest = function(root, k) {
	let isFound = false, res;
	dfs(root);
    return res;

    function dfs(root) {
        if (!root) return;
        dfs(root.right);
		if (isFound) return;
        if (k - 1) --k;
        else {
			res = root.val;
			isFound = true;
		}
        dfs(root.left);
    }
};
</code></pre>
<p>后来发现<code>isFound</code>可以省略，当<code>k</code>减到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时即代表找到了目标：</p>
<pre><code class="language-js">var kthLargest = function(root, k) {
	let res;
	dfs(root);
    return res;

    function dfs(root) {
        if (!root) return;
        dfs(root.right);
		if (!k) return;
        // 先自减再判断是否为 0
        if (!--k) res = root.val;
        dfs(root.left);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[36. 二叉搜索树与双向链表]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_36/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_36/">
        </link>
        <updated>2022-06-23T06:12:05.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="二叉搜索树二叉查找树二叉排序树">二叉搜索树（二叉查找树，二叉排序树）</h3>
<p><strong>定义：</strong> 它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉排序树。<br>
二叉搜索树（Binary Search Tree, BST）的<strong>中序遍历</strong>是<strong>升序序列</strong>。</p>
<h3 id="三种深度优先搜索">三种深度优先搜索</h3>
<p>前中后指的是<code>root</code>节点在三个节点中的位置</p>
<h4 id="前序遍历">前序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    console.log(root.val); // 操作 root 节点，比如打印其值
    dfs(root.left);
    dfs(root.right);
}
</code></pre>
<h4 id="中序遍历">中序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    dfs(root.left);
    console.log(root.val); // 操作 root 节点，比如打印其值
    dfs(root.right);
}
</code></pre>
<h4 id="后序遍历">后序遍历：</h4>
<pre><code class="language-js">var dfs = function(root) {
    if (!root) return;
    dfs(root.left);
    dfs(root.right);
    console.log(root.val); // 操作 root 节点，比如打印其值
}
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一使用队列">法一：使用队列</h3>
<p>我一开始想到的方法，在中序遍历的同时使用一个队列按顺序保存每一个节点，再按顺序输出节点并连接：</p>
<pre><code class="language-js">var treeToDoublyList = function(root) {
    if (!root) return root;
    const list = [];
    dfs(root);
    const head = list.shift();
    let ptr = head;
    while(list.length) {
        ptr.right = list.shift();
        ptr.right.left = ptr;
        ptr = ptr.right;
    }
    ptr.right = head;
    head.left = ptr;
    return head;

    function dfs(root) {
        if (!root) return;
        dfs(root.left);
        list.push(root);
	    dfs(root.right);
    }
};
</code></pre>
<h3 id="法二原地算法">法二：原地算法</h3>
<p>事实上并不需要使用队列保存节点，使用一个``pre<code>和一个</code>curr`指针分别保存上一个节点和当前节点即可：</p>
<pre><code class="language-js">var treeToDoublyList = function(root) {
    let pre, curr;
    // 空树
    if (!root) return root;
    dfs(root);
    // 完成中序遍历后还需将头节点和尾节点连接起来成环
    head.left = pre;
    pre.right = head;
    return head;

    function dfs(curr) {
        if (!curr) return;
        // 先找到最左侧的叶子节点，是链表的头节点
        dfs(curr.left);
        if (pre) pre.right = curr;
        else head = curr;
        curr.left = pre;
        // 更新 curr
        pre = curr;
	    dfs(curr.right);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[34. 二叉树中和为某一值的路径]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_34/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_34/">
        </link>
        <updated>2022-06-23T03:08:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的坑">JavaScript 的坑</h3>
<p>做这道题的过程中遇到了两个坑，记录一下。</p>
<h4 id="声明全局变量">声明全局变量</h4>
<p>这道题中我需要在<code>dfs(root, target)</code>中使用<code>path</code>和<code>res</code>，所以一开始在最外层声明了变量，即全局变量，像下面这样：</p>
<pre><code class="language-js">const path = [], res = [];
var pathSum = function(root, target) {}
var dfs = function(root, target) {}
</code></pre>
<p>这样写能够通过 Leetcode 的测试用例，但同样的用例在正式提交时却会报错，这是因为上一次用例运行留下的全局变量并没有被销毁，会使之后的用例运行出错，所以应当将<code>dfs(root, target)</code>设置为局部函数：</p>
<pre><code class="language-js">var pathSum = function(root, target) {
    const path = [], res = [];
    function dfs(root, target) {}
}
</code></pre>
<h4 id="引用值">引用值</h4>
<p>这道题里的<code>path</code>是引用对象，使用<code>res.push([path])</code>是将这个引用对象放入了<code>res</code>中，而后续<code>path</code>对象改变时，<code>res</code>中的<code>path</code>的会随之改变，输出错误结果，正确处理需要深拷贝<code>path</code>存入<code>res</code>中，需要用到展开<strong>运算符</strong><code>...</code>。</p>
<pre><code class="language-js">res.push([...path]);
</code></pre>
<ul>
<li>对于一级基础数据，展开运算符实现<strong>深拷贝</strong>；</li>
<li>对于二级及以上的复杂数据，展开运算符实现<strong>浅拷贝</strong>。</li>
</ul>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>这道题需要遍历到叶子节点并且输出所有可能，因此无法剪枝。<br>
使用<code>path</code>保存当前遍历的路径，<code>res</code>保存符合要求的路径，需要注意的是在返回上一层递归的时候需要通过<code>path.pop()</code>将<code>path</code>恢复至上一层节点：</p>
<pre><code class="language-js">var pathSum = function(root, target) {
    const path = [], res = [];
    dfs(root, target);
    return res;

    // 声明函数
    function dfs(root, target) {
        if (!root) return;
        path.push(root.val);
        target -= root.val;
        // 深拷贝 path 并存入 res
        if (!root.left &amp;&amp; !root.right &amp;&amp; !target) res.push([...path]);
        dfs(root.left, target);
        dfs(root.right, target);
        // 恢复 path
        path.pop();
    };
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[13. 机器人的运动范围]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_13/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_13/">
        </link>
        <updated>2022-06-22T05:30:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的函数传值">JavaScript 中的函数传值</h3>
<p>js 中的所有函数的参数都是按值传递的，这意味着函数外的值会被复制到函数内部的参数中，如果是原始值，就跟原始值变量的复制一样，如果是引用值，就和引用值变量的复制一样。</p>
<ul>
<li><strong>按值传递参数：</strong> 外部的值被复制到函数的一个局部变量中，这两个值相互独立，互不干扰；</li>
<li><strong>按引用传递参数：</strong> 外部的值在内存中的位置会被保存到函数的一个局部变量中，意味着对局部变量的修改会反应到函数外部，这在 js 中是<strong>不可能的</strong>。<br>
<img src="https://AriesSK.github.io/post-images/1655878734447.png" alt="" loading="lazy"><br>
原始值的按值传递举例，可以看到传入参数与外部值相互独立，互不干扰：</li>
</ul>
<pre><code class="language-js">function addOne (num) {
    num += 1;
    return num;
}
let count = 20;
let res = addOne(count); // count === 20, res === 30
</code></pre>
<p>引用值的按值传递举例，如果是按引用传递，那么在新建<code>obj</code>对象的时候，<code>person</code>应该自动将指针改为指向&quot;Aries&quot;的对象，但事实上并没有。这证明了是按值传递的，传递了引用值，而引用的对象是保存在全局作用域，因此可以通过<code>obj</code>访问引用对象修改属性：</p>
<pre><code class="language-js">function setName(obj) {
    obj.name = &quot;AriesSK&quot;;
    obj = new Object();
    obj.name = &quot;Aries&quot;
    return num;
}
let person = new Object();
setName(person); // person.name === &quot;AriesSK&quot;
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一深度优先搜索">法一：深度优先搜索</h3>
<p>我的解法：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    let res = 0;
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    return dfs(visit, 0, 0, k, res);
};

var dfs = function(visit, i, j, k, res) {
    let s = &quot;&quot; + i + j, sum = 0;
    for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
    if (i &lt; 0 || i &gt;= visit.length || j &lt; 0 || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return res;
    visit[i][j] = 1;
    res = dfs(visit, i + 1, j, k, res);
    res = dfs(visit, i - 1, j, k, res);
    res = dfs(visit, i, j + 1, k, res);
    res = dfs(visit, i, j - 1, k, res);
    return ++res;
}
</code></pre>
<p><img src="https://AriesSK.github.io/post-images/1655879902391.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655879907533.png" alt="" loading="lazy"><br>
dfs 解法的优化，省略了不必要的<code>res</code>，并且由于从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(0,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 开始，由图可以看出仅通过向右和向下两个方向即可访问所有可达解：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    return dfs(visit, 0, 0, k);
};

var dfs = function(visit, i, j, k) {
    let s = &quot;&quot; + i + j, sum = 0;
    for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
    if ( i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) return 0;
    visit[i][j] = 1;
    return 1 + dfs(visit, i + 1, j, k) + dfs(visit, i, j + 1, k);
}
</code></pre>
<h3 id="法二广度优先搜索">法二：广度优先搜索</h3>
<p>bfs 需要用到队列和循环，无需递归：</p>
<pre><code class="language-js">var movingCount = function(m, n, k) {
    let res = 0;
    const visit = new Array(m);
    for (let i = 0; i &lt; m; ++i) visit[i] = new Array(n).fill(0);
    const queue = [];
    queue.unshift([0, 0]);
    while(queue.length &gt; 0) {
        let temp = queue.pop();
        let i = temp[0], j = temp[1], s = &quot;&quot; + i + j, sum = 0;
        for (let i = 0; i &lt; s.length; ++i) sum += Number(s[i]);
        if (i &gt;= visit.length || j &gt;= visit[0].length || visit[i][j] || sum &gt; k) continue;
        visit[i][j] = 1;
        ++res;
        queue.unshift([i + 1, j]);
        queue.unshift([i, j + 1]);
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[12. 矩阵中的路径]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_12/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_12/">
        </link>
        <updated>2022-06-22T02:25:20.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>通过递归的方式，先朝一个方向搜索到底，再回溯至上个节点，沿另一个方向搜索，一次类推。</p>
<h3 id="剪枝">剪枝</h3>
<p>在搜索过程中遇到<strong>该路径不可能与目标匹配成功</strong>的情况时，应当立即返回，这叫<strong>可行性剪枝</strong>。</p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="深度优先搜索-剪枝">深度优先搜索 + 剪枝</h3>
<ul>
<li>
<p><strong>递归终止条件：</strong></p>
<ul>
<li>返回 <code>false</code>：索引越界 || 当前矩阵元素与目标不匹配（包括已访问）；</li>
<li>返回<code>true</code>：<code>k === word.length - 1</code>，即<code>word</code>已完全匹配。</li>
</ul>
</li>
<li>
<p><strong>递推工作：</strong></p>
<ol>
<li>标记已访问：将<code>board[i][j]</code>修改为 <code>0</code>，防止重复搜索；</li>
<li>搜索下一元素：朝当前元素上、下、左、右四个方向进行下一层递归，使用<code>||</code>连接代表只需找到一条可行路径，记录结果至<code>res</code>；</li>
<li>还原：将<code>board[i][j]</code>还原至初始值<code>word[k]</code>。<br>
<img src="https://AriesSK.github.io/post-images/1655866202557.png" alt="" loading="lazy"><br>
<img src="https://AriesSK.github.io/post-images/1655866209347.png" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
<pre><code class="language-js">var exist = function(board, word) {
    for (let i = 0; i &lt; board.length; ++i) {
        for (let j = 0; j &lt; board[0].length; ++j) {
            if (dfs(board, word, i, j, 0)) return true;
        }
    }
    return false;
};

var dfs = function(board, word, i, j, k) {
    if (i &gt;= board.length || i &lt; 0 || j &gt; board[0].length || j &lt; 0 || board[i][j] !== word[k]) return false;
    if (k === word.length - 1) return true;
    // 标记已访问
    board[i][j] = 0;
    const res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1);
    // 恢复原数组
    board[i][j] = word[k];
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[58 - I. 翻转字符单词顺序]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_58_i/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_58_i/">
        </link>
        <updated>2022-06-21T12:29:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的正则表达式">JavaScript 的正则表达式</h3>
<p>语法：<br>
<code>/正则表达式主体/修饰符(可选)</code><br>
修饰符不区分大小写：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>执行对大小写不敏感的匹配</td>
</tr>
<tr>
<td>g</td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配</td>
</tr>
</tbody>
</table>
<p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc]</td>
<td>查找方括号之间的任何字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字</td>
</tr>
<tr>
<td>(x|y)</td>
<td>查找任何以 | 分隔的选项</td>
</tr>
</tbody>
</table>
<p>元字符是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>查找数字</td>
</tr>
<tr>
<td>\s</td>
<td>查找空白字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词边界</td>
</tr>
<tr>
<td>\uxxxx</td>
<td>查找以十六进制数 xxxx 规定的 Unicode 字符</td>
</tr>
</tbody>
</table>
<p>量词:</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>n+</td>
<td>匹配任何包含至少一个 n 的字符串</td>
</tr>
<tr>
<td>n*</td>
<td>匹配任何包含零个或多个 n 的字符串</td>
</tr>
<tr>
<td>n?</td>
<td>匹配任何包含零个或一个 n 的字符串</td>
</tr>
</tbody>
</table>
<h3 id="javascript-的字符串函数">JavaScript 的字符串函数</h3>
<p>本题中使用的一些字符串函数及它们的时间复杂度：</p>
<pre><code class="language-js">trim() // 去除字符串头尾的空格 O(n)
split() // 拆分成数组 O(n)
reverse() // 反转数组 O(n)
join() // 使用特定分隔符将数组连接成字符串 O(n)
</code></pre>
<p>其中需要重点说明<code>split()</code>举例如下：</p>
<pre><code class="language-js">let s = &quot;a  b c&quot;
s.split() // [&quot;a  b c&quot;] // 直接返回数组
s.split(&quot;&quot;) // [&quot;a&quot;, &quot; &quot;, &quot; &quot;, &quot;b&quot;, &quot; &quot;, &quot;c&quot;] // 每个字符都拆开
s.split(&quot; &quot;) // [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;] // 按空格拆，不存在的以 &quot;&quot; 占数组一个元素
s.split(&quot;&quot;, 2) // [&quot;a&quot;, &quot; &quot;] // 可以设定返回的数组元素个数
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一字符串函数">法一：字符串函数</h3>
<p>首先想到使用<code>tirm()</code>删除头尾空格，<code>split(&quot; &quot;)</code>拆分成数组，从数组末尾开始拼接：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    const arr = s.trim().split(&quot; &quot;);
    let res = &quot;&quot;;
    for (let i = arr.length - 1; i &gt;= 0; --i) {
        if (arr[i] === &quot;&quot;) continue;
        res += i ? arr[i] + &quot; &quot; : arr[i];
    }
    return res;
};
</code></pre>
<p>事实上使用字符串函数代码可以更加简洁：</p>
<pre><code class="language-js">var reverseWords = function(s) {
    return s.trim().split(/\s+/).reverse().join(' ');
};
</code></pre>
<h3 id="法二双指针">法二：双指针</h3>
<pre><code class="language-js">var reverseWords = function(s) {
    s = s.trim();
    let left = s.length - 1, right = left;
    let res = &quot;&quot;;
    // 保证 left 能够取到 0
    while (left &gt;= 0) {
        // 找到第一个空格
        while (left &gt;= 0 &amp;&amp; s.charAt(left) !== &quot; &quot;) --left;
        res += s.substring(left + 1, right + 1) + &quot; &quot;;
        // 忽略空格找到第一个字符
        while (left &gt;= 0 &amp;&amp; s.charAt(left) == &quot; &quot;) --left;
        right = left;
    }
    // 删去最后末尾多余的一个空格
    return res.trim();
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[57. 和为s的两个数字]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_57/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_57/">
        </link>
        <updated>2022-06-21T11:46:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-的const">JavaScript 的<code>const</code></h3>
<p>在允许的情况下，推荐使用<code>const</code>进行声明，<code>const</code>声明后无法重新赋值，但可以修改其属性值。</p>
<hr>
<h2 id="题解">题解</h2>
<p>双指针的简单应用：</p>
<pre><code class="language-js">var twoSum = function(nums, target) {
    let left = 0, right = nums.length - 1;
    const res = [];
    // 若允许同一个数自己加自己则取 =
    while (left &lt; right) {
        // 在值是正数的情况下，改加为减能够有效防止值溢出
        if (nums[left] &gt; target - nums[right]) --right;
        else if (nums[left] &lt; target - nums[right]) ++left;
        else {
            res.push(nums[left]);
            res.push(nums[right]);
            // 不适用 break 会导致无限循环入栈至溢出
            break;
        }
    }
    return res;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[21. 调整数组顺序使奇数位于偶数前面]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_21/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_21/">
        </link>
        <updated>2022-06-21T10:56:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-中的运算符优先级">JavaScript 中的运算符优先级</h3>
<p><img src="https://AriesSK.github.io/post-images/1655902411960.png" alt="" loading="lazy"><br>
在写代码时需要注意运算符的优先级，如下由于<code>!</code>的运算优先级高于<code>%</code>，因此加不加<code>()</code>是两种结果：</p>
<pre><code class="language-js">let num = 2;
console.log(!num % 2); // 0
console.log(!(num % 2)); // true
</code></pre>
<hr>
<h2 id="题解">题解</h2>
<p>简单的双指针运用：</p>
<pre><code class="language-js">var exchange = function(nums) {
    let left = 0, right = nums.length - 1;
    // while 中是否取等号均可
    while (left &lt; right) {
        if (nums[left] % 2) ++left;
        else if (!(nums[right] % 2)) --right;
        else {
            let temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
        } 
    }
    return nums;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[52. 两个链表的第一个公共节点]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_52/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_52/">
        </link>
        <updated>2022-06-20T14:26:09.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<p>这题使用的是一种<strong>特别</strong>的解题思路：<br>
<em>你变成我，走过我走过的路；</em><br>
<em>我变成你，走过你走过的路；</em><br>
<em>然后我们便相遇了…</em></p>
<hr>
<h2 id="题解">题解</h2>
<h3 id="法一哈希表">法一：哈希表</h3>
<p>链表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 长度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>，链表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>。<br>
看到这题的第一想法是暴力遍历，时间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>∗</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m * n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，<br>
第二想法是用哈希表，时间复杂度降低为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m + n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span> 的空间：</p>
<pre><code class="language-js">var getIntersectionNode = function(headA, headB) {
    let ptra = headA, ptrb = headB;
    const set = new Set();
    while(ptra) {
        set.add(ptra);
        ptra = ptra.next;
    }
    while(ptrb) {
        if (set.has(ptrb)) return ptrb;
        ptrb = ptrb.next;
    }
    return null;
};
</code></pre>
<h3 id="法二双指针">法二：双指针</h3>
<p>但题目要求时间复杂度降低为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。<br>
这题用了一种比较特别的思路：</p>
<ul>
<li>首先假设链表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 个节点，链表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 个节点， 它们的公共节点有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 个，它们的第一个公共节点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">nodec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span>；</li>
<li>设置指针<code>ptra</code>遍历链表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>，随后再从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">headB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> 开始遍历，到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">nodec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span> 时遍历长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mo>(</mo><mi>b</mi><mo>−</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a + (b - c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span>；</li>
<li>设置指针<code>ptrb</code>遍历链表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，随后再从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">headA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span> 开始遍历，到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">nodec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span> 时遍历长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>+</mo><mo>(</mo><mi>a</mi><mo>−</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">b + (a - c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p>可以发现此时两指针相交于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>o</mi><mi>d</mi><mi>e</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">nodec</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span></span></span></span> 并且遍历过的节点总数是相同的，这就为算法的实现提供了条件——每次使<code>ptra</code>和<code>ptrb</code>同时前进一个节点。<br>
<img src="https://AriesSK.github.io/post-images/1655994986613.jpg" alt="" loading="lazy"><br>
两条链表没有公共节点的情况就等同于两条链表的公共节点是链表结尾的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">null</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，因此在完成遍历后两指针同时为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">null</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 时会返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">null</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>：</p>
<pre><code class="language-js">var getIntersectionNode = function(headA, headB) {
    let ptra = headA, ptrb = headB;
    while (ptra !== ptrb) {
        // 注意每一轮循环只因当修改一次指针的值 若这里使用条件语句则应当用 if else
        ptra = !ptra ? headB : ptra.next;
        ptrb = !ptrb ? headA : ptrb.next;
    }
    return ptra;
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[25. 合并两个排序的链表]]></title>
        <id>https://AriesSK.github.io/post/jianzhi_25/</id>
        <link href="https://AriesSK.github.io/post/jianzhi_25/">
        </link>
        <updated>2022-06-20T14:17:46.000Z</updated>
        <content type="html"><![CDATA[<h2 id="知识点">知识点</h2>
<h3 id="javascript-赋值">JavaScript 赋值</h3>
<p>js 中将<strong>原始值</strong>赋值给另一个变量时，原始值会被复制到新变量的位置，而这两个值是完全独立，互不干扰的：</p>
<pre><code class="language-js">let num1 = 6;
let num2 = num1;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://AriesSK.github.io/post-images/1655994030158.jpg" alt="" loading="lazy"></figure>
<hr>
<p>js 中将<strong>引用值</strong>从一个变量赋值给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来：</p>
<pre><code class="language-js">let obj1 = new Object();
let obj2 = obj1;
obj1.name = &quot;AriesSK&quot;;
console.log(obj2.name); // AriesSK
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://AriesSK.github.io/post-images/1655994076135.jpg" alt="" loading="lazy"></figure>
<h2 id="题解">题解</h2>
<h3 id="法一双指针-迭代">法一：双指针 + 迭代</h3>
<p>头指针的应用，注意在比较过程中<code>newHead</code>也会变化，需要使用一个指针<code>res</code>维护它的初值，初始链表为空的情况已经包含在内，不需要另外考虑：</p>
<pre><code class="language-js">var mergeTwoLists = function(l1, l2) {
    let ptr1 = l1, ptr2 = l2, newHead = new ListNode();
    const res = newHead;
    while (ptr1 &amp;&amp; ptr2) {
        if (ptr1.val &lt;= ptr2.val) {
            newHead.next = ptr1;
            ptr1 = ptr1.next;
        } else {
            newHead.next = ptr2;
            ptr2 = ptr2.next;
        }
        newHead = newHead.next;
    }
    // 一条为空 接上另一条剩下的
    newHead.next = ptr1 ? ptr1 : ptr2;
    return res.next;
};
</code></pre>
<h3 id="法二递归">法二：递归</h3>
<p>空间复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n + m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 分别为两个链表的长度，递归调用函数需要消耗栈空间，栈空间的大小取决于递归调用的深度，这里最多调用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n + m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 次：</p>
<pre><code class="language-js">var mergeTwoLists = function(l1, l2) {
    if (!l1) return l2;
    else if (!l2) return l1;
    else if (l1.val &lt;= l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>